{"meta":{"title":"李飞阳","subtitle":"PM、Coder、Data mining","description":"Python ,Code,Data mining","author":"Wing Lee","url":"http://feiyang.li"},"pages":[{"title":"tags","date":"2016-10-17T10:38:37.000Z","updated":"2016-10-17T10:40:36.465Z","comments":false,"path":"tags/index.html","permalink":"http://feiyang.li/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第2.1题：Python统计日记最重要的词","slug":"python-camp2-1","date":"2017-02-17T09:04:55.000Z","updated":"2017-02-17T09:07:37.504Z","comments":true,"path":"2017/02/17/python-camp2-1/","link":"","permalink":"http://feiyang.li/2017/02/17/python-camp2-1/","excerpt":"题目来自：Python 练习册。题目2.1： 你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。","text":"题目来自：Python 练习册。题目2.1： 你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。 参考代码123456789101112131415161718192021222324252627282930#coding: utf-8import re, osfrom collections import Counter# 目标文件所在目录PATH = 'D:'def getCounter(source): #输入一个英文的纯文本文件，统计其中的单词出现的个数 with open(source) as f: data = f.read() data = data.lower()#字母全部小写 datalist = re.split(r'[\\s]+', data)#根据空白字符，将data进行划分 return Counter(datalist)def run(PATH): # 切换到目标文件所在目录 os.chdir(PATH) # 遍历该目录下的txt文件 total_counter = Counter() # 生成Counter()对象 for i in os.listdir(os.getcwd()): if os.path.splitext(i)[1] == '.txt':#分离扩展名 total_counter += getCounter(i)# 多个Counter()叠加 return total_counter.most_common()#Counter对象转化为list格式if __name__ == '__main__': dic = run(PATH) for i in range(len(dic)): print('%15s ----&gt; %3s' % (dic[i][0],dic[i][1])) 出现的错误编码问题UnicodeDecodeError: ‘gbk’ codec can’t decode byte…两种解决方法： decode(‘utf-8’)重新编码一下 123fp = open(filename,'rb')content = fp.read().decode('utf-8') open方法指定参数encoding=’UTF-8’: 1content= open('filename', mode='rb', encoding='UTF-8') 但是得注意一下，原文到底是不是UTF-8编码。反正Python编码这里是个大坑，多加小心。 文件名、目录名或卷标语法不正确Path里边的斜杠是 / 不是 \\PATH = &#39;E:/Python/pydata-book-master/ch02&#39; AttributeError: ‘list’ object has no attribute ‘…看看那个object到底是什么，print(type(name)) ，然后再查查其对应的函数。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://feiyang.li/tags/自然语言处理/"}]},{"title":"第1.9题：Python对密码加密","slug":"python-camp9","date":"2017-02-16T13:59:43.000Z","updated":"2017-02-17T04:33:14.710Z","comments":true,"path":"2017/02/16/python-camp9/","link":"","permalink":"http://feiyang.li/2017/02/16/python-camp9/","excerpt":"题目来自：Python 练习册。题目1.9： 通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。","text":"题目来自：Python 练习册。题目1.9： 通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。 思路：salt 加 hash 来单向转换密码明文 参考代码以下给出Py2和Py3两段代码，输出的内容是一样的。因为加密之后的内容不是unicode代码，所以存储可能不方便，可以使用base64.b64encode(hashed)转化为base64编码格式。 输出结果 Python2代码123456789101112131415161718192021222324252627282930313233import os,base64from hashlib import sha256from hmac import HMACdef encrypt_password(password, salt=None): \"\"\"Hash password on the fly.\"\"\" if salt is None: salt = os.urandom(8) # 64 bits. assert 8 == len(salt) assert isinstance(salt, str) if isinstance(password, unicode): password = password.encode('UTF-8') assert isinstance(password, str) result = password for i in xrange(10): result = HMAC(result, salt, sha256).digest() return salt + resultdef validate_password(hashed, input_password): return hashed == encrypt_password(input_password, salt=hashed[:8]) if __name__==\"__main__\": hashed = encrypt_password('secret password') assert validate_password(hashed, 'secret password') print (hashed) print (base64.b64encode(hashed)) print (base64.b64decode(base64.b64encode(hashed))) Python3代码123456789101112131415161718192021222324252627282930313233343536import os, base64from hashlib import sha256from hmac import HMACdef encrypt_password(password, salt=None): \"\"\"Hash password on the fly.\"\"\" if salt is None: salt = os.urandom(8) # 64 bits. assert 8 == len(salt) assert isinstance(salt, bytes) assert isinstance(password, str) if isinstance(password, str): password = password.encode('UTF-8') assert isinstance(password, bytes) result = password for i in range(10): result = HMAC(result, salt, sha256).digest() return salt + resultdef validate_password(hashed, input_password): return hashed == encrypt_password(input_password, salt=hashed[:8])if __name__ == \"__main__\": hashed = encrypt_password('secret password') assert validate_password(hashed, 'secret password') print (hashed) print (base64.b64encode(hashed)) print (base64.b64decode(base64.b64encode(hashed))) Python编码问题一开始直接在Python3环境运行第一段代码的时候，总会报错NameError: global name &#39;unicode&#39; is not defined，百思不得其解。 查了资料，才发现是因为Python更新的时候，Python 3 renamed the unicode type to str, the old str type has been replaced by bytes。在Python升级文档内可以查到相关内容，也就是unicode直接改名str，str改名成bytes。Python2和Python3，在编码方面挖下太多的坑举个简单的例子：12isinstance(u'中文', unicode) #python2内是正确的isinstance(u'中文', str) #python3内是正确的 Python3内的unicode和bytesPython 3最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。 在将字符串存入磁盘和从磁盘读取字符串的过程中，Python 自动地帮你完成了编码和解码的工作，你不需要关心它的过程，例如你能把一个中文赋值给字符串。而使用 bytes 类型，实质上是告诉 Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式。 参考链接：http://zhuoqiang.me/password-storage-and-python-example.htmlhttp://www.ituring.com.cn/article/61192","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"密码处理","slug":"密码处理","permalink":"http://feiyang.li/tags/密码处理/"}]},{"title":"第1.8题：文本读取转化","slug":"python-camp8","date":"2017-02-15T14:07:40.000Z","updated":"2017-02-15T14:09:04.064Z","comments":true,"path":"2017/02/15/python-camp8/","link":"","permalink":"http://feiyang.li/2017/02/15/python-camp8/","excerpt":"题目来自：Python 练习册。题目1.8： 将纯文本文件 student.txt为学生信息,，写到 student.xls 文件内。","text":"题目来自：Python 练习册。题目1.8： 将纯文本文件 student.txt为学生信息,，写到 student.xls 文件内。 题目描述题目1.8： 纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示： { &quot;1&quot;:[&quot;张三&quot;,150,120,100], &quot;2&quot;:[&quot;李四&quot;,90,99,95], &quot;3&quot;:[&quot;王五&quot;,60,66,68] } 请将上述内容写到 student.xls 文件中，如下图所示： student.xls 这个题使用到文件读取，数据读取，Xls文件输出三部分内容。 文件读取使用open()函数12with open('student.txt') as f: content = f.read() 数据读取1d = json.loads(content) xls文件输出12345678file = xlwt.Workbook()# 添加sheettable = file.add_sheet('test')for row, i in enumerate(list(d)): table.write(row, 0, i) for col, j in enumerate(d[i]): table.write(row, col + 1, j)file.save('student.xls') 参考代码student.txt 可以在这里下载~ http://cdn.mmmxcc.cn/blog/student.txt 1234567891011121314151617181920212223#coding: utf-8import osimport jsonimport xlwt# 存放文件的目录filepath = 'D:'os.chdir(filepath)# 读取文件内容with open('student.txt') as f: content = f.read()# 转为jsond = json.loads(content)file = xlwt.Workbook()# 添加sheettable = file.add_sheet('test')for row, i in enumerate(list(d)): table.write(row, 0, i) for col, j in enumerate(d[i]): table.write(row, col + 1, j)file.save('student.xls')","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://feiyang.li/tags/自然语言处理/"}]},{"title":"第1.7题：Python敏感词检测","slug":"python-camp7","date":"2017-02-15T11:28:20.000Z","updated":"2017-02-16T14:24:00.864Z","comments":true,"path":"2017/02/15/python-camp7/","link":"","permalink":"http://feiyang.li/2017/02/15/python-camp7/","excerpt":"题目来自：Python 练习册。题目1.7：敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。","text":"题目来自：Python 练习册。题目1.7：敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。 Python find()方法描述Python find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。 语法find()方法语法：str.find(str, beg=0, end=len(string)) 参数str – 指定检索的字符串beg – 开始索引，默认为0。end – 结束索引，默认为字符串的长度。 返回值如果包含子字符串返回开始的索引值，否则返回-1。 实例以下实例展示了find()方法的实例：12345678info = 'abca'print info.find('a')##从下标0开始，查找在字符串里第一个出现的子串，返回结果：0info = 'abca'print info.find('a',1)##从下标1开始，查找在字符串里第一个出现的子串：返回结果3info = 'abca'print info.find('333')##返回-1,查找不到返回-1 Python strip()方法描述Python strip() 方法用于移除字符串头尾指定的字符（默认为空格）。 语法strip()方法语法：str.strip([chars]); 参数chars – 移除字符串头尾指定的字符。 返回值返回移除字符串头尾指定的字符生成的新字符串。 实例以下实例展示了strip()函数的使用方法：12str = \"0000000this is string example....wow!!!0000000\";print str.strip( '0' ); 以上实例输出结果如下：this is string example….wow!!! Python map()方法描述很简单，第一个参数接收一个函数名，第二个参数接收一个可迭代对象。 语法map(f, iterable)基本上等于：[f(x) for x in iterable] 实例123456&gt;&gt;&gt; def add100(x):... return x+100... &gt;&gt;&gt; hh = [11,22,33]&gt;&gt;&gt; map(add100,hh)[111, 122, 133] 参考代码filtered_words.txt将文件下载到D盘内即可1234567891011121314151617181920212223242526#coding: utf-8import cmd# 存放敏感词文件的路径filtered_words_filepath = 'd:/filtered_words.txt'class CLI(cmd.Cmd): def __init__(self): #初始基础类方法 cmd.Cmd.__init__(self) # 初始化，提取敏感词列表 self.intro = 'Python敏感词检测:' #输出欢迎信息 f = open(filtered_words_filepath) self.words = list(map(lambda i: i.strip('\\n'), f.readlines())) self.prompt = \"&gt;&gt;&gt; \" # 定义提示符 def default(self, line): if any([i in line for i in self.words]): print ('Freedom') else: print ('Human Rights') def do_quit(self, arg): exit() return Trueif __name__ ==\"__main__\": cli = CLI() cli.cmdloop() 其实这个地方出现过一个错误，map()形成的iterable是一次性的。 也就是如果不保存，直接迭代之后，self.words =map(lambda i: i.strip(&#39;\\n&#39;), f.readlines())self.words 里边的数据会丢失，因此这个地方加了一个list()函数，将iterable到处保存。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://feiyang.li/tags/自然语言处理/"}]},{"title":"Coursera ML笔记-机器学习基础概念","slug":"Coursera-ML","date":"2017-02-14T11:19:17.000Z","updated":"2017-02-14T11:24:58.929Z","comments":true,"path":"2017/02/14/Coursera-ML/","link":"","permalink":"http://feiyang.li/2017/02/14/Coursera-ML/","excerpt":"在学习的过程中，抓住基本概念是非常重要的，这样可以防止自己陷入某些细节中无法自拔，可以让自己站在比较宏观的层面上看待问题。 更多见：李飞阳","text":"在学习的过程中，抓住基本概念是非常重要的，这样可以防止自己陷入某些细节中无法自拔，可以让自己站在比较宏观的层面上看待问题。 更多见：李飞阳 机器学习（Machine Learning） Coursera上机器学习课程的介绍中，第一句话是： Machine learning is the science of getting computers to act without being explicitly programmed. 机器学习是让电脑自己学会如何处理问题，而不需要人们刻意的编程。 Andrew Ng老师的讲义中（Coursera）给出的定义：Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”Example: playing checkers. · E = the experience of playing many games of checkers · T = the task of playing checkers. · P = the probability that the program will win the next game. 周志华的《机器学习》中定义：机器学习正是这样一门学科，它致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。在计算机系统中，“经验”通常以“数据”的形式存在，因此，机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”（model）的算法，即“学习算法”（learning algorithm）。有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时，模型会给我们提供相应的判断。 有监督学习（Supervised Learning） 维基百科Supervised learning is the machine learningtask of inferring a function from labeled training data.The training data consist of a set of training examples. In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a “reasonable” way. Example: Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem. We could turn this example into a classification problem by instead making our output about whether the house “sells for more or less than the asking price.” Here we are classifying the houses based on price into two discrete categories 无监督学习（Unsupervised Learning）维基百科： Unsupervised learning is the machine learning task of inferring a function to describe hidden structure from unlabeled data. Since the examples given to the learner are unlabeled, there is no error or reward signal to evaluate a potential solution. This distinguishes unsupervised learning from supervised learning and reinforcement learning. Unsupervised learning is closely related to the problem of density estimation in statistics.[1] However unsupervised learning also encompasses many other techniques that seek to summarize and explain key features of the data. Many methods employed in unsupervised learning are based on data mining methods used to preprocess data. Example: Clustering: Take a collection of 1000 essays written on the US Economy, and find a way to automatically group these essays into a small number that are somehow similar or related by different variables, such as word frequency, sentence length, page count, and so on. Associative: Suppose a doctor over years of experience forms associations in his mind between patient characteristics and illnesses that they have. If a new patient shows up then based on this patient’s characteristics such as symptoms, family medical history, physical attributes, mental outlook, etc the doctor associates possible illness or illnesses based on what the doctor has seen before with similar patients. This is not the same as rule based reasoning as in expert systems. In this case we would like to estimate a mapping function from patient characteristics into illnesses. 解释一下： 首先看什么是学习（learning）？一个成语就可概括：举一反三。此处以高考为例，高考的题目在上考场前我们未必做过，但在高中三年我们做过很多很多题目，懂解题方法，因此考场上面对陌生问题也可以算出答案。机器学习的思路也类似：我们能不能利用一些训练数据（已经做过的题），使机器能够利用它们（解题方法）分析未知数据（高考的题目）？ 最简单也最普遍的一类机器学习算法就是分类（classification）。对于分类，输入的训练数据有特征（feature），有标签（label）。所谓的学习，其本质就是找到特征和标签间的关系（mapping）。这样当有特征而无标签的未知数据输入时，我们就可以通过已有的关系得到未知数据标签。 在上述的分类过程中，如果所有训练数据都有标签，则为有监督学习（supervised learning）。如果数据没有标签，显然就是无监督学习（unsupervised learning）了，也即聚类（clustering）。 目前分类算法的效果还是不错的，但相对来讲，聚类算法就有些惨不忍睹了。确实，无监督学习本身的特点使其难以得到如分类一样近乎完美的结果。这也正如我们在高中做题，答案（标签）是非常重要的，假设两个完全相同的人进入高中，一个正常学习，另一人做的所有题目都没有答案，那么想必第一个人高考会发挥更好，第二个人会发疯。 这时各位可能要问，既然分类如此之好，聚类如此之不靠谱，那为何我们还可以容忍聚类的存在？因为在实际应用中，标签的获取常常需要极大的人工工作量，有时甚至非常困难。例如在自然语言处理（NLP）中，Penn Chinese Treebank在2年里只完成了4000句话的标签…… 这时有人可能会想，难道有监督学习和无监督学习就是非黑即白的关系吗？有没有灰呢？Good idea。灰是存在的。二者的中间带就是半监督学习（semi-supervised learning）。对于半监督学习，其训练数据的一部分是有标签的，另一部分没有标签，而没标签数据的数量常常极大于有标签数据数量（这也是符合现实情况的）。隐藏在半监督学习下的基本规律在于：数据的分布必然不是完全随机的，通过一些有标签数据的局部特征，以及更多没标签数据的整体分布，就可以得到可以接受甚至是非常好的分类结果。（此处大量忽略细节） 因此，learning家族的整体构造是这样的：有监督学习（分类，回归）↕半监督学习（分类，回归），transductive learning（分类，回归）↕半监督聚类（有标签数据的标签不是确定的，类似于：肯定不是xxx，很可能是yyy）↕无监督学习（聚类） 总结在Coursera上Andrew Ng的课程中，主要涉及： Supervised Learning，包括Linear Regression、Logistic Regression、Neural Networks、Support Vector Machines； Unsupervised Learning，包括Clustering、Dimensionality Reduction、Anomaly Detection、Recommender Systems。 参考资料Coursera - Machine learning( Andrew Ng) https://www.coursera.org/learn/machine-learning什么是无监督学习？ https://www.zhihu.com/question/23194489","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"}]},{"title":"《结网》","slug":"jiewang","date":"2017-02-13T13:39:16.000Z","updated":"2017-02-13T14:09:06.067Z","comments":true,"path":"2017/02/13/jiewang/","link":"","permalink":"http://feiyang.li/2017/02/13/jiewang/","excerpt":"对于产品经理来说，自己所负责的产品的表现就是自己的履历。","text":"对于产品经理来说，自己所负责的产品的表现就是自己的履历。 入坑说来惭愧，最初进入产品经理这个职位，是因为大二在OPPO的实习。 搬砖的地方 当时实习的时候，认识了许和高，许 瘦瘦高高的风格很让人喜欢。 许 当时应该算产品助理，但是不知道自己具体该做什么。 最开始只是单纯的觉得HR纪姐姐真的好漂亮，如果不能进去实习，岂不后悔莫及。 进入OPPO，很多时间是跟费费和飞哥玩，认识了女神。我们玩得时候，女神总默默的拿出自己的小Iphone用百词斩背单词。 有一次做展示的时候，和高 有吵，记得争论是OPPO论坛的改版问题。 我第一次对产品岗心生退意 更深大三暑假，走上了考研路，想想这一辈子应该也没有这样一次机会，这么长时间的去做一件事情。可以与喜欢的女孩，朝夕相处。 妹子 那时最大的梦想就是一起去吃 老五烧烤 吃 去年的这个时间，知道自己成绩后一脸懵逼。没有多想，立刻动身找工作。 当时有很多互联网公司在春招，因为 高 的推荐，拿到了搜狐的offer。之后又拿到了360的offer，都是做产品经理。选择了数字公司，做线上商城业务。 期间发现自己可以调剂，碾转奔波的面试，终于可以继续在象牙塔读书。 USTC 在360的时候，跟卢老师系统的学习了一些产品方面的知识，后来又和涛哥共事了很久。慢慢的掌握了一些产品经理的技能，比如不要重复发明轮子。现有的组件可以用上的，就尽量不要重复开发，提高共用性，需求的快速化迭代。如何将已有的功能，逻辑性的展示出来。 疾病症状搜索 之后，自己接手360全球好药的产品工作。看着薛姐、静姐、俊哥哥、欣欣，他们付出那么多心血，真心希望这个项目可以成功。页面还是我画的那个样子，好熟悉，时间过得真快。 一开始，这个项目跟我对接业务的是金，金 是武大生物学硕士。真是条条大道通CS，后来金跳槽去了杭州。之后跟我对接的是超哥，超哥又跳槽去了拼少少。我都有点怀疑自己了…… 上次跟超超聊，又升值加薪了，就差一个白富美。 期间发生了一些事，再加上我本身不喜与人当面争执，又一次对产品岗位心生退意 后记现在虽然已经远离产品经理这个角色，但是给我留下很多习惯。比如对一些细节会较真，会对一些人或事看的比较淡。 当初计划大四面试前看，但是那时图书馆没这本书。 谁知今天正好遇见它，也许是缘分吧。读了一些，做此感想。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"臭臭","slug":"臭臭","permalink":"http://feiyang.li/tags/臭臭/"}]},{"title":"第1.6题：使用Python生成字母验证码图片","slug":"python-camp6","date":"2017-02-13T05:36:02.000Z","updated":"2017-02-13T05:38:30.441Z","comments":true,"path":"2017/02/13/python-camp6/","link":"","permalink":"http://feiyang.li/2017/02/13/python-camp6/","excerpt":"题目来自：Python 练习册。题目1.6：使用 Python 生成类似于下图中的字母验证码图片查看更多于本人博客：李飞阳","text":"题目来自：Python 练习册。题目1.6：使用 Python 生成类似于下图中的字母验证码图片查看更多于本人博客：李飞阳 参考代码我们用随机颜色填充背景，再画上文字，最后对图像进行模糊，得到验证码图片如下：12345678910111213141516171819202122232425262728293031323334353637383940from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random# 随机字母:def rndChar(): return chr(random.randint(65, 90))# 随机颜色1:def rndColor(): return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))# 随机颜色2:def rndColor2(): return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))def compose(): # 240 x 60: width = 240 height = 60 image = Image.new('RGB', (width, height), (255, 255, 255)) # 创建Font对象: font = ImageFont.truetype('C:/windows/fonts/Arial.ttf', 36) # 创建Draw对象: draw = ImageDraw.Draw(image) # 填充每个像素: for x in range(width): for y in range(height): draw.point((x, y), fill=rndColor()) # 输出文字: letter = [] for t in range(4): letter.append(rndChar()) draw.text((60 * t + 10, 10), letter[t], font=font, fill=rndColor2()) # 模糊: image.save('code.jpg', 'jpeg') image = image.filter(ImageFilter.BLUR) image.save('filter.jpg', 'jpeg') print (letter)compose() 输出验证码原本数字： 运行结果 模糊前： mark image = image.filter(ImageFilter.BLUR) # 模糊:模糊后： mark 如果运行的时候报错：IOError: cannot open resource 这是因为PIL无法定位到字体文件的位置，可以根据操作系统提供绝对路径，比如：&#39;/Library/Fonts/Arial.ttf&#39; 要详细了解PIL的强大功能，请请参考Pillow官方文档：https://pillow.readthedocs.io/en/4.0.x/ 小结PIL提供了操作图像的强大功能，可以通过简单的代码完成复杂的图像处理。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"图片处理","slug":"图片处理","permalink":"http://feiyang.li/tags/图片处理/"}]},{"title":"第1.5题：使用Python处理图片","slug":"python-camp5","date":"2017-02-13T02:33:53.000Z","updated":"2017-02-13T05:37:50.976Z","comments":true,"path":"2017/02/13/python-camp5/","link":"","permalink":"http://feiyang.li/2017/02/13/python-camp5/","excerpt":"题目来自：Python 练习册。题目1.5：你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。查看更多于本人博客：李飞阳","text":"题目来自：Python 练习册。题目1.5：你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。查看更多于本人博客：李飞阳 使用python来处理图片是非常方便的，下面提供一小段python处理图片的代码，需要安装图像处理工具包PIL(Python Image Library)。 安装PIL我用的是anaconda(一个开源的Python发行版本，包含了常用的数据科学库。)，其中自带了PIL和Pillow，但是不能用，真是(ಥ _ ಥ) 。检查自己电脑是否支持PIL，可以在Python shell 页面输入：1from PIL import Image Image 如果没有报错的话，就可以代表正常。如果报错说[importError: No module named images]，使用pip卸载pillow，重新安装应该就可以了. 参考代码稍微注意一下，图片的宽高是两个数字，不能理所当然的认为图片都是宽大于高的。12345678910111213141516171819202122232425262728import os from PIL import Image pathDir='F:\\CloudMusic' os.chdir(pathDir) def get_imglist(): #获取照片名称list img_list=[] list_dir=os.listdir(pathDir) for x in list_dir: if '.jpg' in x: img_list.append(x) else: print(\"This is not a picture: \"+x) return img_list def modify_imgsize(): for filename in get_imglist(): img=Image.open(filename) if max(img.size)&gt;1136: value=max(img.size)/1136.0 newsize =(int(img.size[0]/value),int(img.size[1]/value)) newimg = img.resize(newsize,Image.ANTIALIAS) #修改大小 newimg.save('new_'+filename) else: print(\"This picture is availabe:\"+filename) if __name__ == '__main__': modify_imgsize()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"图片处理","slug":"图片处理","permalink":"http://feiyang.li/tags/图片处理/"}]},{"title":"第1.4题：统计文件中单词出现个数","slug":"python_camp4","date":"2017-02-11T12:16:52.000Z","updated":"2017-02-17T06:12:58.915Z","comments":true,"path":"2017/02/11/python_camp4/","link":"","permalink":"http://feiyang.li/2017/02/11/python_camp4/","excerpt":"题目来自：Python 练习册。今天做第四题：任一英文的纯文本文件，统计其中的单词出现个数。","text":"题目来自：Python 练习册。今天做第四题：任一英文的纯文本文件，统计其中的单词出现个数。 铺垫工作这一期的铺垫工作比较多，所以单独写了一篇文章，详见 Python正则表达式 正文部分题目内容任一个英文的纯文本文件，统计其中的单词出现的个数。参考英文：12345678910111213141516171819202122232425262728If you are looking for someone you can pour out your love to, let me suggest the empowered woman. The empowered woman knows what she wants, knows how to get it, knows how to live fully, and she knows how to love you back without needing anyone’s approval or recognition. An empowered woman is unarguably one of the most magnificent beings you will ever come in contact with. Read on and find 10 reason why you should absolutely love and embrace the empowered women in your life! . 1. She knows how to love you in returnIt is difficult to give what you don’t have. It is impossible to love someone and feel fulfilled when they can’t love you in return because they don’t love themselves. This will never happen to you when you love an empowered woman. She loves herself (not in a narcissistic manner). In turn, she appreciates who you are and loves you in return. She will love you just like you deserve to be loved. 2. She will inspire youWhen life puts you down and you are at the end of your rope, the empowered woman will be there to see you through. Her drive, enthusiasm and (at times) hopeless optimism will inspire you to carry on despite the obstacles you face. 3. She is not afraid of failureWhile many out there are thoroughly terrified of failure, the empowered woman understands that failures are simply stepping stones in life. How can you not love someone that is thoroughly unafraid to try, fail, and give it a shot all over again?! 4. She is all about the legacyWhile most people are focused on the car, the house, the job, and corner office; the empowered woman is focused on leaving a legacy that will inspire others and change the world. The empowered woman is focused on empowering others to maximize their potential and fulfill their purpose. She is all about inspiring others to look beyond themselves and live a life of service to others. 5. She can laugh at her mistakes……and learn from them as well! She understands mistakes are part of the journey. The empowered woman can laugh and learn from her mistakes to ensure they never happen again. 6. She can be vulnerableThe empowered woman understands there is no debt in relationships without vulnerability. Although she is emotionally strong, she is willing to laugh and cry with you because all of these emotions are an essential part of life. 7. She can speak her mindWhile everyone else is too concerned with what others may think or say, the empowered woman is not afraid to speak her mind. She understands that her value comes from within, not from what others say or think about her. 8. She knows when to remain quietShe lives by Abe Lincoln’s words, “Better to remain silent and be thought a fool, than to speak out and remove all doubt.” 9. She knows how to have funWhether it is at the symphony or at a ball game, the empowered woman understands life is made up of experiences with people – not the places you go. She is able to live in the moment and enjoy it fully without being concerned for the future. After all, who’s got a guaranteed future? 10. She is not afraid of changeWhile most people rather continue on living unfulfilled lives as long as their comfort zone remains intact, the empowered woman is all about embracing change. She understands growth cannot happen without change. She understands that change is the gift life offers you to choose your destiny. Therefore, she is not afraid of change because it is her stepping stone towards success. 下载链接将文件下载到python的工作路径里去，如果不知道哪里是工作路径，输入123456import os#获取当前工作目录os.getcwd()#更改当前工作目录os.chdir('d:\\')os.getcwd() 参考代码每一步我都尽量附带上了解释123456789101112131415161718192021222324252627# coding=utf-8from collections import defaultdictimport re# 替换除了n't这类连字符外的所有非单词字符和数字字符def replace(s): if s.group(1) == 'n\\'t': return s.group(1) return ' 'def cal(filename='203305485.txt'): # 使用lambda来定义简单的函数 dic = defaultdict(lambda: 0)#dic = defaultdict(int)也可以 with open(filename, 'r') as f: data = f.read() # 全部变为小写字母 data = data.lower() # 替换除了n't这类连字符外的所有非单词字符和数字字符 data = re.sub(r'(n[\\']t)|([\\W\\d])', replace, data) datalist = re.split(r'[\\s\\n]+', data) for item in datalist: dic[item] += 1 del dic[''] return dicif __name__ == '__main__': dic = cal() for key, val in dic.items(): print('%15s ----&gt; %3s' % (key,val)) 运行结果如下： 结果 增加排序函数代码有参考 《利用python进行数据分析》12345def top_counts(dic, n=10): value_key_pairs = [(count, tz) for tz, count in dic.items()] value_key_pairs.sort() return value_key_pairs[-n:]top_counts(dic) 运行结果如下： 结果 可以看出，人们最喜欢用的词是定冠词the，下来是介词to……. 补充最近发现collections模块的Counter类 ，导入语句是：from collections import Counter，作用是：定义一个list数组，求数组中每个元素出现的次数修改之后代码量要少很多，而且可以直接排列好顺序~12345678910111213141516# coding=utf-8import refrom collections import Counterdef cal(filename='203305485.txt'): with open(filename, 'r') as f: data = f.read() data = data.lower() # 替换除了n't这类连字符外的所有非单词字符和数字字符 datalist = re.split(r'[\\s\\n]+', data) return Counter(datalist).most_common() if __name__ == '__main__': dic = cal() for i in range(len(dic)): print('%15s ----&gt; %3s' % (dic[i][0],dic[i][1])) 代码看起来行云流水，舒服多了。当然结论是一样的，人们还是比较喜欢说 the , you~ 修改后 以上~","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"Python正则表达式","slug":"Python_lambda","date":"2017-02-10T14:18:55.000Z","updated":"2017-02-11T13:36:55.460Z","comments":true,"path":"2017/02/10/Python_lambda/","link":"","permalink":"http://feiyang.li/2017/02/10/Python_lambda/","excerpt":"使用正则表达式，会使得字符串的处理很方便。","text":"使用正则表达式，会使得字符串的处理很方便。 正则表达式基础常用语法Python中经常要对字符串进行处理，处理用户的输入，对文本的编辑等等。使用正则表达式，会使得字符串的处理很方便。 Python支持的正则表达式元字符和语法 数量词的贪婪模式与非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。 Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。 例如：正则表达式”ab“如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab?”，将找到”a”。 re模块开始使用rePython通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。 12345678910111213# encoding: UTF-8import redef test(): # 将正则表达式编译成Pattern对象 pattern1 = re.compile(r'hello') # 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None return pattern1.match('hello world!') if test(): # 使用Match获得分组信息 print (\"match\")else: print (\"not match\") re.compile(strPattern[, flag]):这个方法用于将字符串形式的正则表达式编译为Pattern对象， 第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。可选值有： re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同） M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图） S(DOTALL): 点任意匹配模式，改变’.’的行为 L(LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 U(UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：1234a = re.compile(r\"\"\"\\d + # the integral part \\. # the decimal point \\d * # some fractional digits\"\"\", re.X)b = re.compile(r\"\\d+\\.\\d*\") re提供了众多模块方法用于完成正则表达式的功能。这些方法可以使用Pattern实例的相应方法替代，唯一的好处是少写一行re.compile()代码，但同时也无法复用编译后的Pattern对象。12m = re.match(r'hello', 'hello world!')print m.group() re模块还提供了一个方法escape(string)，用于将string中的正则表达式元字符如*/+/?等之前加上转义符再返回，在需要大量匹配元字符时有那么一点用。 MatchMatch对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。 属性： string: 匹配时使用的文本。 re: 匹配时使用的Pattern对象。 pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。 lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。 方法： group([group1, …]):获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 groups([default]): 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 groupdict([default]): 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。 start([group]): 返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。 end([group]): 返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。 span([group]): 返回(start(group), end(group))。 expand(template): 将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。 1234567891011121314151617import rem = re.match(r'(\\w+) (\\w+)(?P&lt;sign&gt;.*)', 'hello world!') print (\"m.string:\", m.string)print (\"m.re:\", m.re)print (\"m.pos:\", m.pos)print (\"m.endpos:\", m.endpos)print (\"m.lastindex:\", m.lastindex)print (\"m.lastgroup:\", m.lastgroup) print (\"m.group(1,2):\", m.group(1, 2))print (\"m.groups():\", m.groups())print (\"m.groupdict():\", m.groupdict())print (\"m.start(2):\", m.start(2))print (\"m.end(2):\", m.end(2))print (\"m.span(2):\", m.span(2))print (r\"m.expand(r'\\2 \\1\\3'):\", m.expand(r'\\2 \\1\\3')) 输出内容如下：12345678910111213m.string: hello world!m.re: re.compile(&apos;(\\\\w+) (\\\\w+)(?P&lt;sign&gt;.*)&apos;)m.pos: 0m.endpos: 12m.lastindex: 3m.lastgroup: signm.group(1,2): (&apos;hello&apos;, &apos;world&apos;)m.groups(): (&apos;hello&apos;, &apos;world&apos;, &apos;!&apos;)m.groupdict(): &#123;&apos;sign&apos;: &apos;!&apos;&#125;m.start(2): 6m.end(2): 11m.span(2): (6, 11)m.expand(r&apos;\\2 \\1\\3&apos;): world hello! PatternPattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。 Pattern不能直接实例化，必须使用re.compile()进行构造。 Pattern提供了几个可读属性用于获取表达式的相关信息： pattern: 编译时用的表达式字符串。 flags: 编译时用的匹配模式。数字形式。 groups: 表达式中分组的数量。 groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。 12345678910111213import rep = re.compile(r'(\\w+) (\\w+)(?P&lt;sign&gt;.*)', re.DOTALL) print (\"p.pattern:\", p.pattern)print (\"p.flags:\", p.flags)print (\"p.groups:\", p.groups)print (\"p.groupindex:\", p.groupindex) ### output #### p.pattern: (\\w+) (\\w+)(?P&lt;sign&gt;.*)# p.flags: 16# p.groups: 3# p.groupindex: &#123;'sign': 3&#125; 实例方法[ | re模块方法]： match(string[, pos[, endpos]]) | re.match(pattern, string[, flags]): 这个方法将从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’。 search(string[, pos[, endpos]]) | re.search(pattern, string[, flags]): 这个方法用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。 12345678910111213141516# encoding: UTF-8 import re # 将正则表达式编译成Pattern对象 pattern = re.compile(r'world') # 使用search()查找匹配的子串，不存在能匹配的子串时将返回None # 这个例子中使用match()无法成功匹配 match = pattern.search('hello world!') if match: # 使用Match获得分组信息 print (match.group() ) ### 输出 ### # world split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]): 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 1234567import re p = re.compile(r'\\d+')print (p.split('one1two2three3four4')) ### output #### ['one', 'two', 'three', 'four', ''] findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags]): 搜索string，以列表形式返回全部能匹配的子串。 1234567import re p = re.compile(r'\\d+')print (p.findall('one1two2three3four4')) ### output #### ['1', '2', '3', '4'] finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags]): 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。 12345678import re p = re.compile(r'\\d+')for m in p.finditer('one1two2three3four4'): print m.group(), ### output #### 1 2 3 4 sub(repl, string[, count]) | re.sub(pattern, repl, string[, count]): 使用repl替换string中每一个匹配的子串后返回替换后的字符串。当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。 123456789101112131415import re p = re.compile(r'(\\w+) (\\w+)')s = 'i say, hello world!' print p.sub(r'\\2 \\1', s) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print p.sub(func, s) ### output #### say i, world hello!# I Say, Hello World! subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]): 返回 (sub(repl, string[, count]), 替换次数)。 123456789101112131415import re p = re.compile(r'(\\w+) (\\w+)')s = 'i say, hello world!' print p.subn(r'\\2 \\1', s) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print p.subn(func, s) ### output #### ('say i, world hello!', 2)# ('I Say, Hello World!', 2) 以上就是Python对于正则表达式的支持。熟练掌握正则表达式是每一个程序员必须具备的技能。笔者也是看的迷迷糊糊，文章来自cnblog，原版博客基于Python2.4完成，年代有点久，我稍微修改了一下代码。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python-camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"第1.3题：将  200 个激活码保存到 MySQL","slug":"python_camp3","date":"2017-02-10T07:16:52.000Z","updated":"2017-02-13T05:37:44.188Z","comments":true,"path":"2017/02/10/python_camp3/","link":"","permalink":"http://feiyang.li/2017/02/10/python_camp3/","excerpt":"题目来自：Python 练习册，今天做的是第三题，使用 Python 将激活码保存到 MySQL。","text":"题目来自：Python 练习册，今天做的是第三题，使用 Python 将激活码保存到 MySQL。 准备姿势安装Mysql如果是windows 用户，mysql 的安装非常简单，直接下载安装文件，双击安装文件一步一步进行操作即可。 Linux 下的安装可能会更加简单，除了下载安装包进行安装外，一般的linux 仓库中都会有mysql ，我们只需要通过一个命令就可以下载安装： Ubuntu\\deepin12sudo apt-get install mysql-server sudo apt-get install mysql-client centOS/redhat1yum install mysql 安装MySQL-python要想使python可以操作mysql 就需要MySQL-python驱动，它是python 操作mysql必不可少的模块。 下载地址：https://pypi.python.org/pypi/MySQL-python/ 下载MySQL-python-1.2.5.zip 文件之后直接解压。进入MySQL-python-1.2.5目录: 1python setup.py install 可能会提示缺少“error: Microsoft Visual C++ 9.0 is required (Unable to find vcvarsall.bat). Get it from http://aka.ms/vcpython27”这个地方查找了很多资料，有的说要修改注册表，有的说要改VS2015的配置。简直一派胡言，I am angry。直接按照要求，在这个http://aka.ms/vcpython27下载安装就可以了。 Microsoft 测试输入1import MySQLdb 或者1import mysql 如果不报错，那么就安装成功了。 mysql 的基本操作 启动mysql 1mysql -u root -p 查看当前所有的数据库 1show databases; 新建数据库表 1create database if not exists test; 使用某表 1use test; 添加数据 1insert into user values(&apos;Alen&apos;,&apos;7875&apos;); 查看数据 1select * from student 删除数据 1delete from user where name = &apos;Jack&apos;; 删除table 1drop table if exists student 删除database 1drop database if exists test mysql卡死怎么办查看目前连接情况： 1show processlist; 卡死 发现多个线程数据处理间出现了死锁，也没什么好的办法，kill掉就可以了。1kill 65; 然后就可以继续使用了。python 操作mysql基本语法 建立数据库连接注意，这个地方的test表要存在，否则无法连接123456789import MySQLdbconn=MySQLdb.connect( host='localhost', port = 3306, #默认3306端口，不写也可以 user='root', passwd='123456', db ='test',)cur = conn.cursor() cursor 是游标, 通过获取到的数据库连接conn下的cursor()方法来创建游标。其中，第二行代码可以缩写为：1connect(&apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;test&apos;) 创建数据表 12cur.execute(&quot;create table student(id int ,name varchar(20),class varchar(30),age varchar(10))&quot;) #通过游标cur 操作execute()方法可以写入纯sql语句。通过execute()方法中写如sql语句来对数据进行操作。 插入一条数据 1cur.execute(&quot;insert into student values(&apos;2&apos;,&apos;Tom&apos;,&apos;3 year 2 class&apos;,&apos;9&apos;)&quot;) 修改查询条件的数据 1cur.execute(&quot;update student set class=&apos;3 year 1 class&apos; where name = &apos;Tom&apos;&quot;) 删除查询条件的数据 1cur.execute(&quot;delete from student where age=&apos;9&apos;&quot;) 关闭游标 1cur.close() 提交数据向数据库插入一条数据时必须要有这个方法，否则数据不会被真正的插入。 1conn.commit() 关闭数据库连接 1conn.close() 打印表中所有数据1234567891011121314151617181920212223#coding=utf-8import MySQLdbconn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='123456', db ='test', )cur = conn.cursor()#获得表中有多少条数据aa=cur.execute(\"select * from student\")print aa#打印表中的多少数据info = cur.fetchmany(aa)for ii in info: print iicur.close()conn.commit()conn.close() 插入数据1234567891011121314151617181920212223#coding=utf-8import MySQLdbconn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='123456', db ='test', )cur = conn.cursor()#一次插入多条记录sqli=\"insert into student values(%s,%s,%s,%s)\"cur.executemany(sqli,[ ('3','Tom','1 year 1 class','6'), ('3','Jack','2 year 1 class','7'), ('3','Yaheng','2 year 2 class','7'), ])cur.close()conn.commit()conn.close() 以上两段代码参考 虫师的博客 正式代码经过以上铺垫之后，就可以写出满足要求的代码了。 12345678910111213141516171819202122232425262728293031323334353637from uuid import uuid4import MySQLdb,random, stringchars = string.digits + string.lettersdef uuidkey(num):# 使用uuid方法得到随机值 id_list = [str(uuid4()) for i in range(num)] return id_listdef randomkey(num):# 使用random随机取数据值 id_list = [\"\".join(random.sample(chars, 20)) for i in range(num)] return id_list def create_table_put_keys(id_list,table):#将获得的随机值存入mysql conn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='lyyc12345', db ='test', ) cur = conn.cursor() cur.execute(\"drop table if exists %s\" % table) #若存在table表则删除 cur.execute(\"create table %s(id int, coupon char(40))\" % table) #创建数据表 temp = 1 for i in id_list: #将id_list里边的数据插入到mysql中 cur.execute(\"insert into %s values('%d','%s')\" %(table,temp,i)) temp=temp+1 cur.close() #关闭游标 conn.commit() #提交数据 conn.close() #关闭数据库连接def main(): create_table_put_keys(uuidkey(200),'uuidtable') create_table_put_keys(randomkey(200),'randomtable')if __name__ == '__main__': main() 总结 python 中 % 的使用：cur.execute(&quot;insert into %s values(&#39;%d&#39;,&#39;%s&#39;)&quot; %(table,temp,i))，前后两部分用%相隔 提交数据conn.commit()，否则数据将不会保存。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"frp内网穿透","slug":"frp","date":"2017-02-09T02:56:15.000Z","updated":"2017-02-11T13:20:27.500Z","comments":true,"path":"2017/02/09/frp/","link":"","permalink":"http://feiyang.li/2017/02/09/frp/","excerpt":"我之前写过一篇文章是用Ngrok方式进行内网穿透，该方法需要借助到别人的服务器，非常麻烦。后来发现了Frp这个神器，只需要有一台公网的主机，就可以进行端口穿透，同时还可以转发tcp，udp，dns查询。","text":"我之前写过一篇文章是用Ngrok方式进行内网穿透，该方法需要借助到别人的服务器，非常麻烦。后来发现了Frp这个神器，只需要有一台公网的主机，就可以进行端口穿透，同时还可以转发tcp，udp，dns查询。 这里仅使用的到最简单的端口映射，需要一台有公网的vps，以及一台本地主机。 ssh登录公网vps下载frp安装包这里下载的是64位安装包wget http://home.ustc.edu.cn/~mmmwhy/frp/frp_0.9.3_linux_amd64.tar.gz如果你的系统版本是32位，那么建议使用如下命令：(如果不知道自己系统版本的，也用这个)wget http://home.ustc.edu.cn/~mmmwhy/frp/frp_0.9.3_linux_386.tar.gz frp 解压安装包tar -xzvf frp_0.9.3_linux_386.tar.gz frp 修改 frps.ini 文件，配置一个名为 ssh 的反向代理：cd frp_0.9.3_linux_386/ &amp;&amp; vi frps.ini1234567# frps.ini[common]bind_port = 7000[ssh]listen_port = 6000auth_token = 123 [ssh]后边写vps自己的端口。 公网端口 ssh端口号 启动 frps：./frps -c ./frps.ini 登录无公网主机下载frp安装包与 解压安装包，与上部相同，在此不赘述。 修改 frpc.ini 文件，配置一个名为 ssh 的反向代理：cd frp_0.9.3_linux_386/ &amp;&amp; vi frpc.ini如果希望转发到本地8888端口12345678[common]server_addr = 115.159.102.118server_port = 7000auth_token = 123[ssh]local_ip = 127.0.0.1local_port = 8888 启动 frpc：./frpc -c ./frpc.ini","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"},{"name":"frp","slug":"frp","permalink":"http://feiyang.li/tags/frp/"}]},{"title":"第1.2题：使用 Python 如何生成 200 个激活码","slug":"python_camp2","date":"2017-02-07T11:50:11.000Z","updated":"2017-02-13T05:37:40.975Z","comments":true,"path":"2017/02/07/python_camp2/","link":"","permalink":"http://feiyang.li/2017/02/07/python_camp2/","excerpt":"题目来自：Python 练习册，今天做的是第二题，使用 Python 如何生成 200 个激活码。","text":"题目来自：Python 练习册，今天做的是第二题，使用 Python 如何生成 200 个激活码。 random模块介绍我们可以使用python中的random模块，用于生成随机浮点数、整数、字符串，甚至帮助你随机选择列表序列中的一个元素，打乱一组数据等。 random模块五个函数 random() 返回0&lt;=n&lt;1之间的随机实数n； choice(seq) 从序列seq中返回随机的元素； getrandbits(n) 以长整型形式返回n个随机位； shuffle(seq[, random]) 原地指定seq序列； sample(seq, n) 从序列seq中选择n个随机且独立的元素； random模块方法说明 random.random()函数是这个模块中最常用的方法了，它会生成一个随机的浮点数，范围是在0.0~1.0之间。 random.uniform()正好弥补了上面函数的不足，它可以设定浮点数的范围，一个是上限，一个是下限。 random.randint()随机生一个整数int类型，可以指定这个整数的范围，同样有上限和下限值，python random.randint。 random.choice()可以从任何序列，比如list列表中，选取一个随机的元素返回，可以用于字符串、列表、元组等。 random.shuffle()如果你想将一个序列中的元素，随机打乱的话可以用这个函数方法。 random.sample()可以从指定的序列中，随机的截取指定长度的片断，不作原地修改。 使用random直接随机抽取从26个大小字母+10个数字，随机选取10个数字，组成一组激活码。重复此过程200次即可。 设定字符串内容123import random, stringchars = string.letters + string.digitsprint chars 输出内容为：abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 从给定内容中随机选取使用random.choice()和random.sample()两个函数123s= \"\".join(random.choice(chars) for i in range(10))gene = \"\".join(random.sample(chars, 10))print s +\" /////// \" + gene 其中s与gene分别可以获得两个随机序列，从这里我们可以看出两个函数使用上的差异，相对来说，random.sample()简单一些。 使用UUIDUUID是128位的全局唯一标识符，通常由32字节的字符串表示。 它可以保证时间和空间的唯一性，也称为GUID，全称为：Universally Unique IDentifie。 UUID的五种实现方法 uuid1()——基于时间戳由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。 uuid2()——基于分布式计算环境DCE（Python中没有这个函数）算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID，实际中很少用到该方法。 uuid3()——基于名字的MD5散列值通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。 uuid4()——基于随机数由伪随机数得到，有一定的重复概率，该概率可以计算出来。 uuid5()——基于名字的SHA-1散列值算法与uuid3相同，不同的是使用 Secure Hash Algorithm 1 算法使用UUID生成激活码123import uuidfor i in range(20): print uuid.uuid1() 输出：ebb4911e-ed1e-11e6-82ec-708bcda57790 ebb4b82e-ed1e-11e6-9f24-708bcda57790 ebb4b82f-ed1e-11e6-9d5c-708bcda57790 ebb4b830-ed1e-11e6-9f8b-708bcda57790 ebb4b831-ed1e-11e6-89d4-708bcda57790 ebb4b832-ed1e-11e6-903a-708bcda57790 ebb4b833-ed1e-11e6-9038-708bcda57790 ebb4b834-ed1e-11e6-b1dc-708bcda57790 ebb4b835-ed1e-11e6-8fb8-708bcda57790 ebb4b836-ed1e-11e6-a399-708bcda57790 ebb4b837-ed1e-11e6-a9a0-708bcda57790 ebb4b838-ed1e-11e6-8f85-708bcda57790 ebb4b839-ed1e-11e6-9ac2-708bcda57790 ebb4b83a-ed1e-11e6-8f48-708bcda57790 ebb4b83b-ed1e-11e6-b6d8-708bcda57790 ebb4b83c-ed1e-11e6-9bde-708bcda57790 ebb4b83d-ed1e-11e6-b03f-708bcda57790 ebb4b83e-ed1e-11e6-ac70-708bcda57790 ebb4b83f-ed1e-11e6-baf1-708bcda57790 ebb4b840-ed1e-11e6-a694-708bcda57790 写入文件代码示例12345678910111213141516import randomimport stringFIELD = string.digits + string.lettersdef generate(n, many=1, where=None): def getCode(n): return \"\".join(random.sample(FIELD, n)) gene = [getCode(n) for i in range(many)] return genedef writeIn(n, many, where): count = 1 for i in generate(n, many): with open(where, \"a\") as boom: boom.write(str(count).rjust(3)+\" \"+i+\"\\n\") count += 1if __name__ == '__main__': writeIn(20, 200, \"coupon.txt\") 以上","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"Github Pages + CDN全站加速","slug":"Github-Pages-CDN","date":"2017-02-07T05:38:38.000Z","updated":"2017-02-11T13:20:33.275Z","comments":true,"path":"2017/02/07/Github-Pages-CDN/","link":"","permalink":"http://feiyang.li/2017/02/07/Github-Pages-CDN/","excerpt":"常见的Pages服务有 Coding Pages和Github Pages，因为众所周知的原因，此类服务仅能放在国外，通过国内CDN加速Pages访问速度是一种不错的选择。以Coding Pages和腾讯CDN为例。 本方法同样可以对虚拟主机进行CDN加速。","text":"常见的Pages服务有 Coding Pages和Github Pages，因为众所周知的原因，此类服务仅能放在国外，通过国内CDN加速Pages访问速度是一种不错的选择。以Coding Pages和腾讯CDN为例。 本方法同样可以对虚拟主机进行CDN加速。 本方法可解决以下问题： 提高Pages的访问速度； 利用 CDN 解决百度爬虫被 Github Pages 拒绝的问题； 加速效果展示不使用CDN加速 不使用CDN 平均响应时间130ms，比我想象中要好。可能因为现在是上午11点上网的人少（?），之前我在学校测得时候动辄200ms。 使用CDN加速 CDN加速后 可以看到平均响应时间大约24.2ms，祖国山河一片绿。多环保~ 利用Pages搭建个人网站这一步在网上搜一下，有很多教程，在此不赘述。 使用CDN为Pages加速推荐腾讯云CDN，https://www.qcloud.com/product/cdn 目前可以免费送300G流量。根据服务商的要求，如Coding要求为： 在您的域名管理面板中添加 CNAME 记录指向到 pages.coding.me。 获得CNAME的IP地址ping 一下 pages.coding.me，获得IP地址： 23.248.162.138，源站设置为该IP。 设置源站 接下来，加速服务配置，默认时长都是30天。明显这个时间忒长了，我们可以设置为1天或者几个小时。 设置缓存逻辑 点击提交 ，过约5分钟会返回提示成功。点击管理进一步设置； 配置回源host我们可以把回源host理解为，访问23.248.162.138这个IP地址的服务器时，向服务器发出的url访问请求，服务器根据host头部里边的url地址，映射到内部相应访问空间去。回源host是用于CDN回源到源站时的访问域名，即http请求包包头的host字段内容。 回源host 配置域名CNAME CNAME 为域名配置相应的CNAME，常见的是@和www 检查ping 一下自己的域名，如果PING到后缀为cdntip.com或后缀为tcdn.qq.com表示域名CNAME已生效。 使用CDN为Pages加速，到这一步已经算结束了。但是由于使用国内CDN，使得网站在国外加载速度会慢的令人发指。 分地区DNS国内国外设置不同CANME，国外指向 mmmwhy.github.io或者pages.coding.me（设置自己的），国内的指向刚才CDN给出的地址。 以上 通过此方法可以将pages或者国外的免费空间，速度快到令人发指的地步~祝新年快乐~","categories":[],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://feiyang.li/tags/CDN/"},{"name":"Pages","slug":"Pages","permalink":"http://feiyang.li/tags/Pages/"}]},{"title":"jupyter notebook使用帮助","slug":"jupyter-notebook","date":"2017-01-12T12:50:52.000Z","updated":"2017-02-11T13:20:37.749Z","comments":true,"path":"2017/01/12/jupyter-notebook/","link":"","permalink":"http://feiyang.li/2017/01/12/jupyter-notebook/","excerpt":"jupyer notebook 使用的时候常见换主题，以及换工作空间的问题。","text":"jupyer notebook 使用的时候常见换主题，以及换工作空间的问题。 jupyter notebook 换字体换颜色换主题jupyter notebook自带的默认颜色实在是阳春白雪，看的多了眼睛有点累。页面的相关定义都是在CSS内完成的，我们可以通过修改CSS来达到目标。但是这样实在是太累了，在Github有一个jupyter-themes工具，真的很好用，通过pip进行安装，分分钟更换成自己喜欢的主题。 安装 jupyterthemespip install jupyterthemes通过pip安装省时省力，如果你当前pip安装速度很慢，可以考虑使用清华源，代码如下：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jupyterthemes 命令行格式1234usage: jt [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT] [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-alt] [-vim] [-T] [-N] [-r] options arg default Usage help -h – List Themes -l – Theme Name to Install -t – Code Font -f droidmono Code Font-Size -fs 11 Notebook Font -nf exosans Notebook Font Size -nfs 13 Text/MD Cell Font -tf loraserif Text/MD Cell Fontsize -tfs 13 Intro Page Margins -m auto Cell Width -cellw 980 Line Height -lineh 170 Cursor Width -cursw 2 Cursor Color -cursc – Alt Text/MD Layout -alt – Alt Prompt Layout -altp – Style Vim NBExt* -vim – Toolbar Visible -T – Name &amp; Logo Visible -N – Restore Default -r – 举个例子jt -t oceans16 -f roboto -fs 15意味着选择oceans16主题，roboto字体，大小为15，效果如下。 恢复原始主题，重新启动Jupyter notebook，如果主题没有改变，Ctrl+F5刷新即可。# restore default themejt -r jupyter notebook换工作空间 打开 cmd 输入命令jupyter notebook --generate-config 进入自己工作目录，.jupyter，打开jupyter_notebook_config.py ctrl+f查到c.NotebookApp.notebook_dir，将这一行改为c.NotebookApp.notebook_dir = ‘自己的位置’ 启动 jupyter notebook","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Jupyer","slug":"Jupyer","permalink":"http://feiyang.li/tags/Jupyer/"}]},{"title":"部署在线IPyhton notebook(在线python编译器)","slug":"IPyhton-notebook","date":"2016-12-31T14:52:39.000Z","updated":"2017-02-15T12:08:27.233Z","comments":true,"path":"2016/12/31/IPyhton-notebook/","link":"","permalink":"http://feiyang.li/2016/12/31/IPyhton-notebook/","excerpt":"jupyter notebook在数据分析时使用非常的方便，特别那优美的页面，简直让我着迷。","text":"jupyter notebook在数据分析时使用非常的方便，特别那优美的页面，简直让我着迷。 优点： 支持的格式很多，Markdown，Latex等都支持，还有很方便的快捷键。 可以将代码可视化分享给其他人，From notebook to slides 像一张草稿纸，可以一边通过它来进行你的思考探索过程，交互式的进行，每一步都能看到结果，也很方便查看之前的结果。可以到IPython Notebook看一下，密码是Jupyter，我把《利用Python进行数据挖掘》的所有数据集和代码都放到了服务器里边2333333 本地安装Jupyter推荐先安装python科学计算包ANACONDA点击进入官网下载，按要求下载安装完成之后。期间会有一步提示是否加入Path，勾选加入环境变量。如果但是没有勾选，对于win事后可以手动添加环境变量。对于linux，使用export PATH=~/anaconda2/bin:$PATH进行添加。anaconda安装完后，对于win10用户，可以看到已经成功安装Jupyter Notebook，点击即可打开食用~ 点击之后，默认直接打开浏览器localhost:8888 用命令行也可以打开此页面，并且在打开的页面会形成.ipynb文件 线上部署 Jupyter Notebook在本地部署好了之后，其实给了我一些灵感，既然可以在浏览器运行。那么其实部署在服务器上也是可以的，大家如果看过我看过我之前的文章，就知道我对vps很感兴趣。其实在本地看到的那个localhost:8888，在外网也可以访问，只需要稍微加以设置即可。 首先要申请虚拟机这里推荐腾讯云或者DO，通过本链接注册送$10。然后再加上github的学生优惠包，可以很便宜哦。设置好之后，使用SSH连接上服务器。 服务器下载Anaconda 如果选择国内服务器，推荐清华Anaconda 镜像，点击进入，选择与自己服务器相符的版本。wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda-2.3.0-Linux-x86_64.sh 如果选择国外服务器，使用代码wget https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh本来想推荐科大源的，但是科大源实在是烂泥扶不上墙，目前清华源是国内比较好的了。 安装Anacondasudo bash Miniconda-latest-Linux-x86_64.shMiniconda-latest-Linux-x86_64.sh这个地方，输入自己下载的文件名称，其实只要写前几个字母，然后敲Tab，就可以自动补全了。安装好时候输入conda --v检查一下，如果输出为conda的版本则正常。如果输出conda: command not found，出现这种情况的原因是conda没有在path添加，使用export PATH=~/anaconda2/bin:$PATH 添加即可。 打开Ipython ,设置密码设置过程中要设置用于远程登录的密码，把生成的密文‘sha:ce…’复制下来 mark 12345In [1]: from IPython.lib import passwdIn [2]: passwd()Enter password:Verify password: Out[2]: &apos;sha1:7467b73*************************3003b****&apos; 生成配置文件终端输入：jupyter notebook --generate-config这个时候在当前目录会生成一个.jupyter的隐藏文件夹，修改文件内的jupyter_notebook_config.pyvim ~/.jupyter/jupyter_notebook_config.py 关于vim的常用功能：按a在光标所在位置插入内容（进入编辑模式），Esc退出编辑模式，连续按两下z，保存并退出。 jupyter_notebook_config.py内包含以下内容，稍作修改即可1234c.NotebookApp.ip=&apos;*&apos; # 就是设置所有ip皆可访问c.NotebookApp.password = u&apos;sha:ce...刚才复制的那个密文&apos;c.NotebookApp.open_browser = False # 禁止自动打开浏览器c.NotebookApp.port =8888 #随便指定一个端口 启动jupyter notebookjupyter notebook 此时应该可以直接从本地浏览器直接访问http://address_of_remote:8888就可以看到jupyter的登陆界面。 如果希望不要在退出SSH命令行的时候，同时也停止jupyter notebook服务，推荐nohup ，之前写过篇博客解释过nohup的作用在线python编译器就搭建好了，是不是很洋气~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://feiyang.li/tags/Jupyter/"}]},{"title":"第1.1题：Python图片添加水印","slug":"python_camp1","date":"2016-12-31T04:16:16.000Z","updated":"2017-02-13T05:37:36.719Z","comments":true,"path":"2016/12/31/python_camp1/","link":"","permalink":"http://feiyang.li/2016/12/31/python_camp1/","excerpt":"题目来自：Python 练习册，今天做的是第一题，将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。","text":"题目来自：Python 练习册，今天做的是第一题，将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 添加文字水印初始图像 我的头像 Python代码123456789101112131415from PIL import Image, ImageDraw, ImageFontdef add_num(img): draw = ImageDraw.Draw(img) myfont = ImageFont.truetype('C:/windows/fonts/Arial.ttf', size=40) fillcolor = \"#ff0000\" width, height = img.size draw.text((width-50, 5), '99', font=myfont, fill=fillcolor) img.save('result.jpg','jpeg') return 0if __name__ == '__main__': image = Image.open('F:/Picture/touxiang.jpg') add_num(image) image.show() 代码解释 from PIL import Image, ImageDraw, ImageFont 导入PIL图像处理库 draw = ImageDraw.Draw(img)，查了一下ImageDraw作用： 创建绘画对象 ImageDraw module creates drawing surface for image123import Image, ImageDrawim = Image.open(“vacation.jpeg\") drawSurface = ImageDraw.Draw(im) draw.text((width-50, 5), &#39;99&#39;, font=myfont, fill=fillcolor) 第一个括号填写的是位置，表示在x轴在width-50，y轴在5的位置加入文字，也就是右上角的意思。 效果展示 文字水印 添加图片水印Python代码1234567891011121314from PIL import Image, ImageDraw, ImageFontdef add_num(im,mark): layer = Image.new('RGBA', im.size, (0, 0, 0, 0)) layer.paste(mark, (im.size[0] - 150, im.size[1] - 150)) out = Image.composite(layer, im, layer) out.save('result.jpg','jpeg') out.show() return 0if __name__ == '__main__': image = Image.open('F:/Picture/touxiang.jpg') mark = Image.open('F:/Picture/1022.png') add_num(image,mark) 代码解释 Image.composite(layer, im, layer) 解释一下Image.composite()的意思使用案例Image.composite(image1, image2, mask) =&gt; image使用遮罩（mask）作为alpha，通过在两个图像之间进行插值来创建一个新图像。遮罩图像的模式可以是“1”，“L”，或者“RGBA”。所有的图像的大小必须有相同。 out.save(&#39;result.jpg&#39;,&#39;jpeg&#39;)，对图片进行保存，设置文件名和文件格式。 效果展示 图片水印 参考文章Python图像处理库：PIL中Image,ImageDraw等基本模块介绍","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"Python练习册","slug":"python_camp","date":"2016-12-31T03:35:04.000Z","updated":"2017-02-13T05:43:54.616Z","comments":true,"path":"2016/12/31/python_camp/","link":"","permalink":"http://feiyang.li/2016/12/31/python_camp/","excerpt":"参考代码一同附上，分析过程见李飞阳，请多指教。","text":"参考代码一同附上，分析过程见李飞阳，请多指教。 一、基础问题题目1.1：图片加水印，类似于微信未读信息数量那种提示效果 头像 题目1.2：使用 Python 如何生成 200 个激活码（或者优惠券） 题目1.3：将 0002 题生成的 200 个激活码（或者优惠券）保存到 MySQL 关系型数据库中。 题目1.4：任一个英文的纯文本文件，统计其中的单词出现的个数。 题目1.5：你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。 题目1.6：使用 Python 生成类似于下图中的字母验证码图片 字母验证码 阅读资料 题目1.7： 敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。 北京 程序员 公务员 领导 牛比 牛逼 你娘 你妈 love sex jiangge 题目1.8： 纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示： { &quot;1&quot;:[&quot;张三&quot;,150,120,100], &quot;2&quot;:[&quot;李四&quot;,90,99,95], &quot;3&quot;:[&quot;王五&quot;,60,66,68] } 请将上述内容写到 student.xls 文件中，如下图所示： student.xls 阅读资料 腾讯游戏开发 XML 和 Excel 内容相互转换 题目1.9： 通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。 阅读资料 用户密码的存储与 Python 示例 阅读资料 Hashing Strings with Python 阅读资料 Python’s safest method to store and retrieve passwords from a database 二、数据分析题目2.1：你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。 题目2.2：有个目录，里面是你自己写过的程序，统计一下你写过多少行代码。包括空行和注释，但是要分别列出来。 题目2.3： 登陆中国联通网上营业厅 后选择「自助服务」 –&gt; 「详单查询」，然后选择你要查询的时间段，点击「查询」按钮，查询结果页面的最下方，点击「导出」，就会生成类似于 2014年10月01日～2014年10月31日通话详单.xls 文件。写代码，对每月通话时间做个统计。 三、爬虫方面题目3.1：一个HTML文件，找出里面的正文。 题目3.2：一个HTML文件，找出里面的链接。 题目3.3： 用 Python 写一个爬图片的程序，可以参考Python爬取图片（使用urllib2），如果出现问题，可以尝试selenium自动化测试工具 四、Web问题题目4.1： 使用 Python 的 Web 框架，做一个 Web 版本 留言簿 应用。 阅读资料：Python 有哪些 Web 框架 留言簿参考 题目4.2： 使用 Python 的 Web 框架，做一个 Web 版本 TodoList 应用。 SpringSide 题目来自 易枭寒的Github","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"使用Python selenium处理页面延迟加载问题","slug":"Python-selenium","date":"2016-12-29T08:06:43.000Z","updated":"2017-02-11T13:21:00.266Z","comments":true,"path":"2016/12/29/Python-selenium/","link":"","permalink":"http://feiyang.li/2016/12/29/Python-selenium/","excerpt":"使用python爬取数据的时候，碰到了一个非常无语的问题。有个网站，在输入url进入页面之后，会强制加载一段动画，之后才显示正确内容。后来发现了selenium这个神器，不过还是折腾了我好久。","text":"使用python爬取数据的时候，碰到了一个非常无语的问题。有个网站，在输入url进入页面之后，会强制加载一段动画，之后才显示正确内容。后来发现了selenium这个神器，不过还是折腾了我好久。 用selenium 设置浏览器等待时间很多人问，这个下拉框定位不到、那个弹出框定位不到…各种定位不到，其实大多数情况下就是两种问题：1 有frame，2 没有加等待。殊不知，你的代码运行速度是什么量级的，而浏览器加载渲染速度又是什么量级的，就好比闪电侠和奥特曼约好去打怪兽，然后闪电侠打完回来之后问奥特曼你为啥还在穿鞋没出门？奥特曼分分中内心一万只羊驼飞过，欺负哥速度慢，哥不跟运行需要两个前提，每个都不好搞。。 首先需要安装selenium ，推荐使用pip安装,pip install selenium或者直接下载selenium包:https://pypi.python.org/pypi/selenium 解压，cmd进入目录:python setup.py install 接下来安装 ChromeDriver推荐在这里 https://sites.google.com/a/chromium.org/chromedriver/downloads 下载，然后放在Chrome浏览器目录内，配置Path环境变量为形如 XXGoogle\\Chrome\\Application的形式你玩了，抛个异常撂挑子了。 最简单粗暴的一种办法就是强制等待sleep(xx)，强制让闪电侠等xx时间，不管凹凸曼能不能跟上速度，还是已经提前到了，都必须等xx时间。 12345678# coding: utf-8from selenium import webdriverfrom time import sleepdriver = webdriver.Chrome()driver.get('https://feiyang.li')sleep(3) # 强制等待3秒再执行下一步print driver.titledriver.quit() 结合selenium使用Xpath获得所需信息 需要注意的是，selenium内find_elements的方法有很多种，xpath表达式的要求很严格，所以可以试试find_elements_id等方法。 Xpath表达式可以检测文字中是否包含某文字，以此为标准过滤。 mark Xpath表达式支持and 和 or。 1234def extract_from(browser): links = browser.find_elements_by_xpath(\"//p[contains(text(), '出处') or contains(text(), '组成') or contains(text(), '组成') or contains(text(), '主治') or contains(text(), '用法')] \") print(browser.title) return [link.text for link in links] 中文输入输出问题 send_keys() 不能正确的输入关键字，在中文前边加一个u即可，比如elem.send_keys(u&#39;你好哇&#39;) 不能正确的输出中文，print (&#39;\\n&#39;.join(extract_from(browser)))以上两个问题都跟python2的特性有关，升级至3之后应当不会出现此类问题。 写了一个小demo，解释中文输入输出问题12345678910111213141516171819# coding=utf-8import timefrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdef search(key): elem = browser.find_element_by_xpath(\"//input[@id='kw']\") elem.send_keys(key) elem.send_keys(Keys.RETURN) time.sleep(1)def extract_from(browser): links = browser.find_elements_by_xpath(\"//div[contains(text(),'李银河')]\") return [link.text for link in links]key = u\"你好哇\"browser = webdriver.Chrome()browser.get('http://www.baidu.com')search(key)print ('\\n'.join(extract_from(browser)))browser.close() 运行结果见下，可以抽取出对应文字。 运行结果 Code1234567891011121314151617181920212223242526272829303132# coding=utf-8import timeimport requestsfrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdef search(key): elem = browser.find_element_by_xpath(\"//input[@id='simple_search_filed']\") elem.send_keys(key) elem.send_keys(Keys.RETURN) time.sleep(3)def extract_from(browser): links = browser.find_elements_by_xpath(\"//p[contains(text(), '出处') or contains(text(), '组成') or contains(text(), '组成') or contains(text(), '主治') or contains(text(), '用法')] \") print(browser.title) return [link.text for link in links]from lxml import etreehtml = requests.get(\"http://www.zk120.com/fang/\")html.encoding = 'utf-8'selector = etree.HTML(html.text)content = selector.xpath(\"//ul/li/a/span[@class='free_icon_r']/../@href\")for imgurl in content: imgurl = \"http://www.zk120.com\" +imgurl browser = webdriver.Chrome() browser.get(imgurl) time.sleep(2) print ('\\n'.join(extract_from(browser))) print(\"------------\") browser.close() 参考代码在搜索资料的时候，同时发现了一个非常好的示例代码 1234567891011121314151617181920212223242526272829303132import refrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdef extract_data(browser): links = browser.find_elements_by_xpath('//i[@class=\"RecordStats\"]/a') return [link.get_attribute('href') for link in links]browser = webdriver.Firefox()browser.get(\"http://www.scba.gov.ar/jurisprudencia/Navbar.asp?Busca=Fallos+Completos&amp;SearchString=Inconstitucionalidad\")# get max pageselement = WebDriverWait(browser, 10).until(EC.presence_of_element_located((By.XPATH, \"//p[@class='c'][last()]\")))max_pages = int(re.search(r'\\d+ de (\\d+)', element.text).group(1), re.UNICODE)# extract from the current (1) pageprint \"Page 1\"print extract_data(browser)# loop over the rest of the pagesfor page in xrange(2, max_pages + 1): print \"Page %d\" % page next_page = browser.find_element_by_xpath(\"//table[last()]//td[last()]/a\").click() print extract_data(browser) print \"-----\" 这个地方真的花费了我好大的精力啊，让人头疼。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://feiyang.li/tags/爬虫/"},{"name":"Xpath","slug":"Xpath","permalink":"http://feiyang.li/tags/Xpath/"},{"name":"selenium","slug":"selenium","permalink":"http://feiyang.li/tags/selenium/"}]},{"title":"牛顿迭代法计算平方根(Java,Python实现)","slug":"Newton-Raphson_method-Java-Python","date":"2016-12-28T08:33:55.000Z","updated":"2017-02-11T13:20:52.231Z","comments":true,"path":"2016/12/28/Newton-Raphson_method-Java-Python/","link":"","permalink":"http://feiyang.li/2016/12/28/Newton-Raphson_method-Java-Python/","excerpt":"牛顿法的作用是使用迭代的方法来求解函数方程的根。简单地说，牛顿法就是不断求取切线的过程。","text":"牛顿法的作用是使用迭代的方法来求解函数方程的根。简单地说，牛顿法就是不断求取切线的过程。 数学推导假设c为原数，t为c的根数。 $$ t^2 \\quad = \\quad c$$$$2t^2 \\quad = \\quad c + \\quad t^2$$$$2t \\quad = \\quad \\frac{c}{t}+ \\quad t$$$$t \\quad = \\quad \\frac{\\frac{c}{t} + t}{2.0}$$ Java代码实现123456789101112131415161718192021package test;import java.io.IOException;import java.util.Scanner;public class QuickFindUF &#123; public static double sqrt (double c)&#123; if(c&lt;0) return Double.NaN; double err = 1e-15; double t = c; while(Math.abs(t-c/t)&gt;err) t = (c/t+t)/2.0; return t; &#125; public static void main(String args[]) throws IOException&#123; Scanner sc = new Scanner(System.in); double a = sqrt(sc.nextDouble()); System.out.println(a); &#125;&#125; Python代码实现123456c = input()err = 1e-15t = cwhile abs(t - c/t)&gt;err: t = (c/t+t)/2.0print(t) Python代码真心简洁啊","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"Java","slug":"Java","permalink":"http://feiyang.li/tags/Java/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"LaTex 编辑公式","slug":"LaTex","date":"2016-12-28T07:21:21.000Z","updated":"2017-02-11T13:23:33.245Z","comments":true,"path":"2016/12/28/LaTex/","link":"","permalink":"http://feiyang.li/2016/12/28/LaTex/","excerpt":"在计算机直接输入数学公式是一件棘手的事情，我一般是用一个专业的数学工具MathType，但最近在使用Markdown写作，遂产生念头用LaTex输入公式。发现目前网上的语法介绍往往不够全面，于是自己写了一份。","text":"在计算机直接输入数学公式是一件棘手的事情，我一般是用一个专业的数学工具MathType，但最近在使用Markdown写作，遂产生念头用LaTex输入公式。发现目前网上的语法介绍往往不够全面，于是自己写了一份。 LaTex 公式通用语法 使用单 $ 围住表达式，居左展示。 使用双 $$ 围住表达式，可以居中显示。 空格当前环境标准字体宽度为 M 两个quad空格 a \\qquad b 两个m的宽度$$ C_1 \\qquad C_2 $$$$ C_1 \\qquad C_2 $$ quad空格 a \\quad b 一个m的宽度$$ C_1 \\quad C_2 $$$$ C_1 \\quad C_2 $$ 大空格 a\\ b 1/3m宽度$$ C_1 \\ C_2 $$$$ C_1 \\ C_2 $$ 中等空格 C_1\\;C_2 2/7m宽度$$C_1\\;C_2$$$$C_1\\;C_2$$ 小空格 C_1\\,C_2 1/6m宽度$$C_1\\,C_2$$$$C_1\\,C_2$$ 没有空格 C_1C_2$$C_1C_2$$$$C_1C_2$$ 紧贴 C_1!C_2 缩进1/6m宽度$$C_1\\!C_2$$ 上下标 上标符号 ^$$ c_{1}^{2}=a^{2}+b^{2} $$$$ c_{1}^{2}=a^{2}+b^{2} $$ 下标符号_$$C_{m,n}$$$$C_{m,n}$$ 希腊字母$$\\lambda,\\xi,\\pi,\\mu,\\Phi,\\Omega,\\alpha, \\beta, \\gamma,\\Gamma, \\Delta $$$$\\lambda,\\xi,\\pi,\\mu,\\Phi,\\Omega,\\alpha, \\beta, \\gamma,\\Gamma, \\Delta $$ 值比较符 大于等于小于，使用正常&gt;,&lt;,=即可 大于等于使用 \\geq$$e^{x^2} \\geq {e^x}^2$$$$e^{x^2} \\geq {e^x}^2$$ 小于等于使用\\leq$$e^{x^2} \\leq {e^x}^2$$$$e^{x^2} \\leq {e^x}^2$$ 不等于使用neq$$e^{x^2} \\neq {e^x}^2$$$$e^{x^2} \\neq {e^x}^2$$ 平方根使用\\sqrt或 \\surd$$\\sqrt{x+y}$$$$\\sqrt{x+y}$$ 水平线使用 \\overline,\\underline$$\\overline{m+n} \\quad \\underline{m+n}$$$$\\overline{m+n} \\quad \\underline{m+n}$$ 水平括号使用\\overbrace 和 \\underbrace$$ \\underbrace{a+b+\\cdots+z}_{26}$$$$ \\underbrace{a+b+\\cdots+z}_{26}$$ 重音号使用\\widetilde 和 \\widehat$$y’=3\\widetilde a+4\\widehat b$$ 向量使用\\overrightarrow 和 \\overleftarrow$$\\overrightarrow {AC} = \\overrightarrow {AB} +\\overrightarrow {BC} $$$$\\overrightarrow {AC} = \\overleftarrow {AB} +\\overrightarrow {BC} $$ 圆点使用\\cdot, \\cdots,\\vdots,\\ddot$$ a \\vdots =b \\cdot c \\cdots d \\ddot e$$$$ a \\vdots =b \\cdot c \\cdots d \\ddot e$$ 函数名\\arccos \\cos \\csc \\arcsin \\cosh \\deg \\arctan \\cot \\det \\arg \\coth \\dim \\sinh \\sup \\tan [\\lim_{x \\rightarrow 0} \\frac{\\sin x}{x}=1] \\exp \\ker \\limsup \\min \\gcd \\lg \\ln \\Pr \\hom \\lim \\log \\sec \\inf \\liminf \\max \\sin \\tanh $$lim_{x \\rightarrow 0} \\frac{\\sin x}{x}=1$$$$lim_{x \\rightarrow 0} \\frac{\\sin x}{x}=1$$ 数学符\\mathbf$$ x^{2} \\geq 0\\qquad \\textrm{for all }x\\in\\mathbf{R} $$$$ x^{2} \\geq 0\\qquad \\textrm{for all }x\\in\\mathbf{R} $$ 分数直接输入或者\\frac{}{} $$\\sin \\alpha = \\frac{a}{c} $$$$\\sin \\alpha = \\frac{a}{c} $$ $$x^{1/2} $$$$x^{1/2} $$ 二项系数{… \\choose …} 或 {… \\atop …}。第二个命令与第一个命令的输出相同,只是没有括号。$${n\\choose m} \\qquad {x\\atop y+2}$$$${n\\choose m} \\qquad {x\\atop y+2}$$ 前缀符号\\int,\\sum,\\prod $$ {\\int_{0}^{\\frac{\\pi}{2}}} $$$$ {\\int_{0}^{\\frac{\\pi}{2}}} $$ $$ \\sum_{i=1}^{n}$$$$ \\sum_{i=1}^{n}$$ $$\\prod_\\epsilon$$$$\\prod_\\epsilon$$ 转义符号有时保留字需要加入\\来进行转义$${a,b,c}\\neq\\{a,b,c\\}$$$${a,b,c}\\neq{a,b,c}$$ 括号层次 正确的括号大小\\left和\\right。如果将命令 \\left 放在开分隔符前,TEX会自动决定分隔符的正确大 小。注意必须用对应的右分隔符 \\right 来关闭每一个左分隔符 \\left,并 且只有当这两个分隔符排在同一行时大小才会被正确确定。我们可以看到右式没有采用\\left形式，不能正确确定括号大小$$ 1+\\left(\\frac {1}{1-x^2}\\right) ^3 \\qquad 1+(\\frac {1}{1-x^2}) ^3$$$$ 1+\\left(\\frac {1}{1-x^2}\\right) ^3 \\qquad 1+(\\frac {1}{1-x^2}) ^3$$ 另外也可以手工指出括号大小，使用\\big,\\Big,\\bigg,\\Bigg。 $$ \\Big( (x+y) (x-y) \\Big)^{2} $$$$ \\Big( (x+y) (x-y) \\Big)^{2} $$ $$\\big(\\Big(\\bigg(\\Bigg($$$$\\big(\\Big(\\bigg(\\Bigg($$ $$\\big\\}\\Big\\}\\bigg\\}\\Bigg\\} $$$$\\big}\\Big}\\bigg}\\Bigg} $$ $$\\big\\|\\Big\\|\\bigg\\|\\Bigg\\| $$$$\\big|\\Big|\\bigg|\\Bigg| $$ 垂直对齐使用array命令，并\\命令来分行。注意转义 123456$$\\mathbf&#123;X&#125; = \\left( \\begin&#123;array&#125;&#123;ccc&#125; x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \\ldots \\\\\\ x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \\ldots \\\\\\ \\vdots &amp; \\vdots &amp; \\ddots \\end&#123;array&#125; \\right) $$","categories":[],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://feiyang.li/tags/LaTex/"}]},{"title":"Nginx环境下配置HTTPS","slug":"Nginx_HTTPS","date":"2016-12-18T08:47:29.000Z","updated":"2017-02-11T13:21:04.182Z","comments":true,"path":"2016/12/18/Nginx_HTTPS/","link":"","permalink":"http://feiyang.li/2016/12/18/Nginx_HTTPS/","excerpt":"现在，你应该能在访问https://feiyang.li 的时候，在地址栏里看到一个漂亮的小绿锁 作为肤浅的人，为了这么洋气的小绿锁也要上HTTPS~","text":"现在，你应该能在访问https://feiyang.li 的时候，在地址栏里看到一个漂亮的小绿锁 作为肤浅的人，为了这么洋气的小绿锁也要上HTTPS~ 申请免费SSL证书普通的SSL证书动辄好几千，简直令人发指。不过别担心，我找到了3个免费申请HTTPS证书的方式。 StartSSL也免费提供了一个证书（纯英文）申请地址：https://www.startssl.com/Account?r=L1ZhbGlkYXRl 阿里云免费提供的证书https://common-buy.aliyun.com/?spm=5176.7968328.231195.3.Vh92u7&amp;commodityCode=cas#/buy 腾讯云免费申请https://console.qcloud.com/ssl 获得证书之后，下载至本地。 VPS上安装SSL证书以Nginx 为例 获取证书Nginx文件夹内获得SSL证书文件 1_www.domain.com_bundle.crt 和私钥文件 2_www.domain.com.key, 1_www.domain.com_bundle.crt 文件包括两段证书代码 “—–BEGIN CERTIFICATE—–”和“—–END CERTIFICATE—–”,2_www.domain.com.key 文件包括一段私钥代码“—–BEGIN RSA PRIVATE KEY—–”和“—–END RSA PRIVATE KEY—–”。 上传和部署SSL证书将域名 www.domain.com 的证书文件1_www.domain.com_bundle.crt 、私钥文件2_www.domain.com.key保存到同一个目录，例如/usr/local/nginx/conf目录下。更新Nginx根目录下 conf/nginx.conf 文件如下：123456789101112131415server &#123; listen 443; server_name www.domain.com; #填写绑定证书的域名 ssl on; ssl_certificate 1_www.domain.com_bundle.crt; ssl_certificate_key 2_www.domain.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; root html; #站点目录 index index.html index.htm; &#125; &#125; 配置文件参数 说明 listen 443 SSL访问端口号为443 ssl on 启用SSL功能 ssl_certificate 证书文件 ssl_certificate_key 私钥文件 ssl_protocols 使用的协议 ssl_ciphers 配置加密套件，写法遵循openssl标准 重启Nginx输入 nginx -s reload ：修改配置后重新加载生效可以看到SSL证书生效，且HTTPS可以访问站点。","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"},{"name":"Nginx","slug":"Nginx","permalink":"http://feiyang.li/tags/Nginx/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://feiyang.li/tags/HTTPS/"}]},{"title":"使用Python插入排序","slug":"Python_get_order","date":"2016-12-15T13:44:51.000Z","updated":"2017-02-07T05:47:48.848Z","comments":true,"path":"2016/12/15/Python_get_order/","link":"","permalink":"http://feiyang.li/2016/12/15/Python_get_order/","excerpt":"使用Python进行数据结构操作比较少见，但为了更深入的理解Python的操作原理，提升自己的算法能力。我决定认真过一遍 普林斯顿大学教授Robert Sedgewick主讲的《Algorithms》","text":"使用Python进行数据结构操作比较少见，但为了更深入的理解Python的操作原理，提升自己的算法能力。我决定认真过一遍 普林斯顿大学教授Robert Sedgewick主讲的《Algorithms》 【普林斯顿算法下载链接】普林斯顿大学教授Robert Sedgewick主讲的《Algorithms》 使用C++插入排序12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; int a[] = &#123; 4,3,9,0,1,2,5,6,7,8 &#125;; for(int i = 1; i &lt; 10; i++) &#123; int key = a[i]; int j = i - 1; while (j &gt;= 0&amp;&amp;a[j] &gt; key) &#123; a[j + 1] = a[j]; j--; &#125; a[j + 1] = key; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 这一段比较简单，我也就不多说了。 使用Python进行排序123456789data = [4,3,9,0,1]for i in range(1,len(data)): key = data[i] j = i - 1 while j &gt;= 0 and data[j] &gt; key: data[j+1]=data[j] j = j - 1 data[j+1] = keyprint(data) 总结： Python的确比CPP简洁得多； while循环体中条件部分可以使用 and ，不能用&amp;&amp; python没有{}，需要对齐，输入Tab或者敲空格。","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Python爬取图片（使用urllib2）","slug":"Python_use_urllib2","date":"2016-12-15T11:14:24.000Z","updated":"2017-02-11T13:27:59.892Z","comments":true,"path":"2016/12/15/Python_use_urllib2/","link":"","permalink":"http://feiyang.li/2016/12/15/Python_use_urllib2/","excerpt":"上篇文章 使用 XPath 提取网页信息 之后，将链接中的内容下载至本地，需要使用到 urllib2 。","text":"上篇文章 使用 XPath 提取网页信息 之后，将链接中的内容下载至本地，需要使用到 urllib2 。 urllib2 简介urllib2提供一个基础函数urlopen，通过向指定的URL发出请求来获取数据。最简单的形式就是： 123import urllib2 response = urllib2.urlopen('http://feiyang.li/') html = response.read() 可以将上述代码看作两个步骤，我们指定一个域名并发送请求1request=urllib2.request(&apos;http://feiyang.li/&apos;) 接着服务端响应来自客户端的请求 1response=urllib2.urlopen(request) 运行结果 我们可以发现title这个地方本来应该是中文的，但因为编码的原因，导致出现乱码。通过将html页面重新用”utf-8”编码，可以解决这个问题。 将获得的response保存至本地使用Xpath表达式提取图片链接详见上一文章 http://feiyang.li/2016/12/13/提取网页信息/ ，关于XPath和beautifulsoup，可以参考python中的beautifulsoup和xpath有什么异同点？ 这里需要导入lxml，代码格式如下。 123456import requestsfrom lxml import etreehtml = requests.get(\"http://jandan.net/ooxx\")html.encoding = 'utf-8'selector = etree.HTML(html.text)content = selector.xpath('//ol[@class = \"commentlist\"]//@src') 单独运行 以上代码可以获得 Xpath运行结果 设置保存的位置需要使用到os库中的 os.chdir(r””)函数，””中间插入地址。注意这个位置必须是存在的，如果位置不存在，函数会报错。因为该函数的意义是：将工作空间从python代码所在位置，改为指定的这个位置。 模拟正常浏览器下载图片（如果Python下载的图片不显示 ）有时你会碰到，程序也对，但是服务器拒绝你的访问。这是为什么呢? 问题出在请求中的头信息(header)。 有的服务端有洁癖，不喜欢程序来触摸它。 这个时候你需要将你的程序伪装成浏览器来发出请求。请求的方式就包含在header中。 123456header = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.114 Safari/537.36', 'Cookie': 'AspxAutoDetectCookieSupport=1', &#125; request = urllib2.Request(imgurl, None, header) response = urllib2.urlopen(request) 可以看到urllib2.Request()里边加入了一个header，用于模拟浏览器访问，第二个位置None表示data，用Python官方文档的说法：Sometimes you want to send data to a URL (often the URL will refer to a CGI (Common Gateway Interface) script [1] or other web application). With HTTP, this is often done using what’s known as a POST request. 暂时我们用不着，所以不深究，等我碰到这个问题了再说。 为图片命名（下载图片只有一张）在获得response之后，将图片直接保存为某个特定名字的话。会导致之后抓取到的图片顶替掉之前的图片，导致图片看起来只有一张。 1234with open(\"%s.jpg\" %name, \"wb\") as f: f.write(response.read()) print(imgurl) name += 1 使用with as语句，将文件名保存为%s.jpg，类似于C语言的输出。循环结束的时候name++，保证文件名不重复。 使用with as 函数Python’s with statement provides a very convenient way of dealing with the situation where you have to do a setup and teardown to make something happen. A very good example for this is the situation where you want to gain a handler to a file, read data from the file and the close the file handler.有一些任务，可能事先需要设置，事后做清理工作。对于这种场景，Python的with语句提供了一种非常方便的处理方式。一个很好的例子是文件处理，你需要获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。 Without the with statement, one would write something along the lines of:如果不用with语句，代码如下：123file = open(\"/tmp/foo.txt\")data = file.read()file.close() 使用with as之后代码为：12with open(\"%s.jpg\" %name, \"wb\") as f: f.write(response.read()) 总结本文通过XPath表达式提取页面图片链接，使用urllib2下载，其中使用header模仿浏览器访问。解决了以下问题： Python下载的图片不显示 下载图片只有一张 设置保存的位置 使用with f函数 效果如下： 抓取到的图片 完整代码 # coding=utf-8 import requests import urllib2 import os from lxml import etree html = requests.get(\"http://cl.d5j.biz/htm_mob/7/1612/2172569.html\") html.encoding = 'utf-8' selector = etree.HTML(html.text) content = selector.xpath('//table//img/@src') for imgurl in content: name = imgurl[-9:]; os.chdir(r\"D:\") header = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.114 Safari/537.36', 'Cookie': 'AspxAutoDetectCookieSupport=1', } request = urllib2.Request(imgurl, None, header) #刻意增加头部header，否则本行与下一行可以写为：response = urllib2.urlopen(imgurl) response = urllib2.urlopen(request) f = open(name , 'wb') f.write(response.read()) f.close() print(imgurl) 代码重新修改了一下，上手运行会发现D盘有惊喜哦~加入print(imgurl)，运行起来更洋气~ 输入下载来源","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://feiyang.li/tags/爬虫/"},{"name":"urllib2","slug":"urllib2","permalink":"http://feiyang.li/tags/urllib2/"}]},{"title":"使用 XPath 提取网页信息","slug":"get_html","date":"2016-12-13T08:24:34.000Z","updated":"2017-02-11T13:27:18.463Z","comments":true,"path":"2016/12/13/get_html/","link":"","permalink":"http://feiyang.li/2016/12/13/get_html/","excerpt":"以1024举例，使用XPath提取图片链接以及磁力链接地址。","text":"以1024举例，使用XPath提取图片链接以及磁力链接地址。 学习XPath的基本知识推荐 Xpath教程 很容易理解。推荐可以将常用的语法记下来，不常用的可以等用的时候再查。 推荐使用Chrome浏览器中的XPath Helper，良心之作. 左边输入XPath表达式，右侧会自动展示结果。 选择元素之后按下ctral + shift + x，可以自动提取该元素的XPath表达式。 使用Xpath 常用语法 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 @ 选取属性，常见使用方法为[@class = “title”] 举例，比如在双面胶-淘宝搜索 页面 输入: //*[@class=”m-itemlist”]//a[@trace-price&lt;20]/@href，用来提取出class为itemlist内a标签里所有price 小于20的产品，并将其href(即超链接)输出 结果展示 需要结合Chrome浏览器的F12一起使用，先选定大致的框架，比如itemlist这个class，然后逐渐加上更多的要求，具体见文首给出的链接学习。 知道这些就可以抓取1024上的图片和磁力链接了，目测是不是很简单 挑选网页实验一下 作为一名1024资深游客，首先在技术讨论区选择一篇好文，这里用的是[榴民资讯]11月精品主题推荐（49期） 使用F12查看网页的结构有两个主要标签 header 和 main ，鼠标移动到main上，可以看到内容页面都被包含起来，所以第一个节点应该选main。 main标签 使用XPath表达式筛选图片链接我们看到图片前边都有一个属性src，这个src后边就是我们所需的图片链接。 综上，使用XPath表达式: //*[@id=”main”]//@src mark 输入XPath代码，获得图片链接。 mark 使用XPath表达式筛选磁力链接同理，我们可以发现，磁力链接前边都有一个blockquote，与上一条处理方式类似，使用XPath表达式: //*[@id=”main”]//blockquote 磁力链接 以上","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://feiyang.li/tags/爬虫/"},{"name":"Xpath","slug":"Xpath","permalink":"http://feiyang.li/tags/Xpath/"}]},{"title":"永远的7012","slug":"forever_7012","date":"2016-10-28T13:33:08.000Z","updated":"2017-02-07T05:47:51.001Z","comments":true,"path":"2016/10/28/forever_7012/","link":"","permalink":"http://feiyang.li/2016/10/28/forever_7012/","excerpt":"Gary要从Running man下车了，这真是10月以来最悲伤的一件事了。","text":"Gary要从Running man下车了，这真是10月以来最悲伤的一件事了。 慌张在这件事情还没有成为热搜之前，室友私下给我发了这个消息。 当时我第一反应就觉得是假的，“怎么可能嘛，Gary之前说过七个人要永远在一起的啊。” 就算我信誓旦旦的否认了，可还是忍不住又把这个消息多看了好几遍，想找到这是个假消息的依据。 可到后来我越看越慌，直到过了两个小时以后，热搜出现Gary的名字，我才被迫相信，但还是不愿接受。 缘起其实我并没有认识他们太长时间，但却在最短的时间内被他们所吸引。 因为他们七个人，让我爱上了一个国家。 我觉得这就是韩国跑男的魅力吧，他们永远谦逊，努力，敬业，总是希望把最好的一面呈献给观众。他们七个人的感情好到让我嫉妒，多少不经意间的小动作让我们觉得这就是一家人的感觉，这种感情，绝对不是靠”We are family“就能喊出来的。 七年Running man在一起跑了七年了，每个周一都准时准点的出现在我们面前，风雨无阻，真的不是所有的综艺都可以坚持那么久的。 王鼻子大叔已经50岁了，体力明显跟不上了。 金钟国浑身是伤，根本无法再扮演能力者的角色。 其他的成员也是或多或少身体状况都不佳，不可能再回到大规模撕名牌的环节中。 我们看得出来现在的running man确实不如以前好看了，可是看到他们七个人在一起，就是最开心的事。 我知道我们总有一天要和Runningman告别，我也曾想过很多次他们会以怎样的方式跟我们说再见。可这种方式是我最不愿意见到的。 与其Gary一人离开，不如节目就到此为止吧。 因为在我心里，他们就是一个整体，谁也不能替代，谁也无法分割。 不知道RM以后会怎么发展下去，但我知道所有深爱过这个节目的人，都不会责怪他们。 就算不舍，也会把最真的祝福送给每一位成员。并且要告诉他们：谢谢他们七年的陪伴，谢谢他们为我们所做的努力，谢谢他们给我们带来那么多的快乐。 综艺人姜Gary，我们有缘再见！音乐人姜Gary，我们敬请期待！","categories":[],"tags":[{"name":"臭臭","slug":"臭臭","permalink":"http://feiyang.li/tags/臭臭/"},{"name":"Running man","slug":"Running-man","permalink":"http://feiyang.li/tags/Running-man/"}]},{"title":"C / C++ 文件读取写入、文件夹的打开","slug":"C_read","date":"2016-10-28T11:09:24.000Z","updated":"2017-02-11T13:27:15.125Z","comments":true,"path":"2016/10/28/C_read/","link":"","permalink":"http://feiyang.li/2016/10/28/C_read/","excerpt":"使用C++做文件处理时常用的几个函数","text":"使用C++做文件处理时常用的几个函数 文件的打开与关闭 (open和close函数)文件读取之前，使用open函数进行打开。文件使用完毕后，使用close命令关闭。 12infile.open(\"E:\\\\hello.txt\");infile.close(); 文件读取与写入(infile &gt;&gt; income,outfile &lt;&lt; “income:”)C++中可以调用库 #include&lt;fstream&gt; 之后可以使用，”&gt;&gt;”和”&lt;&lt;”输入输出流的形式进行文件的读取 12345678while (infile &gt;&gt; income) &#123; if (income &lt; cutoff) tax = rate1*income; else tax = rate2*income; outfile &lt;&lt; \"income:\"&lt;&lt;left&lt;&lt;setw(6) &lt;&lt; income &lt;&lt; right&lt;&lt;setw(8) &lt;&lt; \"Tax:\" &lt;&lt;tax&lt;&lt; endl; &#125; 文件夹/文件的打开在程序运行完之后，你可能会希望自动将输出的结果文件打开。调 Windows Exploler 打开一个文件夹， 1system(\"start E:\\\\tax.out\"); E:\\tax.out 就是你文件的地址 运行程序demo读取hello.txt文件内的收入数据，计算税金，并输出到tax.txt中 demo hello.txt，直接 Ctrl+S 保存到E盘即可 C++代码如下1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;iomanip&gt;using namespace std;const int cutoff = 6000;const float rate1 = 0.3;const float rate2 = 0.6;void main() &#123; ifstream infile; ofstream outfile; int income, tax; infile.open(\"E:\\\\hello.txt\"); outfile.open(\"E:\\\\tax.txt\"); while (infile &gt;&gt; income) &#123; if (income &lt; cutoff) tax = rate1*income; else tax = rate2*income; outfile &lt;&lt; \"income:\"&lt;&lt;left&lt;&lt;setw(6) &lt;&lt; income &lt;&lt; right&lt;&lt;setw(8) &lt;&lt; \"Tax:\" &lt;&lt;tax&lt;&lt; endl; &#125; infile.close(); outfile.close(); cout &lt;&lt; \"done\"&lt;&lt;endl; system(\"start E:\\\\tax.txt\");&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://feiyang.li/tags/C/"}]},{"title":"《解忧杂货店》","slug":"book","date":"2016-10-28T04:30:59.000Z","updated":"2017-02-13T08:36:38.289Z","comments":true,"path":"2016/10/28/book/","link":"","permalink":"http://feiyang.li/2016/10/28/book/","excerpt":"我一直很努力去当一个善良的人，却总是在现实中受到各种打击。","text":"我一直很努力去当一个善良的人，却总是在现实中受到各种打击。 以至于让我觉得根本不需要总是对别人那么好，或者说其实我希望可以一直对别人保持一颗有爱的心，只不过我需要力量支撑而已。 而解忧杂货店就给了我这种力量。 解忧杂货店 浪矢爷爷说，人的心声是最不能被忽视的。所以不管是什么内容的信，玩笑的或是严肃的，甚至是一张白纸，他都会认认真真的回复。 因为人与人之间本来就是相互影响的，你的一举一动，一句在你看来是无所谓的话，却可能对别人造成很大的影响。 不要总想着设身处地，我们永远不是别人，总是很难站在别人角度考虑问题，稍不留神就以己度人了。 所以，子所不欲勿施于人，己所欲也勿施于人。 收到那么多封烦恼咨询信后，我慢慢发现其实很多人在写信的时候心里就已经有自己的答案了，他们写信的目的就是为了让别人可以支持他们的想法。 但他们读过回信之后会再写信过来，就说明双方观点不太一样。所以才会反反复复进行那么多次通信，就为了说服别人同意自己的想法。 我就想到每次我想买啥东西又不好意思买的时候，就会假装向阳询问，而阳就会 二话不说 立马给我买了。他竟然那么早就懂了这个道理，真是好棒呀！ 我不知道别人判断一本好书的标准是什么，我不认识东野圭吾，不知道kindle里边他的排名，就只是很喜欢这种故事，有爱情，有亲情，有事业，有梦想。 很平凡，平凡到感觉里边的人物就是生活中的你和我。但文学总是高于生活的，时空的交错，奇妙的构思让我觉得善良的人在冥冥之中总会受到保佑。 文章中的最后一段话好像是这样的，敦也从信纸上抬起头，正好对上了另两个人的视线，他发现他俩的眼里闪着光芒，他想他的眼里也一定是这样的。而我想说，读完这本书以后，我也是这样的感觉。 mark","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"臭臭","slug":"臭臭","permalink":"http://feiyang.li/tags/臭臭/"}]},{"title":"Python基础","slug":"Python_basic","date":"2016-10-27T03:38:32.000Z","updated":"2017-02-11T13:28:16.372Z","comments":true,"path":"2016/10/27/Python_basic/","link":"","permalink":"http://feiyang.li/2016/10/27/Python_basic/","excerpt":"脚本运行 Windows 下需将python加入的系统变量中； Linux 下需添加头部","text":"脚本运行 Windows 下需将python加入的系统变量中； Linux 下需添加头部 12#! /usr/bin/enc python print('Hello World!') 循环 for 循环for 元素 in 序列: statement while 循环while 条件: statement 函数函数的定义123def square_sum(a,b): c = a**2 + b**2 return c def，这个关键字通知python：我在定义一个函数。square_sum是函数名。括号中的a, b是函数的参数，是对函数的输入。 函数调用和参数传递12345678910111213141516171819a = 1def change_integer(a): a = a + 1 return aprint (change_integer(a)) #注意观察结果print (a) #注意观察结果#===(Python中 \"#\" 后面跟的内容是注释，不执行 )b = [1,2,3]def change_list(b): b[0] = b[0] + 1 return bprint (change_list(b)) #注意观察结果print (b) #注意观察结果 运行结果 第一个例子，我们将一个整数变量传递给函数，函数对它进行操作，但原整数变量a不发生变化。第二个例子，我们将一个表传递给函数，函数进行操作，原来的表b发生变化。对于基本数据类型的变量，变量传递给函数后，函数会在内存中复制一个新的变量，从而不影响原来的变量。（我们称此为值传递）但是对于表来说，表传递给函数的是一个指针，指针指向序列在内存中的位置，在函数中对表的操作将在原有内存中进行，从而影响原有变量。 （我们称此为指针传递）。 类我们定义一个类“鸟”，鸟有羽毛，鸟的方法是下蛋，定义一个函数fly()。123456789101112class Bird(object): feather = True way = 'egg' def fly(self, dx, dy): position = [0,0] position[0] = position[0] + dx position[1] = position[1] + dy return positionsummer = Bird()print (after move:',summer.fly(5,8)) 方法的第一个参数必须是self，无论是否用到。 我的summer可以飞了。 常见python os 命令 os.getcwd() 函数得到当前工作目录，即当前Python脚本工作的目录路径。 os.listdir() 返回指定目录下的所有文件和目录名。 os.remove() 删除一个文件。 os.chdir(dirname) 改变工作目录到dirname","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Android正则表达式及Pattern Matcher使用","slug":"Android_Pattern Matcher","date":"2016-10-19T13:25:57.000Z","updated":"2016-10-20T07:14:18.936Z","comments":true,"path":"2016/10/19/Android_Pattern Matcher/","link":"","permalink":"http://feiyang.li/2016/10/19/Android_Pattern Matcher/","excerpt":"Pattern Matcher使用众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生","text":"Pattern Matcher使用众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生 而这些情况有时又比较复杂，如果用纯编码方式解决，往往会浪费程序员的时间及精力。因此，学习及使用正则表达式，便成了解决这一矛盾的主要手段。 一个正则表达式就是由普通的字符（例如字符a到z）以及特殊字符（元字符）组成的文字模式，它用以描述在查找文字主体时待匹配的一个或多个字符串。 加入特定限制条件「[]」 [a-z] 条件限制在小写a to z范围中一个字符 [A-Z] 条件限制在大写A to Z范围中一个字符 [a-zA-Z] 条件限制在小写a to z或大写A to Z范围中一个字符 [0-9] 条件限制在小写0 to 9范围中一个字符 [0-9a-z] 条件限制在小写0 to 9或a to z范围中一个字符 [0-9[a-z]] 条件限制在小写0 to 9或a to z范围中一个字符(交集) []中加入^后加再次限制条件「[^]」 [^a-z] 条件限制在非小写a to z范围中一个字符 [^A-Z] 条件限制在非大写A to Z范围中一个字符 [^a-zA-Z] 条件限制在非小写a to z或大写A to Z范围中一个字符 [^0-9] 条件限制在非小写0 to 9范围中一个字符 [^0-9a-z] 条件限制在非小写0 to 9或a to z范围中一个字符 [^0-9[a-z]] 条件限制在非小写0 to 9或a to z范围中一个字符(交集) 在限制条件为特定字符出现0次以上时，可以使用「*」 J* 0个以上J .* 0个以上任意字符 J.*D J与D之间0个以上任意字符 在限制条件为特定字符出现1次以上时，可以使用「+」 J+ 1个以上J .+ 1个以上任意字符 J.+D J与D之间1个以上任意字符 Pattern Matcher的例子查找以Java开头,任意结尾的字符串1234Pattern pattern = Pattern.compile(\"^Java.*\"); Matcher matcher = pattern.matcher(\"Java不是人\"); boolean b= matcher.matches(); //当条件满足时，将返回true，否则返回false System.out.println(b); 以多条件分割字符串时12345Pattern pattern = Pattern.compile(\"[, |]+\"); String[] strs = pattern.split(\"Java Hello World Java,Hello,,World|Sun\"); for (int i=0;i&lt;strs.length;i++) &#123; System.out.println(strs[i]); &#125; 文字替换（首次出现字符）12345Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World\"); //替换第一个符合正则的数据 System.out.println(matcher.replaceFirst(\"Java\")); ` 文字替换（全部）12345Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World\"); //替换第一个符合正则的数据 System.out.println(matcher.replaceAll(\"Java\")); ` 文字替换（置换字符）12345678Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World \"); StringBuffer sbr = new StringBuffer(); while (matcher.find()) &#123; matcher.appendReplacement(sbr, \"Java\"); &#125; matcher.appendTail(sbr); System.out.println(sbr.toString()); 验证是否为邮箱地址1234String str=\"ceponline@yahoo.com.cn\"; Pattern pattern = Pattern.compile(\"[//w//.//-]+@([//w//-]+//.)+[//w//-]+\",Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(str); System.out.println(matcher.matches()); 查找html中对应条件字符串12345Pattern pattern = Pattern.compile(\"href=/\"(.+?)/\"\"); Matcher matcher = pattern.matcher(\"&lt;a href=/\"index.html/\"&gt;主页&lt;/a&gt;\"); if(matcher.find()) System.out.println(matcher.group(1)); &#125; 截取http://地址12345678Pattern pattern = Pattern.compile(\"(http://|https://)&#123;1&#125;[//w//.//-/:]+\"); Matcher matcher = pattern.matcher(\"dsdsds&lt;http://dsds//gfgffdfd&gt;fdf\"); StringBuffer buffer = new StringBuffer(); while(matcher.find())&#123; buffer.append(matcher.group()); buffer.append(\"/r/n\"); System.out.println(buffer.toString()); &#125; 替换指定{}中文字12345678910public static String replace(final String sourceString,Object[] object) &#123; String temp=sourceString; for(int i=0;i&lt;object.length;i++)&#123; String[] result=(String[])object[i]; Pattern pattern = Pattern.compile(result[0]); Matcher matcher = pattern.matcher(temp); temp=matcher.replaceAll(result[1]); &#125; return temp; &#125; 以正则条件查询指定目录下文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//用于缓存文件列表 private ArrayList files = new ArrayList(); //用于承载文件路径 private String _path; //用于承载未合并的正则公式 private String _regexp; class MyFileFilter implements FileFilter &#123; /** * 匹配文件名称 */ public boolean accept(File file) &#123; try &#123; Pattern pattern = Pattern.compile(_regexp); Matcher match = pattern.matcher(file.getName()); return match.matches(); &#125; catch (Exception e) &#123; return true; &#125; &#125; &#125; /** * 解析输入流 * @param inputs */ FilesAnalyze (String path,String regexp)&#123; getFileName(path,regexp); &#125; /** * 分析文件名并加入files * @param input */ private void getFileName(String path,String regexp) &#123; //目录 _path=path; _regexp=regexp; File directory = new File(_path); File[] filesFile = directory.listFiles(new MyFileFilter()); if (filesFile == null) return; for (int j = 0; j &lt; filesFile.length; j++) &#123; files.add(filesFile[j]); &#125; return; &#125; /** * 显示输出信息 * @param out */ public void print (PrintStream out) &#123; Iterator elements = files.iterator(); while (elements.hasNext()) &#123; File file=(File) elements.next(); out.println(file.getPath()); &#125; &#125; public static void output(String path,String regexp) &#123; FilesAnalyze fileGroup1 = new FilesAnalyze(path,regexp); fileGroup1.print(System.out); &#125; public static void main (String[] args) &#123; output(\"C://\",\"[A-z|.]*\"); &#125; Java正则的功用还有很多，事实上只要是字符处理，就没有正则做不到的事情存在。（正则解释时较耗时间就是了|||……）","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://feiyang.li/tags/Android/"},{"name":"Pattern","slug":"Pattern","permalink":"http://feiyang.li/tags/Pattern/"}]},{"title":"VelocityTracker滑动屏幕切换Activity","slug":"VelocityTracker_Activity","date":"2016-10-19T09:11:28.000Z","updated":"2016-10-20T07:13:10.520Z","comments":true,"path":"2016/10/19/VelocityTracker_Activity/","link":"","permalink":"http://feiyang.li/2016/10/19/VelocityTracker_Activity/","excerpt":"我现在非常恨自己手贱选了安卓这门课，作业多的令人发指。不过自己选的课，哭着也要上完。本文主要讲解如何实现 滑动屏幕时切换Activity","text":"我现在非常恨自己手贱选了安卓这门课，作业多的令人发指。不过自己选的课，哭着也要上完。本文主要讲解如何实现 滑动屏幕时切换Activity VelocityTracker简介 android.view.VelocityTracker主要用跟踪触摸屏事件（flinging事件和其他gestures手势事件）的速率。 用addMovement(MotionEvent)函数将Motion event加入到VelocityTracker类实例中。 使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。 使用recycleVelocityTracker()释放空间，循环使用。 当你需要跟踪触摸屏事件的速度的时候 使用obtain() 方法来获得 VelocityTracker 类的一个实例对象在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象使用computeCurrentVelocity (int units)函数来计算当前的速度，使用 getXVelocity ()、 getYVelocity ()函数来获得当前的速度。 使用VelocityTracker123456789101112131415161718192021222324252627private void initView()&#123; entryLayout = (RelativeLayout)super.findViewById(R.id.entry); entryLayout.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; createVelocityTracker(event); //获取实例对象 switch(event.getAction())&#123; case MotionEvent.ACTION_DOWN: // xDown=event.getX(); break; case MotionEvent.ACTION_MOVE: int xSpeed = getScrollVelocity(); xMove = event.getRawX(); int distanceX1 = (int) (xMove - xDown); int distanceX2 = (int) (xDown-xMove); if ((distanceX1 &gt; XDISTANCE_MIN||distanceX2&gt;XDISTANCE_MIN )&amp;&amp;(xSpeed&gt;XSPEED_MIN)) &#123; openNew(); &#125; break; case MotionEvent.ACTION_UP: recycleVelocityTracker(); &#125; return true; &#125; &#125;); &#125; 对于 MotionEventACTION_DOWN: 表示用户开始触摸. ACTION_MOVE: 表示用户在移动(手指或者其他) ACTION_UP:表示用户抬起了手指 ACTION_CANCEL:表示手势被取消了 ACTION_OUTSIDE: 表示用户触碰超出了正常的UI边界. ACTION_POINTER_DOWN:有一个非主要的手指按下了. ACTION_POINTER_UP:一个非主要的手指抬起来了 其余部分代码12345678910111213141516171819202122232425private int getScrollVelocity() &#123;//计算移动距离 mVelocityTracker.computeCurrentVelocity(1000); int velocity = (int) mVelocityTracker.getXVelocity(); return Math.abs(velocity); &#125; private void createVelocityTracker(MotionEvent event)&#123; if(mVelocityTracker == null)&#123; mVelocityTracker = VelocityTracker.obtain(); //获得VelocityTracker类实例 &#125; mVelocityTracker.addMovement(event);//将事件加入到VelocityTracker类实例中 &#125; private void recycleVelocityTracker()&#123; mVelocityTracker.recycle(); mVelocityTracker = null; &#125; private void openNew()&#123; Intent intent = new Intent(SCOSEntry.this,MainScreen.class); Bundle bundle = new Bundle(); bundle.putString(\"message\",\"FromEntry\"); intent.putExtras(bundle); startActivity(intent); &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://feiyang.li/tags/Android/"},{"name":"VelocityTracker","slug":"VelocityTracker","permalink":"http://feiyang.li/tags/VelocityTracker/"}]},{"title":"搭建个人SSR帐号及私人分享","slug":"SSR","date":"2016-10-19T06:13:18.000Z","updated":"2017-02-11T13:29:08.195Z","comments":true,"path":"2016/10/19/SSR/","link":"","permalink":"http://feiyang.li/2016/10/19/SSR/","excerpt":"本文转自1024社区，讲了一下SSR的搭建流程，并分享自己的SSR服务器。","text":"本文转自1024社区，讲了一下SSR的搭建流程，并分享自己的SSR服务器。 服务器配置安装SSR1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/shadowsocks_install/master/shadowsocksR.sh &amp;&amp; bash shadowsocksR.sh 锐速一键包1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh finalspeed 一键包1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/finalspeed/master/install_fs.sh &amp;&amp; bash install_fs.sh finalspeed客户端配置假设服务器 IP 为 10.10.10.10,finalspeed 端口为默认 150,ss 端口为 8989. 加速前提 ss 服务端运行正常, ss 客户端也能正常登录,运行FinalSpeed客户端,填写服务器地址 10.10.10.10 . 搭建个人SSR帐号及私人 点击添加,增加加速端口,加速端口为ss端口8989,如果为其他端口,请相应修改,本地端口任意,这里是2000 打开ss客户端,添加服务器,服务器IP为127.0.0.1,服务器端口为加速端口对应的本地端口,这里是2000,然后设置你的ss密码,加密方式 确定保存,选择使用刚添加的服务器,并设置浏览器代理,成功连接后,FinalSpeed状态栏会出现”连接服务器成功”提示.SSR 客户端、Xshell5和finalspeed客户端自己百度下载吧，我就不分享主要是不知用什么网盘分享，度盘不安全，免得被请去喝茶。 安卓版SSR下载地址下载地址：http://cdn.mmmxcc.cn/ssr_3.0.2.2.apk 因为本网站已经备案，所以。。。有什么问题可以留言或发送邮件~","categories":[],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"},{"name":"SSR","slug":"SSR","permalink":"http://feiyang.li/tags/SSR/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"}]},{"title":"无公网IP服务器搭建Web站点","slug":"without_IP_build_Website","date":"2016-10-19T05:25:29.000Z","updated":"2017-02-11T13:28:24.691Z","comments":true,"path":"2016/10/19/without_IP_build_Website/","link":"","permalink":"http://feiyang.li/2016/10/19/without_IP_build_Website/","excerpt":"前言很多时候我们都会碰到 无公网IP ，比如家用电脑，或者在阿里云上贪便宜买的服务器等。对于科大学生，就更容易出现这种情况了，科大学生可以从http://cloud.ustc.edu.cn/ 申请校内云主机，配置高，网速快，免流量，简直就是学生狗的福音啊。唯一的问题就是，提供的地址是校内IP，使用起来很不方便，搭建Web站点的时候就会遇到很多问题。","text":"前言很多时候我们都会碰到 无公网IP ，比如家用电脑，或者在阿里云上贪便宜买的服务器等。对于科大学生，就更容易出现这种情况了，科大学生可以从http://cloud.ustc.edu.cn/ 申请校内云主机，配置高，网速快，免流量，简直就是学生狗的福音啊。唯一的问题就是，提供的地址是校内IP，使用起来很不方便，搭建Web站点的时候就会遇到很多问题。 本文介绍一种免费内网穿透方案，ngrok 。 该方案与花生壳差不多，只不过花生壳变坏了，现在开始要钱，每个月还限制流量1g。对于网站来说，1个g能干什么，卖萌么。 在vps中下载对应版本的客户端 选择对应的客户端 本文以中国科大云的ubuntu系统为例，首先输入命令1sudo -s 本命令的作用是提升权限，否则之后会不停的要求输入密码的，然后下载客户端。1wget http://hls.ctopus.com/sunny/linux_amd64.zip 下载完毕之后，就要安装ngrok了。 注册端口获得隧道ID在安装之后，需要进入网站注册，注册的目的就是告诉服务器，你希望将服务器的哪个端口和自己的系统的哪个端口相映射，比如这个样子。 选择映射端口 本地端口注意，需要填写本机在局域网内的IP地址和服务端口，我这里写的tcp：22，为了SSH连接使用的，当然也可以像下边这个样子。 SSH连接端口 这里可以使用前缀域名，也可以使用自己的域名，如果使用自己域名的话，需要将域名的CNAME指向到 server.ngrok.cc 。提醒一下，自定义域名会比前缀域名速度慢很多。复制一下，自动生成的隧道ID，一会儿有用哦~ 配置服务器参数服务器端配置完毕之后，回到自己的VPS控制台，输入12cd linux_amd64/nohup ./sunny clientid 9328c9d3f12326e9 后边那一串9328c9d3f12326e9 就是隧道ID，用自己的ID进行替换就好。解释一下nohup的作用，因为SSH连接断掉，或者退出该页面的话，会导致该ngrok关闭，使用nohup可以让本命令在后台运行，直接关毕SSH不会影响ngrok的运行。 切记，这可是一个晚上的深刻教训 啊。。。 这个时候应该就可以看到成功页面了，打开自己的网址就可以看到自己Web服务器里边的东西了~~ 这种内网穿透也就是所谓的TCP转发其实一点也不靠谱，速度巨慢。但是很多人为了调试微信小程序不得不使用这种方法，真心建议各位去闲鱼上，找个学生买个腾讯云服务器，一个月1块钱，而且还有公网IP。用起来不知道比这种方法快到哪里去了。","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"}]},{"title":"回到了苏州","slug":"return_suzhou","date":"2016-10-08T12:28:44.000Z","updated":"2017-02-11T13:28:28.884Z","comments":true,"path":"2016/10/08/return_suzhou/","link":"","permalink":"http://feiyang.li/2016/10/08/return_suzhou/","excerpt":"又回到了苏州 今天我回到了苏州，想想昨天还在北京，和臭臭在一起吃KFC，就觉得好梦幻。","text":"又回到了苏州 今天我回到了苏州，想想昨天还在北京，和臭臭在一起吃KFC，就觉得好梦幻。 臭臭，你是我见到过最棒最好的女孩子了。我特别怕我让你失望，我一定会好好努力的。 以前我给你写的那些纸，都跟流水账一样的。因为我的确不会写日记，以前写日记就是早上干了什么晚上干了什么的，一通记录了事。我以后会好好写的，我做了好多事情，都对不起你。 我会努力的 我真觉得自己配不上你，但是我会努力的。我想和你一起留在北京，我想让你离妈妈爸爸近一些，我想看着孩子长大。 臭臭，谢谢你。 我和臭臭","categories":[],"tags":[{"name":"love","slug":"love","permalink":"http://feiyang.li/tags/love/"}]},{"title":"今天我要去北京见臭臭啦","slug":"travel_to_peking","date":"2016-09-29T12:28:44.000Z","updated":"2017-02-11T13:28:20.163Z","comments":true,"path":"2016/09/29/travel_to_peking/","link":"","permalink":"http://feiyang.li/2016/09/29/travel_to_peking/","excerpt":"","text":"又可以见面了 现在是中午12点，我还在收拾东西，下午就要“坐”火车去北京了。 我真的很想臭臭。 chou)","categories":[],"tags":[{"name":"love","slug":"love","permalink":"http://feiyang.li/tags/love/"}]},{"title":"关于我","slug":"resume","date":"2016-01-18T12:02:28.000Z","updated":"2017-02-11T13:20:43.932Z","comments":true,"path":"2016/01/18/resume/","link":"","permalink":"http://feiyang.li/2016/01/18/resume/","excerpt":"个人信息 李飞阳/男/1994 本科/华中科技大学 硕士/中国科学技术大学","text":"个人信息 李飞阳/男/1994 本科/华中科技大学 硕士/中国科学技术大学 Github：http://github.com/mmmwhy 工作经历360 产品经理 2016.03-2016.08360好药 需求设计 使用 Mockplus 完成 APP 1.6、1.7、1.8 产品需求分析和原型设计； 推进疾病症状搜索功能上线，提高用户搜索体验； 360电商云 前端原型设计 与运营人员沟通确认需求范围，整理需求优先级并提交技术排期开发； 360全球药 （国内最大赴印丙肝服务机构）前端后端需求 使用Axure设计360全球药前端页面原型； 设计全球药后台系统，完成多次活动策划方案的原型与后台设计； OPPO 产品经理 2014.07-2014.08产品服务质量提升 项目背景：微信客服好评率一直非常高，但在调研中发现该产品口碑却偏低。 项目目标：解释弹窗评价与调研反馈的差异，找出产品改进的方向，扭转差口碑的局面。 所做工作：使用 R 统计后台数据，发现微信后台 Bug，通过用户访谈确定问题。重新分析规划服务流程，确立新的 KPI，制作产品报告提供优化建议，进行 A/B 测试并推动实施。 项目成果：通过修补 Bug，改进服务流程，推广 Q&amp;A 系统。一个月后的调研中，微信服务评分上升约 30 个点。 OPPO官方论坛改版 项目目标：由满足功能性为主转化为满足娱乐性需求，提高论坛的可玩性； 推广策划：使用 SWOT 和 3W 分析市场状况，根据 OPPO 服务理念设计朋友圈/微博营销方案，进行实施和效果评估。 致谢唯厨房和远方不可辜负也~","categories":[],"tags":[{"name":"resume","slug":"resume","permalink":"http://feiyang.li/tags/resume/"}]}]}