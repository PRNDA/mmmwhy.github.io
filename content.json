{"meta":{"title":"李飞阳","subtitle":"PM、Coder、Data mining","description":"Python ,Code,Data mining","author":"Wing Lee","url":"http://feiyang.li"},"pages":[{"title":"诶哟喂，你好像进错地方了","date":"2017-03-23T11:32:53.747Z","updated":"2017-03-23T11:32:53.747Z","comments":true,"path":"404.html","permalink":"http://feiyang.li/404.html","excerpt":"","text":"我也想给你听这首歌，告诉你，你是最完美的女孩。 我对你的爱，从山的这头，到海的那头。 就像风走了八百里，不问归期。 你可能看不到，但我一直都在你身边。 有一美人兮， 见之不忘。 一日不见兮， 思之如狂。 凤飞翱翔兮， 四海求凰。 无奈佳人兮， 不在东墙。 将琴代语兮， 聊写衷肠。 何日见许兮， 慰我彷徨。 愿言配德兮， 携手相将。 不得於飞兮， 使我沦亡。"},{"title":"膜拜大佬","date":"2017-05-23T04:45:19.188Z","updated":"2017-05-23T04:45:19.188Z","comments":true,"path":"link.html","permalink":"http://feiyang.li/link.html","excerpt":"","text":"排名不分先后 &nbsp;&nbsp;Anotherhome https://www.anotherhome.net &nbsp;&nbsp;ilanyu's Blog http://blog.lanyus.com/ &nbsp;&nbsp;科研软件小站 http://www.sciencesoft.cn/ &nbsp;&nbsp;Indoor && BlockChain https://jinfeijie.cn &nbsp;&nbsp;&nbsp;&nbsp;请多指教"},{"title":"整理","date":"2017-03-27T11:15:33.000Z","updated":"2017-03-27T11:48:25.701Z","comments":false,"path":"categories/index.html","permalink":"http://feiyang.li/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-03-27T11:28:04.000Z","updated":"2017-03-27T11:47:02.502Z","comments":false,"path":"tags/index.html","permalink":"http://feiyang.li/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法实验(一)","slug":"algorithm1","date":"2017-05-24T10:48:48.000Z","updated":"2017-05-24T10:50:56.516Z","comments":true,"path":"2017/05/24/algorithm1/index.html","link":"","permalink":"http://feiyang.li/2017/05/24/algorithm1/index.html","excerpt":"苏州分校大部分的课程都是垃圾，毁我青春，颓我精神， 败我钱财！少有一些譬如《算法导论》这样的好课，我现在回忆起自己在华科的时候，其实很多老师都是兢兢业业的讲课，但是全然不顾底下同学的接受能力，是不是也是垃圾课程呢？","text":"苏州分校大部分的课程都是垃圾，毁我青春，颓我精神， 败我钱财！少有一些譬如《算法导论》这样的好课，我现在回忆起自己在华科的时候，其实很多老师都是兢兢业业的讲课，但是全然不顾底下同学的接受能力，是不是也是垃圾课程呢？ 快速排序相关文章 普通快速排序算法效率： 最坏情况下分析：当输入序列是正序或者是反序的时候，效率最坏，这时效率是$Θ(n^2)$ 最优情况下分析：其他情况下的算法效率趋向于$Θ（nlgn）$伪代码对整个数组进行递归排序：12345QUICKSORT(A,p,r)if p &lt; r: q = PARTITION(A,p,r); QUICKSORT(A,p,q-1); QUICKSORT(A,q+1,r); 快速排序算法的关键是PARTITION过程，它对A[p..r]进行就地重排：123456789PARTITION(A,p,r)x = A[r]i = p-1for j = p to r-1// A[j]是待比较的元素 if A[j] ≤ r// 若A[j]比主元小 i = i + 1 // i往后一位（符合，不用替换；不符合i就停在这个地方，等着j过来叫唤） exchange A[i] with A[j]//倘若A[j]比主元小，其实是不发生交换的。exchange A[i+1] with A[r]return i + 1 python代码12345678910111213141516171819202122232425262728293031323334# coding=utf-8import datetimeimport sys sys.setrecursionlimit(1000000)def SET_NUMBER(): l = [] for i in range(0,len(range(1,2000,2)[::-1])-1): l.append(range(1,2000,2)[::-1][i]) return l def PARTITION(A,p,r): x = A[r] i = p - 1 for j in range(p,r): if A[j]&lt;=x: i = i + 1 A[i],A[j]=A[j],A[i] A[i+1],A[r] = A[r],A[i+1] return i+1def QUICKSORT(A,p,r): if p &gt;= r: return q = PARTITION(A,p,r) QUICKSORT(A,p,q-1) QUICKSORT(A,q+1,r) if __name__ == '__main__': l = SET_NUMBER() time1 = datetime.datetime.now() QUICKSORT(l,0,len(l)-1) time2 = datetime.datetime.now() print(time2-time1) 随机快速排序算法效率我们已经知道，若输入本身已被排序，那么对于快排来说就糟了。那么如何避免这样的情况？一种方法时随机排列序列中的元素；另一种方法时随机地选择主元（pivot）。这便是随机化快速排序的思想，这种快排的好处是：其运行时间不依赖于输入序列的顺序。 经分析， 随机化快排的算法效率是$Θ(nlgn)$ 伪代码下面是分化（Partition）1234Random_Partition(vector&lt;T&gt; &amp;A,int p,int q) int i=rand()%(q-p)+p; //此行与快排不同、加入随机数参数器 Swap(A[i],A[p]); //此行与快排不同、随机选取主元 return Partition(A,p,q);//此次与快速排序一样 随机化快速排序12345Random_Quick_Sort(vector&lt;T&gt; &amp;A,int p,int q) if (p&lt;q): int i=Random_Partition(A,p,q); Random_Quick_Sort(A,p,i-1); Random_Quick_Sort(A,i+1,q); python代码1234567891011121314151617181920212223242526272829303132333435363738# coding=utf-8import datetimeimport randomdef SET_NUMBER(): l = [] for i in range(0,len(range(1,2000,2)[::-1])-1): l.append(range(1,2000,2)[::-1][i]) return ldef PARTITION(A,p,r): x = A[r] i = p - 1 for j in range(p,r): if A[j]&lt;=x: i = i + 1 A[i],A[j]=A[j],A[i] A[i+1],A[r] = A[r],A[i+1] return i+1def Random_Partition(A,p,r): i = random.randint(p, r) A[i],A[p]=A[p],A[i] return PARTITION(A,p,r)def QUICKSORT(A,p,r): if p &gt;= r: return q = Random_Partition(A,p,r) QUICKSORT(A,p,q-1) QUICKSORT(A,q+1,r) if __name__ == '__main__': l = SET_NUMBER() time1 = datetime.datetime.now() QUICKSORT(l,0,len(l)-1) time2 = datetime.datetime.now() print(time2-time1) 时间效率 对于倒序数组range(1,2000,2)[::-1](1000个数字) 使用正常快速排序时间为：0:00:00.082566 使用随机快速排序时间为：0:00:00.005815 对于随机数组random.randint(0,9999)(重复1000次) 使用正常快速排序时间为：0:00:00.002974 使用随机快速排序时间为：0:00:00.004901 分析性能差异快速排序的平均时间复杂度为$O(nlogn)$，最坏时间时间可达到$O(n^2)$，最坏情况是当要排序的数列基本有序的时候。根据快速排序的工作原理我们知道，选取第一个或者最后一个元素作为主元，快速排序依次将数列分成两个数列，然后递归将分开的数列进行排序。 当把数列平均分成两个等长的数列时，效率是最高的，如果相差太大，效率就会降低。 我们通过使用随机化的快速排序随机的从数列中选取一个元素与第一个，或者最后一个元素交换，这样就会使得数列有序的概率降低。 所以随机快速排序平均速度是比快速排序要快的，但是因为随机排序需要有设置随机数+交换元素的时间，因此总时间上不如普通快速排序。 背包问题相关文章 动态规划知识复习基本步骤 找出最优解的性质，并刻画其结构特征 递归地定义最优解的值 以自底而上的方式计算出最优值 根据计算最优值时得到的信息，构造一个最优解。若给定问题具有以下性质： 最优子结构：如果一个问题的最优解中包含了其子问题的最优解，就说该问题具有最优子结构。当一个问题具有最优子结构时，提示我们动态规划法可能会适用，但是此时贪心策略可能也是适用的。 重叠子问题：指用来解原问题的递归算法可反复地解同样的子问题，而不是总在产生新的子问题。即当一个递归算法不断地调用同一个问题时，就说该问题包含重叠子问题。此时若用分治法递归求解，则每次遇到子问题都会视为新问题，会极大地降低算法的效率，而动态规划法总是充分利用重叠子问题，对于每个子问题仅计算一次，把解保存在一个在需要时就可以查看的表中，而每次查表的时间为常数。 0-1背包问题定义问题问题：有n个物品，第i个物品价值为$v_i$，重量为$w_i$，其中$v_i$和$w_i$均为非负数，背包的容量为W，W为非负数。现需要考虑如何选择装入背包的物品，使装入背包的物品总价值最大。 该问题以形式化描述如下： 目标函数为 ： 约束条件为： 满足约束条件的任一集合（x1，x2，…，xn）是问题的一个可行解，问题的目标是要求问题的一个最优解。考虑一个实例，假设n=5，W=17， 每个物品的价值和重量如下表所示。可将物品1，2和5装入背包，背包未满，获得价值22，此时问题解为你（1，1，0，0，1）。也可以将物品4和5装入背包，背包装满，获得价值24，此时解为（0，0，0，1，1）。 按步骤求解问题 找出最优解的性质，并刻画其结构特征可以将背包问题的求解过程看作是进行一系列的决策过程，即决定哪些物品应该放入背包，哪些物品不放入背包。如果一个问题的最优解包含了物品n，即$x_n=1$，那么其余$x_1，x2，…，x(n-1)$一定构成子问题1，2，…，n-1在容量W-wn时的最优解。如果这个最优解不包含物品n，即$x_n$=0，那么其余$x_1，x2，…，x(n-1)$一定构成子问题1，2，…，n-1在容量W时的最优解。 递归定义最优解的值根据上述分析的最优解的结构递归地定义问题最优解。设c[i,w]表示背包剩余容量为w时，i个物品导致的最优解的总价值。分为三种情况： i或者w等于0，没有空间也没有物品的时候； 第i的物品的重量已经超过当前空间时； 在增加第i个物品和不增加第i个物品之间做出艰难的抉择； 以自底而上的方式计算出最优值伪代码：123456789BOTTOM-UP-CUT-ROD(p,n)let r[0..n] be a new arrayr[0]= 0for j = 1 to n q= -∞ for i = 1 to j q = max(q, p[i]+r[j-i]) r[j]= qreturn r[n] python代码12345678910111213141516171819202122232425262728293031#coding:utf-8 def bag(n,m,w,v): res = [[0 for j in range(m+1)]for i in range(n+1)] #n+1 行，m+1列 值为0的矩阵 for i in range(1,n+1): for j in range(1,m+1): res[i][j] = res[i-1][j] #0-&gt;res[0][1]-&gt;res[1][1] if j&gt;=w[i-1] and res[i][j]&lt;res[i-1][j-w[i-1]]+v[i-1]:#如果res[i-1][j]小于res[i-1][j-w[i-1]]+v[i-1]，那么res[i][j]就等于res[i-1][j]，否则就等于res[i-1][j-w[i-1]]+v[i-1] res[i][j] = res[i-1][j-w[i-1]]+v[i-1] return res def show(n,m,w,res): print (u\"最大值为%d\"%res[n][m]) x = [False for i in range(n)] j = m for i in range(n,0,-1): if res[i][j]!=res[i-1][j]: x[i-1] = True j-=w[i-1] print (u\"选择的物品为\") for i in range(n): if x[i]: print(u\"第%d个\"%(i+1)) if __name__ == \"__main__\": #n种物品，承重量为m，w物品的重量，v 物品的价值 n= 5 m = 17 w = [3,4,7,8,9] v = [4,5,10,11,13] res = bag(n,m,w,v) show(n,m,w,res) 部分背包问题题目要求使用贪心算法 部分背包问题与0-1背包问题的差别在于：可以带走一部分。即，部分背包问题可带走的物品 是可以 无限细分的。 贪心策略是：总是优先选择单位重量下价值最大的物品具体题目假设背包可容纳50Kg的重量，物品信息如下： 物品 i 重量(Kg) 价值 单位重量的价值 1 10 60 6 2 20 100 5 3 30 120 4 伪代码这个看起来就很简单，先装单价最高的1，剩下的地方装2，再剩下的地方装3我也不知道怎么写伪代码，直接写python吧 C代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt; #include &lt;algorithm&gt; using namespace std; //物品结构体，包含两个属性，w表示重量，v表示价值 struct Good&#123; int id; double w; double v; &#125;; //排序比较函数，以物品的价值/重量比值降序排序 bool cmp(Good a, Good b)&#123; if (a.v/a.w &gt; b.v/b.w) &#123; return true; &#125; return false; &#125; //结构体数组,所有物品信息 struct Good goods[] = &#123;&#123;1,10,12&#125;,&#123;2,9,9&#125;,&#123;3,11,7&#125;,&#123;4,12,9&#125;,&#123;5,6,8&#125;,&#123;6,3,4&#125;&#125;; //背包总重量 double totalW = 30; int main() &#123; //以物品的价值/重量比值降序排序 sort(goods,goods+6,cmp); double leftW = totalW; int totalV = 0; //遍历排好序的物品数组 for (int i=0; i&lt;6; i++) &#123; //如果当前背包所能承受的重量大于i物品的总量 //那么把i物品全部放进去 if (leftW &gt;= goods[i].w) &#123; leftW -= goods[i].w; totalV += goods[i].v; printf(\"choose good[id = %d], %.1f weight,make %.1f value\\n\",goods[i].id,goods[i].w,goods[i].v); //如果不能，那么取当前背包所能承受重量的相应数量物品 //当然价值也得按照比例来 &#125;else &#123; totalV += leftW/goods[i].w * goods[i].v; leftW = 0; printf(\"choose good[id = %d], %.1f weight,make %.1f value\\n\",goods[i].id,leftW,leftW/goods[i].w * goods[i].v); break; &#125; &#125; printf(\"max total value:%d\\n\",totalV); return 0; &#125;","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"}]},{"title":"Coursera ML(13)-SVM(Support Vector Machines)","slug":"Coursera-ML-13","date":"2017-05-22T12:25:02.000Z","updated":"2017-05-22T12:32:31.116Z","comments":true,"path":"2017/05/22/Coursera-ML-13/index.html","link":"","permalink":"http://feiyang.li/2017/05/22/Coursera-ML-13/index.html","excerpt":"本节笔记对应第七周课程和西瓜书第六章 支持向量机，主要讲解了支持向量机。","text":"本节笔记对应第七周课程和西瓜书第六章 支持向量机，主要讲解了支持向量机。 SVM介绍这一部分Coursera上的内容我并没有听懂，一头雾水。 数学上的定义逻辑回归模型从最简单的逻辑回国模型说起 $$\\begin{align*}& h_\\theta (x) = g ( \\theta^T x ) \\newline \\newline& z = \\theta^T x \\newline& g(z) = \\dfrac{1}{1 + e^{-z}}\\end{align*}$$简单点，也就是$$h_\\theta (x) = \\dfrac{1}{1 + e^{-\\theta^T x}} $$其图像为： 我们期望的的是底下那两行，而实际给我们的这个sigmoid函数，好像并没有那么完美，这是我们进行少许的处理。 将模型进行抽象原本的 $h_\\theta (x) = log \\dfrac{1}{1 + e^{-\\theta^T x}}$ 或者 $h_\\theta (x) = log(1-\\dfrac{1}{1 + e^{-\\theta^T x}})$ 的图像应该是底下的黑线。 这里，我们定义一个新的新的符号cost，就是上边那个紫色的两条直线组成的东西。为什幺这么做，食屎啦，我怎么知道为什么这么做，先留着这个问题。 改造一番之后，我们得到了 这个就是支持向量机的数学定义，去他妈的，什么鬼东西，干什么了嘛，SVM就被定义出来了。 直观化的定义给定这样一个样本集$D={X_1,y_1},{X_2,y_2},{X_3,y_3}……{X_m,y_m},y_i \\in(-1,+1)$ 我们可以找到很多条直线分割这两个区域 mark 那么我们应该努力去找到哪一个呢？直观上看，那个正中间的黑线看起来很不错。 因为该划分超平面对训练样本的局部扰动容忍度最好。 划分超平面可以定义为如下线性方程组：$$w^Tx+b=0$$其中$w=(w_1;w_2…;w_d;)$为法向量，决定平面的方向，$b$是位移量。将其标记为：$(w,b)$，样本中任一点到超平面$(w,b)$的距离可以表示为：$$r= \\dfrac{|w^T+b|}{||w||}$$ 假定成功分类，那： $$ \\left\\{ \\begin{aligned} w^T+b \\geq1, y_i=+1\\\\ w^T+b \\leq-1, y_i=-1 \\end{aligned} \\right. $$ 两个异类支持向量到超平面的距离之和(间隔)为：$$\\gamma= \\dfrac 2{||w||}$$那么如果我们可以找到最大的间隔，是不是就可以使这个分割线处于最中间的位置。 使距离最小化我们换一个表达方式 $$\\begin{aligned}\\min \\limits_{w,b} \\dfrac 12||w||^2 \\s.t. y_i(w^Tx+b) \\geq 1\\end{aligned}$$这就是支持向量机的基本型 #万能的拉格朗日－对偶问题 又有周boss的“简单”的数学推导了：这一次是和拉格朗日一起。基本SVM的优化目标本身是一个凸二次规划问题，可以利用优化计算包求解，但是据说拉格朗日有更高效的解法：对上一节最后式子使用拉格朗日乘子法就可以得到它的对偶问题 （dual problem），对偶问题出现在线性规划中，每一个求极小的线性规划问题都有一个求极大的线性规划问题互称对偶问题，解决了一个就对应解决了其对偶问题。具体到这里，对式子的每条约束添加非负拉格朗日乘子$\\alpha_i$，拉格朗日函数是 $$L(\\boldsymbol{w},b,\\boldsymbol{\\alpha})=\\frac{1}{2}\\|\\boldsymbol{w}\\|^2+\\sum_{i=1}^m{\\alpha_i(1-y_i(\\boldsymbol{w}^T\\boldsymbol{x}_i+b))}$$对其去$\\boldsymbol{w}$和$b$的偏导为0可得到对偶问题： $$max_\\boldsymbol{\\alpha}\\ \\sum_{i=1}^m\\alpha_i-\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i\\alpha_jy_iy_j\\boldsymbol{x}_i^T\\boldsymbol{x}_j$$$$s.t.\\ \\sum_{i=1}^m{\\alpha_iy_i}=0,\\ \\alpha_i\\geq0,\\ i=1,2,…,m$$这又是一个二次规划问题，但通用解法规模正比于样本数，在大规模数据上开销很大，可以考虑其它高效算法如SMO (Sequential Minimal Optimization)。SMO的简单描述是其不断重复以下两个步骤直至收敛： 选取一对需更新的变量$\\alpha_i$和$\\alpha_j$固定$\\alpha_i$和$\\alpha_j$以外的参数，求解对偶问题更新后的$\\alpha_i$和$\\alpha_j$。 SMO算法在一时间也不能得到完整的理解，希望能作为学习二次规划问题的一个复杂例子在之后研究。 核函数－核函数为什么要使用核函数原始样本空间也许并不存在一个可以正确划分两类样本的超平面，一个比较好的解决办法，试讲当前原始空间映射到一个高维空间去。根据某些大佬的研究，如果原始样本空间是有限的，那么总可以找到一个高维特性空间使样本可分。 其实这个问题在西瓜书上说的非常清楚，但是笔记却无法做，主要是相关的图我找不出来，好气哦。 详细介绍取映射函数$\\phi$，特征空间划分超平面模型表示为：$$f(x)=\\boldsymbol{w}^T\\phi(x)+b$$类似的有问题变为了： $$min_{\\boldsymbol{w},b} \\frac{1}{2}\\|\\boldsymbol{w}\\|^2$$$$s.t.\\ y_i(\\boldsymbol{w}^T\\phi(\\boldsymbol{x}_i)+b)\\geq1,\\ i=1,2,…,m$$其对偶问题是： $$max_\\boldsymbol{\\alpha}\\ \\sum_{i=1}^m\\alpha_i-\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i\\alpha_jy_iy_j\\phi(\\boldsymbol{x}_i^T)\\phi(\\boldsymbol{x}_j)$$$$s.t.\\ \\sum_{i=1}^m{\\alpha_iy_i}=0,\\ \\alpha_i\\geq0,\\ i=1,2,…,m$$ 这中间涉及了$\\phi(\\boldsymbol{x}_i^T)\\phi(\\boldsymbol{x}_j)$，是样本映射到高维空间后的内积，由于维数可能很高甚至无穷，其计算很困难。此时我们就需要找一个函数，使得：$$\\kappa(\\boldsymbol{x_i},\\boldsymbol{x_j})=\\phi(\\boldsymbol{x}_i^T)\\phi(\\boldsymbol{x}_j)$$称作核函数 (kernal function)。有定理表明：只要一个对称函数对应的核矩阵半正定，它就能作为核函数使用。几种常用的核函数有： 名称 表达式 参数 线性核 $\\kappa(\\boldsymbol{x}_i,\\boldsymbol{x}_j)=\\boldsymbol{x}_i^T\\boldsymbol{x}_j$ 多项式核 $\\kappa(\\boldsymbol{x}_i,\\boldsymbol{x}_j)=(\\boldsymbol{x}_i^T\\boldsymbol{x}_j)^d$ $d \\geq 1$为多项式的次数 高斯核 $\\kappa(\\boldsymbol{x}_i,\\boldsymbol{x}_j)=\\exp(-\\frac{∥\\boldsymbol{x}_i-\\boldsymbol{x}_j∥^2}{2\\sigma^2})$ $\\sigma \\geq 0$为高斯核的带宽 拉普拉斯核 $\\kappa(\\boldsymbol{x}_i,\\boldsymbol{x}_j)=\\exp(-\\frac{∥\\boldsymbol{x}_i-\\boldsymbol{x}_j∥}{\\sigma})$ $\\sigma \\geq 0$ Sigmoid核 $\\kappa(\\boldsymbol{x}_i,\\boldsymbol{x}_j)=\\tanh(\\beta\\boldsymbol{x}_i^T\\boldsymbol{x}_j+\\theta)$ $\\tanh$为双曲正切函数，$\\beta&gt;0,\\theta&lt;0$ 多个核函数的线性组合，两个核函数的直积均为核函数，以及若$\\kappa_1$为核函数，对于任意函数$g(\\boldsymbol{x})$有：$\\kappa(\\boldsymbol{x},\\boldsymbol{z})=g(\\boldsymbol{x})\\kappa_1(\\boldsymbol{x},\\boldsymbol{z})g(\\boldsymbol{z})$也是核函数如何选择核函数将样本映射到真正显示其分布规律的高维空间非常重要。 软间隔与正则化实际上很多问题并不能简单地归结为线性可分线性不可分，一些问题的样本空间看来是线性可分的，但总有几个样本跑到了敌对阵营，就为此强行升高维度显然得不偿失。于是引入了软间隔 (soft margin)：允许有若干个样本被线性空间划分错误。此时的优化目标变为： $$min_{\\boldsymbol{w},b}\\ \\frac{1}{2}\\|\\boldsymbol{w}\\|^2+C\\sum_{i=1}^m\\ell_{0/1}(y_i(\\boldsymbol{w}^T\\boldsymbol{x}_i+b)-1)$$其中$C$是一个常数，可以理解问允许多少个样本被分错，而$\\ell_{0/1}$是0/1损失函数，当样本被分错时，它的取值为1，否则为0。这个函数直观，简单，然而非凸，非连续，常用一些替代函数： hinge损失：$\\ell{hinge}(z)=\\max(0,1,1-z)$指数损失 (exponential loss)：$\\ell{exp}(z)=\\exp(-z)$对率损失 (logistic loss)：$\\ell_{log}(z)=\\log(1+\\exp(-z))$ 三种常见的替代损失函数对应图像为 红色为：hinge损失 蓝色为：指数损失 黑色为：对率损失这个地方跟最开始的时候提到的图像好像，只不过Andrew直接就把结果说出来了，并没有解释为什么罢了。 代入优化目标后同样可以找到它们的对偶问题进行求解。实际上此时的优化目标可以看作两部分：第一项描述划分超平面的间隔大小，第二项描述数据集上的误差。对于误差还有更一般的形式： $$min_{f}\\ \\Omega(f)+C\\sum_{i=1}^m\\ell(f(\\boldsymbol{x}_i),y_i)$$ 其中$\\Omega(f)$称为结构风险，后一项称为经验风险，$C$用于对二者进行折中。结构风险方便引入领域知识和用户意图：用户希望得到何种性质的模型，同时它也有助于削减假设空间。这个式子称为正则化 (regularization)。 回归问题－支持向量回归普通的回归问题计算损失为函数预测值与真实值的差，而使用支持向量回归 (Support Vector Regression, SVR)，我们容忍$\\epsilon$的误差，那就相当于在预测函数两端建立了一个宽为$2\\epsilon$的隔离带，在此间隔带种的样本被默认为预测正确，而在此间隔带外的样本计算它的真实值与预测函数得到值的差作为损失，就此SVR问题可形式化为： $$min_{\\boldsymbol{w},b}\\ \\frac{1}{2}\\|\\boldsymbol{w}\\|^2+C\\sum_{i=1}^m\\ell_{\\epsilon}(f(\\boldsymbol{x}_i)-y_i)$$ 其中$C&gt;0$是一个常数,$l_{0/1}$是”0/1”损失函数 $$\\begin{equation}l_{0/1}=\\left\\{\\begin{array}{ll} 1,\\,\\text{if}\\quad z","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"}]},{"title":"Django 笔记之三 Django 模板","slug":"django3","date":"2017-05-21T08:31:52.000Z","updated":"2017-05-21T08:43:14.437Z","comments":true,"path":"2017/05/21/django3/index.html","link":"","permalink":"http://feiyang.li/2017/05/21/django3/index.html","excerpt":"在前面的几节中我们都是用简单的 django.http.HttpResponse 来把内容显示到网页上，本节将讲解如何使用渲染模板的方法来显示内容。","text":"在前面的几节中我们都是用简单的 django.http.HttpResponse 来把内容显示到网页上，本节将讲解如何使用渲染模板的方法来显示内容。 模板网站模板的设计，一般的，我们做网站有一些通用的部分，比如 导航，底部，访问统计代码等等.比如nav.html, bottom.html, tongji.html 可以写一个 base.html 来包含这些通用文件（include)12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&#123;% block title %&#125;默认标题&#123;% endblock %&#125; - 自强学堂&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% include 'nav.html' %&#125; &#123;% block content %&#125;&lt;div&gt;这里是默认内容，所有继承自这个模板的，如果不覆盖就显示这里的默认内容。&lt;/div&gt;&#123;% endblock %&#125; &#123;% include 'bottom.html' %&#125; &#123;% include 'tongji.html' %&#125; &lt;/body&gt;&lt;/html&gt; 如果需要，写足够多的 block 以便继承的模板可以重写该部分，include 是包含其它文件的内容，就是把一些网页共用的部分拿出来，重复利用，改动的时候也方便一些，还可以把广告代码放在一个单独的html中，改动也方便一些，在用到的地方include进去。其它的页面继承自 base.html 就好了，继承后的模板也可以在 block 块中 include 其它的模板文件。 比如我们的首页 home.html，继承或者说扩展(extends)原来的 base.html，可以简单这样写，重写部分代码（默认值的那一部分不用改）12345678&#123;% extends &apos;base.html&apos; %&#125; &#123;% block title %&#125;欢迎光临首页&#123;% endblock %&#125; &#123;% block content %&#125;&#123;% include &apos;ad.html&apos; %&#125;这里是首页，欢迎光临&#123;% endblock %&#125; 注意：模板一般放在app下的templates中，Django会自动去这个文件夹中找。但 假如我们每个app的templates中都有一个 index.html，当我们在views.py中使用的时候，直接写一个 render(request, ‘index.html’)，Django 能不能找到当前 app 的 templates 文件夹中的 index.html 文件夹呢?（答案是不一定能，有可能找错） ##Django 模板查找机制 Django 查找模板的过程是在每个 app 的 templates 文件夹中找（而不只是当前 app 中的代码只在当前的 app 的 templates 文件夹中找）。各个 app 的 templates 形成一个文件夹列表，Django 遍历这个列表，一个个文件夹进行查找，当在某一个文件夹找到的时候就停止，所有的都遍历完了还找不到指定的模板的时候就是 Template Not Found （过程类似于Python找包）。这样设计有利当然也有弊，有利是的地方是一个app可以用另一个app的模板文件，弊是有可能会找错了。所以我们使用的时候在 templates 中建立一个 app 同名的文件夹，这样就好了。 这样，使用的时候，模板就是 “blog/index.html” 和 “mmmwhy/index.html” 这样有app作为名称的一部分，就不会混淆。 Django 模板进阶本节主要讲 Django模板中的循环，条件判断，常用的标签，过滤器的使用。 显示一个基本的字符串在网页上 views.py123def home(request): string = u\"我是一个小胖子\" return render(request, 'home.html', &#123;'string': string&#125;) 在视图中我们传递了一个字符串名称是 string 到模板 home.html，在模板中这样使用它： home.html1&#123;&#123; string &#125;&#125; 基本的 for 循环 和 List内容的显示 views.py 123def home(request): TutorialList = [\"HTML\", \"CSS\", \"jQuery\", \"Python\", \"Django\"] return render(request, 'home.html', &#123;'TutorialList': TutorialList&#125;) home.html 123&#123;% for i in TutorialList %&#125;&#123;&#123; i &#125;&#125;&#123;% endfor %&#125; #for 循环要有一个结束标记 显示字典中内容： views.py 123def home(request): info_dict = &#123;'site': u'肥羊', 'content': u'小姿势'&#125; return render(request, 'home.html', &#123;'info_dict': info_dict&#125;) home.html 1站点：&#123;&#123; info_dict.site &#125;&#125; 内容：&#123;&#123; info_dict.content &#125;&#125; 或者可以遍历字典内容：123&#123;% for key, value in info_dict.items %&#125; &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&#123;% endfor %&#125; 在模板进行 条件判断和 for 循环的详细操作： views.py 123def home(request): List = map(str, range(100))# 一个长度为100的 List return render(request, 'home.html', &#123;'List': List&#125;) home.html 123&#123;% for item in List %&#125; &#123;&#123; item &#125;&#125;&#123;% if not forloop.last %&#125;,&#123;% endif %&#125;&#123;% endfor %&#125; 模板中 获取当前网址，当前用户等 获取当前用户 12345&#123;% if request.user.is_authenticated %&#125; &#123;&#123; request.user.username &#125;&#125;，您好！&#123;% else %&#125; 请登陆，这里放登陆链接&#123;% endif %&#125; 获取当前网址 1&#123;&#123; request.path &#125;&#125; 获取当前 GET 参数： 1&#123;&#123; request.GET.urlencode &#125;&#125;","categories":[{"name":"Django","slug":"Django","permalink":"http://feiyang.li/categories/Django/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://feiyang.li/tags/教程/"},{"name":"Django","slug":"Django","permalink":"http://feiyang.li/tags/Django/"}]},{"title":"Django 笔记之二 视图与网址","slug":"django2","date":"2017-05-20T08:06:53.000Z","updated":"2017-05-21T08:37:15.595Z","comments":true,"path":"2017/05/20/django2/index.html","link":"","permalink":"http://feiyang.li/2017/05/20/django2/index.html","excerpt":"上节已经提到新建app，这节稍微深入一些","text":"上节已经提到新建app，这节稍微深入一些 新建app基本步骤1python manage.py startapp learn # learn 是一个app的名称 之后大概是这个样子，也许你们会发现我用的其实是世界上最好的python IDE~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354E:.│ db.sqlite3│ manage.py│ Python│├─.idea│ │ blog.iml│ │ misc.xml│ │ modules.xml│ │ workspace.xml│ ││ └─inspectionProfiles│ profiles_settings.xml│├─blog│ │ settings.py│ │ settings.pyc│ │ urls.py│ │ urls.pyc│ │ wsgi.py│ │ wsgi.pyc│ │ __init__.py│ │ __init__.pyc│ ││ └─__pycache__│ settings.cpython-35.pyc│ urls.cpython-35.pyc│ wsgi.cpython-35.pyc│ __init__.cpython-35.pyc│└─my_blog │ admin.py │ admin.pyc │ apps.py │ models.py │ models.pyc │ tests.py │ views.py │ views.pyc │ __init__.py │ __init__.pyc │ ├─migrations │ │ __init__.py │ │ __init__.pyc │ │ │ └─__pycache__ │ __init__.cpython-35.pyc │ └─__pycache__ admin.cpython-35.pyc models.cpython-35.pyc views.cpython-35.pyc __init__.cpython-35.pyc 声明my_blog我们需要在settings.py中去声明一下my_blog 123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'my_blog',] 新建的 app 如果不加到 INSTALL_APPS 中的话, django 就不能自动找到app中的模板文件(app-name/templates/下的文件)和静态文件(app-name/static/中的文件) 。 定义视图内容将views.py修改为我们希望展示的内容：1234#coding: utf-8from django.http import HttpResponsedef index(request): return HttpResponse(u'你好哇，李肥羊，希望你可以瘦下来！') 使用python manage.py runserver，启动django服务 第一行是声明编码为utf-8, 因为我们在代码中用到了中文,如果不声明就报错. 第二行引入HttpResponse，它是用来向网页返回内容的，就像Python中的 print 一样，只不过 HttpResponse 是把内容显示到网页上。 我们定义了一个index()函数，第一个参数必须是 request，与网页发来的请求有关，request 变量里面包含get或post的内容，用户浏览器，系统等信息在里面（后面会讲，先了解一下就可以）。 函数返回了一个 HttpResponse 对象，可以经过一些处理，最终显示几个字到网页上。 如果你前端技术非常好的话，可以直接把整个页面return回去。。。 那问题来了，我们访问什么网址才能看到刚才写的这个函数呢？怎么让网址和函数关联起来呢？ 定义视图函数相关的URL(网址)即规定 访问什么网址对应什么内容，我们打开 urls.py 这个文件, 修改其中的代码:1234567from django.conf.urls import urlfrom django.contrib import adminfrom my_blog import views as my_blog_viewurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$', my_blog_view.index),] 先从my_blog导入views进入urls.py，然后用正则表达式，设定对应规则。如果忘了正则表达式怎么使用，也许这个网页会对你有帮助. 通过链接做加减法跟之前的步骤一样，先修改view.py文件 修改view.py1234567891011121314def add(request): a = request.GET[&apos;a&apos;] b = request.GET[&apos;b&apos;] c = int(a)+int(b) return HttpResponse(str(c))def sub(request): a = request.GET[&apos;a&apos;] b = request.GET[&apos;b&apos;] c = int(a)-int(b) return HttpResponse(str(c))def add2(request, a, b): c = int(a) + int(b) return HttpResponse(str(c)) 修改urls.py123url(r&apos;^add/$&apos;, my_blog_view.add, name=&apos;add&apos;), # 注意修改了这一行url(r&apos;^sub/$&apos;, my_blog_view.add, name=&apos;sub&apos;), # 注意修改了这一行url(r&apos;^add/(\\d+)/(\\d+)/$&apos;, my_blog_view.add2, name=&apos;add2&apos;), 运行检查输入http://127.0.0.1:8000/add/?a=4&amp;b=5或者http://127.0.0.1:8000/add/?a=4&amp;b=5 就可以获得答案 URL name返回整个页面urls.py1url(r&apos;^add/$&apos;, calc_views.add, name=&apos;add&apos;) 这里的 name=’add’ 是用来干什么的呢，简单说，name 可以用于在 templates, models, views ……中得到对应的网址，相当于“给网址取了个名字”，只要这个名字不变，网址变了也能通过名字获取到。 views.py123456from django.http import HttpResponsefrom django.shortcuts import render def index(request): return render(request, &apos;home.html&apos;) templates我们在 my_blog 这个 app 中新建一个 templates 文件夹，在templates中新建一个 home.html文件 my_blog/templates/home.html 中写入以下内容（保存时用 utf8 编码）12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;今天是个好天气&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;/add/4/5/&quot;&gt;计算 4+5&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 运行结果运行开发服务器，我们访问 http://127.0.0.1:8000/ 可以看到 点击计算4+5，可以看到答案。 如何用 Python 代码获取对应的网址···计算 4+5···如果这样写“死网址”，之后上线后，如果想要改变链接结构，将会很麻烦。如果有些地方没有修改过来，就不能使用了、使用python manage.py shell，进入django shell调试页面.1234567&gt;&gt;&gt; from django.core.urlresolvers import reverse # django 1.4.x - django 1.10.x&gt;&gt;&gt; from django.urls import reverse # django 1.10.x 新的，更加规范了 &gt;&gt;&gt; reverse('add2', args=(4,5))u'/add/4/5/'&gt;&gt;&gt; reverse('add2', args=(444,555))u'/add/444/555/' reverse 接收 url 中的 name 作为第一个参数，我们在代码中就可以通过 reverse() 来获取对应的网址。也就是输入name返回对应网址。 例如：1&lt;a href=&quot;&#123;% url &apos;add2&apos; 4 5 %&#125;&quot;&gt; 计算 4+5&lt;/a&gt; 上面的代码渲染成最终的页面是 1&lt;a href=&quot;/add/4/5/&quot;&gt;计算 4+5&lt;/a&gt; |这样就可以通过 {% url 'add2' 4 5 %} 获取到对应的网址 /add/4/5/ |这样，即使我们在urls.py中修改了网址链接，1url(r&apos;^new_add/(\\d+)/(\\d+)/$&apos;, my_blog_view.add2, name=&apos;add2&apos;), 注意看重点 add 变成了 new_add，但是后面的 name=’add2’ 没改，这时 |`{% url 'add2' 4 5 %}` | 就会渲染对应的网址成/new_add/4/5/ 用在 views.py 或 models.py 等地方的 reverse函数，同样会根据 name 对应的url获取到新的网址。 想要改网址的时候，修改 urls.py 中的正则表达式部分（url 参数第一部分），name 不变的前提下，其它地方都不需要修改。 链接跳转views.py 写一个跳转的函数1234567from django.http import HttpResponseRedirectfrom django.urls import reverse # new in django 1.10.x def old_add2_redirect(request, a, b): return HttpResponseRedirect( reverse(&apos;add2&apos;, args=(a, b)) ) urls.py12url(r&apos;^add/(\\d+)/(\\d+)/$&apos;, my_blog_view.old_add2_redirect),url(r&apos;^new_add/(\\d+)/(\\d+)/$&apos;, my_blog_view.add2, name=&apos;add2&apos;), 即可完成跳转","categories":[{"name":"Django","slug":"Django","permalink":"http://feiyang.li/categories/Django/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://feiyang.li/tags/教程/"},{"name":"Django","slug":"Django","permalink":"http://feiyang.li/tags/Django/"}]},{"title":"Django 笔记之一 基本命令","slug":"django1","date":"2017-05-20T01:20:41.000Z","updated":"2017-05-21T08:32:12.067Z","comments":true,"path":"2017/05/20/django1/index.html","link":"","permalink":"http://feiyang.li/2017/05/20/django1/index.html","excerpt":"本节主要是为了让您了解一些django最基本的命令，请尝试着记住它们，并且多多练习下，打开 Linux 或 MacOS 的 Terminal （终端）直接在 终端中输入这些命令（不是 python 的 shell中）","text":"本节主要是为了让您了解一些django最基本的命令，请尝试着记住它们，并且多多练习下，打开 Linux 或 MacOS 的 Terminal （终端）直接在 终端中输入这些命令（不是 python 的 shell中） 如果是 windows 用 cmd（开始 搜索 cmd 或者 快捷键 win + R，输入 cmd) 直接在 cmd 上操作。 新建一个 django project1django-admin startproject blog 特别是在 windows 上，如果报错，尝试用 django-admin 代替 django-admin.py 试试注意 project_name 是自己的项目名称，需要为合法的 Python 包名，如不能为 1a 或 a-b。 新建 app要先进入项目目录下，cd project_name 然后执行下面的命令（下同，已经在项目目录下则不需要 cd project_name）1python manage.py startapp my_blog 或1django-admin startapp my_blog 效果太概是这个样子的123456789101112131415161718.├── my_blog│ ├── admin.py│ ├── __init__.py│ ├── migrations│ │ └── __init__.py│ ├── models.py│ ├── tests.py│ └── views.py├── blog│ ├── __init__.py│ ├── __pycache__│ │ ├── __init__.cpython-34.pyc│ │ └── settings.cpython-34.pyc│ ├── settings.py│ ├── urls.py│ └── wsgi.py└── manage.py 一般一个项目有多个app, 当然通用的app也可以在多个项目中使用。 与项目名类似 app name 也需要为合法的 Python 包名，如 blog，news, aboutus 等都是合法的 app 名称。 同步更改数据库表或字段12345Django 1.7.1及以上 用以下命令# 1. 创建更改的文件python manage.py makemigrations# 2. 将生成的py文件应用到数据库python manage.py migrate 这种方法可以在SQL等数据库中创建与models.py代码对应的表，不需要自己手动执行SQL。 备注：对已有的 models 进行修改，Django 1.7之前的版本的Django都是无法自动更改表结构的，不过有第三方工具 south,详见 Django 数据库迁移 一节。 使用开发服务器开发服务器，即开发时使用，一般修改代码后会自动重启，方便调试和开发，但是由于性能问题，建议只用来测试，不要用在生产环境。 1234567891011python manage.py runserver # 当提示端口被占用的时候，可以用其它端口：python manage.py runserver 8001python manage.py runserver 9999（当然也可以kill掉占用端口的进程，具体后面有讲，此处想知道的同学可查下 lsof 命令用法） # 监听机器所有可用 ip （电脑可能有多个内网ip或多个外网ip）python manage.py runserver 0.0.0.0:8000# 如果是外网或者局域网电脑上可以用其它电脑查看开发服务器# 访问对应的 ip加端口，比如 http://172.16.20.2:8000 清空数据库1python manage.py flush 此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。 创建超级管理员12345python manage.py createsuperuser# 按照提示输入用户名和对应的密码就好了邮箱可以留空，用户名和密码必填 # 修改 用户密码可以用：python manage.py changepassword username 导出数据 导入数据12python manage.py dumpdata appname &gt; appname.jsonpython manage.py loaddata appname.json 关于数据操作 详见：数据导入数据迁移，现在了解有这个用法就可以了。 Django 项目环境终端12python manage.py shell如果你安装了 bpython 或 ipython 会自动用它们的界面，推荐安装 bpython。 这个命令和 直接运行 python 或 bpython 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据，还有一些小测试非常方便。 数据库命令行1python manage.py dbshell Django 会自动进入在settings.py中设置的数据库，如果是 MySQL 或 postgreSQL,会要求输入数据库用户密码。 在这个终端可以执行数据库的SQL语句。如果您对SQL比较熟悉，可能喜欢这种方式。 更多命令终端上输入 python manage.py 可以看到详细的列表，在忘记子名称的时候特别有用。","categories":[{"name":"Django","slug":"Django","permalink":"http://feiyang.li/categories/Django/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://feiyang.li/tags/教程/"},{"name":"Django","slug":"Django","permalink":"http://feiyang.li/tags/Django/"}]},{"title":"Coursera ML(12)-Machine Learning System Design","slug":"Coursera-ML-12-Machine-Learning-System-Design","date":"2017-05-19T10:53:03.000Z","updated":"2017-05-22T06:24:40.702Z","comments":true,"path":"2017/05/19/Coursera-ML-12-Machine-Learning-System-Design/index.html","link":"","permalink":"http://feiyang.li/2017/05/19/Coursera-ML-12-Machine-Learning-System-Design/index.html","excerpt":"机器学习系统设计","text":"机器学习系统设计 查准率(Precision)和查全率(Recall) 分为四种情况： 正确肯定（True PositiveTP）：预测为真，实际为真。 正确否定（True Negative TN）：预测为假，实际为假。 错误肯定（False PositiveFP）：预测为真，实际为假。 错误否定（False NegativeFN）：预测为假，实际为真。查准率$$Precison=\\dfrac{TP}{TP+FP}$$在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人百分比，越高越好。查全率$$Recall=\\dfrac{TP}{TP+FN}$$在所有我们实际上有病的病人中，预测成功有恶性肿瘤的病人百分比，越高越好。 F1值$$F_1=\\dfrac{PR}{P+R}$$","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"}]},{"title":"coursera","slug":"coursera","date":"2017-05-18T02:14:53.000Z","updated":"2017-05-18T02:17:37.001Z","comments":true,"path":"2017/05/18/coursera/index.html","link":"","permalink":"http://feiyang.li/2017/05/18/coursera/index.html","excerpt":"关于coursera无法播放，原因其实很简单，就是视频所在服务器被GFW墙了。","text":"关于coursera无法播放，原因其实很简单，就是视频所在服务器被GFW墙了。 有的时候，我真的会觉得，墙是不是太密了，使得我们不得不选择越过它。 常见的方法是，我们使用一个在墙外的服务器，他可以帮助我们将coursera的流量通过服务器重新转发，然后再原路返回，避过GFW。 mark 因此，首先要获得服务器端口以及相应的密码，这样服务器才可以帮你转发流量。我自己因为也在coursera看视频，所以自己搭建了一个服务器，分享给大家。https://ss.feiyang.li/ 这里我分别举例展示如何快速观看coursera视频。 – Windowssshttp://home.ustc.edu.cn/~mmmwhy/Shadowsocks.exe 在任务栏找到 Shadowsocks 图标 在 服务器 -&gt; 编辑服务器-&gt; 输入在网站内获得的服务器信息 选择 启用系统代理 来启用系统代理。请禁用浏览器里的代理插件，或把它们设置为使用系统代理。 ssrhttp://home.ustc.edu.cn/~mmmwhy/ShadowsocksR-dotnet4.0.exe右键 纸飞机 -&gt; 扫描二维码 -&gt; 开启系统代理选择 -&gt;pac模式或者全局模式 当然直接使用二维码扫描会更方便，如果遇到某个节点不能使用，可以换一个，因为本地运营商可能会把某些ip墙掉。 Mac OS Xhttps://github.com/shadowsocks/ShadowsocksX-NG/releasesOS X 下设置使用方法Mac 下使用极其方便，因为 GUI 已经集成了系统 Pac，所以无需设置任何科学上网的姿势，直接运行 ShadowsocksX ，然后输入服务商提供给你的账号信息，保存运行后，即可在所有浏览器里直接科学上网，如图： Linuxhttps://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation Androidssr 扫描二维码-&gt; 然后点小飞机就可以了 iOSSsrConnect - Proxy Utility 免费Network Proxy Utility 免费Shadowrocket 付费土豆丝 付费","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://feiyang.li/categories/shadowsocks/"}],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"}]},{"title":"Coursera ML(11)-Programming Exercise 5 机器学习诊断法","slug":"Coursera-ML-11-Programming-Exercise-5","date":"2017-05-17T05:37:09.000Z","updated":"2017-05-17T06:22:10.492Z","comments":true,"path":"2017/05/17/Coursera-ML-11-Programming-Exercise-5/index.html","link":"","permalink":"http://feiyang.li/2017/05/17/Coursera-ML-11-Programming-Exercise-5/index.html","excerpt":"对应 机器学习诊断法","text":"对应 机器学习诊断法 复习内容Regularized linear regression cost function 对应matlab代码：123J = 1/(2*m)*sum((X*theta - y).^2) ;regularize = lambda /(2*m)* (sum(theta.^2)-theta(1).^2);J = J + regularize; Regularized linear regression gradient 如果对这里有疑惑，这个部分也有相应的推导过程： 梯度对应代码：12345n = size(theta);for i=1:n grad(i) = 1/m * sum((X*theta - y).*X(:,i)) + lambda/m *theta(i);endgrad(1) = 1/m * sum((X*theta - y).^X(:,1)); Learning curves Polynomial regression Programming Exercise 5 - Regularized Linear Regression and Bias v.s. Variance1234567891011121314151617181920212223# %load ../../../standard_import.txtimport pandas as pdimport numpy as npimport matplotlib as mplimport matplotlib.pyplot as pltfrom scipy.io import loadmatfrom scipy.optimize import minimizefrom sklearn.linear_model import LinearRegression, Ridgefrom sklearn.preprocessing import PolynomialFeaturespd.set_option('display.notebook_repr_html', False)pd.set_option('display.max_columns', None)pd.set_option('display.max_rows', 150)pd.set_option('display.max_seq_items', None) #%config InlineBackend.figure_formats = &#123;'pdf',&#125;%matplotlib inlineimport seaborn as snssns.set_context('notebook')sns.set_style('white') 12data = loadmat('data/ex5data1.mat')data.keys() dict_keys([&apos;__header__&apos;, &apos;__version__&apos;, &apos;__globals__&apos;, &apos;X&apos;, &apos;y&apos;, &apos;Xtest&apos;, &apos;ytest&apos;, &apos;Xval&apos;, &apos;yval&apos;]) 1234567891011y_train = data['y']X_train = np.c_[np.ones_like(data['X']), data['X']]yval = data['yval']Xval = np.c_[np.ones_like(data['Xval']), data['Xval']]print('X_train:', X_train.shape)print('y_train:', y_train.shape)print('Xval:', Xval.shape)print('yval:', yval.shape) X_train: (12, 2) y_train: (12, 1) Xval: (21, 2) yval: (21, 1) Regularized Linear Regression1234plt.scatter(X_train[:,1], y_train, s=50, c='r', marker='x', linewidths=1)plt.xlabel('Change in water level (x)')plt.ylabel('Water flowing out of the dam (y)')plt.ylim(ymin=0); ###Regularized Cost function 12345678def linearRegCostFunction(theta, X, y, reg): m = y.size h = X.dot(theta) J = (1/(2*m))*np.sum(np.square(h-y)) + (reg/(2*m))*np.sum(np.square(theta[1:])) return(J) Gradient12345678def lrgradientReg(theta, X, y, reg): m = y.size h = X.dot(theta.reshape(-1,1)) grad = (1/m)*(X.T.dot(h-y))+ (reg/m)*np.r_[[[0]],theta[1:].reshape(-1,1)] return(grad.flatten()) 12345initial_theta = np.ones((X_train.shape[1],1))cost = linearRegCostFunction(initial_theta, X_train, y_train, 0)gradient = lrgradientReg(initial_theta, X_train, y_train, 0)print(cost)print(gradient) 303.951525554 [ -15.30301567 598.16741084] 12345678910def trainLinearReg(X, y, reg): #initial_theta = np.zeros((X.shape[1],1)) initial_theta = np.array([[15],[15]]) # For some reason the minimize() function does not converge when using # zeros as initial theta. res = minimize(linearRegCostFunction, initial_theta, args=(X,y,reg), method=None, jac=lrgradientReg, options=&#123;'maxiter':5000&#125;) return(res) 12fit = trainLinearReg(X_train, y_train, 0)fit fun: 1604.4002999186634 hess_inv: array([[ 1.03142187, 0.00617881], [ 0.00617881, 0.001215 ]]) jac: array([ 3.42437190e-12, -5.70371898e-10]) message: &apos;Optimization terminated successfully.&apos; nfev: 6 nit: 4 njev: 6 status: 0 success: True x: array([ 13.08790351, 0.36777923]) Comparison: coefficients and cost obtained with LinearRegression in Scikit-learn1234regr = LinearRegression(fit_intercept=False)regr.fit(X_train, y_train.ravel())print(regr.coef_)print(linearRegCostFunction(regr.coef_, X_train, y_train, 0)) [ 13.08790351 0.36777923] 1604.40029992 12345678plt.plot(np.linspace(-50,40), (fit.x[0]+ (fit.x[1]*np.linspace(-50,40))), label='Scipy optimize')#plt.plot(np.linspace(-50,40), (regr.coef_[0]+ (regr.coef_[1]*np.linspace(-50,40))), label='Scikit-learn')plt.scatter(X_train[:,1], y_train, s=50, c='r', marker='x', linewidths=1)plt.xlabel('Change in water level (x)')plt.ylabel('Water flowing out of the dam (y)')plt.ylim(ymin=-5)plt.xlim(xmin=-50)plt.legend(loc=4); 123456789101112def learningCurve(X, y, Xval, yval, reg): m = y.size error_train = np.zeros((m, 1)) error_val = np.zeros((m, 1)) for i in np.arange(m): res = trainLinearReg(X[:i+1], y[:i+1], reg) error_train[i] = linearRegCostFunction(res.x, X[:i+1], y[:i+1], reg) error_val[i] = linearRegCostFunction(res.x, Xval, yval, reg) return(error_train, error_val) 1t_error, v_error = learningCurve(X_train, y_train, Xval, yval, 0) 123456plt.plot(np.arange(1,13), t_error, label='Training error')plt.plot(np.arange(1,13), v_error, label='Validation error')plt.title('Learning curve for linear regression')plt.xlabel('Number of training examples')plt.ylabel('Error')plt.legend(); Polynomial regression (Scikit-learn)12345678910111213141516171819202122poly = PolynomialFeatures(degree=8)X_train_poly = poly.fit_transform(X_train[:,1].reshape(-1,1))regr2 = LinearRegression()regr2.fit(X_train_poly, y_train)regr3 = Ridge(alpha=20)regr3.fit(X_train_poly, y_train)# plot range for xplot_x = np.linspace(-60,45)# using coefficients to calculate yplot_y = regr2.intercept_+ np.sum(regr2.coef_*poly.fit_transform(plot_x.reshape(-1,1)), axis=1)plot_y2 = regr3.intercept_ + np.sum(regr3.coef_*poly.fit_transform(plot_x.reshape(-1,1)), axis=1)plt.plot(plot_x, plot_y, label='Scikit-learn LinearRegression')plt.plot(plot_x, plot_y2, label='Scikit-learn Ridge (alpha=&#123;&#125;)'.format(regr3.alpha))plt.scatter(X_train[:,1], y_train, s=50, c='r', marker='x', linewidths=1)plt.xlabel('Change in water level (x)')plt.ylabel('Water flowing out of the dam (y)')plt.title('Polynomial regression degree 8')plt.legend(loc=4);","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"数据库操作","slug":"databases","date":"2017-05-16T10:38:00.000Z","updated":"2017-05-16T10:38:57.468Z","comments":true,"path":"2017/05/16/databases/index.html","link":"","permalink":"http://feiyang.li/2017/05/16/databases/index.html","excerpt":"其实之前学过数据库相关操作，只不过许久不用就忘了。真是年纪大了呀。","text":"其实之前学过数据库相关操作，只不过许久不用就忘了。真是年纪大了呀。 创建数据库：create database books; 使用数据库：use dbname; 新建数据库表12345678create table tablename(columns);create table demo( userid int unsigned not null auto_increment primary key, username char(50) not null, password char(20) not null, age int not null, city char(20) not null ); 显示数据库表：show tables; 在数据库中插入数据 12INSERT INTO `jobcategory` VALUES(11,&quot;丸剂&quot;);INSERT INTO wan (JobCategoryID,JobCategoryName) SELECT ID,MingCheng FROM `zysjyj` WHERE MingCheng LIKE &quot;%丸&quot;; 查询数据 1SELECT ID,MingCheng FROM `zysjyj` WHERE MingCheng LIKE &quot;%丸&quot;; 更新数据： 1UPDATE `zysjyj` SET ID=(1100000+ID) WHERE MingCheng LIKE &apos;%丸&apos;; 删除数据： 1DELETE FROM `nzysys`.`jobintroduction`; 表的删除：1DROP TABLE table; 数据删除： 1DROP DATABASE database;` 通过SELECT来INSERT：先创建新表，然后插入 123CREATE TABLE wan(JobCategoryID INT(20) NOT NULL AUTO_INCREMENT,PRIMARY KEY (JobCategoryID),parentID INT(20) NOT NULL DEFAULT &apos;10&apos; ,JobCategoryName VARCHAR(128) NOT NULL); INSERT INTO wan (JobCategoryID,JobCategoryName) SELECT ID,MingCheng FROM `zysjyj` WHERE MingCheng LIKE &quot;%丸&quot;; 跨数据库插入 1INSERT `nzysys`.`subjobcategory` SELECT * FROM `chinese-drug`.`wan`; 用select来create，并指定默认值 1INSERT INTO `nzysys`.`subjobcategory`(JobCategoryID,parentID,JobCategoryName)SELECT ID,10,MingCheng FROM `chinese-drug`.`zysjyj` WHERE MingCheng LIKE &quot;%散&quot;; 叠加使用 123SELECT ID,MingCheng FROM `chinese-drug`.`zysjyj` WHERE MingCheng LIKE &quot;%散&quot;;UPDATE `chinese-drug`.`zysjyj` SET ID=(1000000+ID) WHERE MingCheng LIKE &quot;%散&quot;;INSERT INTO `nzysys`.`subjobcategory`(JobCategoryID,parentID,JobCategoryName)SELECT ID,10,MingCheng FROM `chinese-drug`.`zysjyj` WHERE MingCheng LIKE &quot;%散&quot;; 自增ID归零 1TRUNCATE TABLE `nzysys`.`jobintroduction`; 交叉 1INSERT INTO `nzysys`.`jobintroduction` (jobCategoryID,introductionValue,introductionkey,introductionID) SELECT b.jobCategoryID,a.ChuFang,&apos;组成&apos;,1 FROM `nzysys`.`subjobcategory` AS b,`chinese-drug`.`zysjyj` AS a WHERE a.`ID`=b.`JobCategoryID`;","categories":[],"tags":[{"name":"databases","slug":"databases","permalink":"http://feiyang.li/tags/databases/"}]},{"title":"免费vps get!","slug":"free-vps","date":"2017-05-15T12:13:05.000Z","updated":"2017-05-15T12:13:29.549Z","comments":true,"path":"2017/05/15/free-vps/index.html","link":"","permalink":"http://feiyang.li/2017/05/15/free-vps/index.html","excerpt":"早就听说WisHosting 长期免费vps，码农买vps就像女人买衣服一样，虽然没什么用，但是会上瘾。","text":"早就听说WisHosting 长期免费vps，码农买vps就像女人买衣服一样，虽然没什么用，但是会上瘾。 要求官网链接 How to get OpenVZ Mini for free?If you want to grab free VPS (OpenVZ Mini package) free of charge, here is the list of requirements you should meet:1) The domain from non-free domain zone (for example .com)2) The link to https://www.wishosting.com/ on your domain index page.3) Your website should have some real content (5+ pages) and it should be indexed by search engines.4) The service will be active as long as you keep the backlink on your website. Please open a support ticket if you meet those requirements or send an e-mail to support@wishosting.com 动手 注册并下单，不需要支付 发工单询问商家，按照沟通步骤来即可 表示已经申请到了，所以，应该不是很难申请的，有兴趣可以去玩一下。","categories":[],"tags":[{"name":"vps","slug":"vps","permalink":"http://feiyang.li/tags/vps/"},{"name":"free","slug":"free","permalink":"http://feiyang.li/tags/free/"}]},{"title":"shadowsocks-manager一键安装脚本","slug":"ss-mgr","date":"2017-05-14T03:58:57.000Z","updated":"2017-05-20T01:23:52.118Z","comments":true,"path":"2017/05/14/ss-mgr/index.html","link":"","permalink":"http://feiyang.li/2017/05/14/ss-mgr/index.html","excerpt":"shadowsocks-manager是一个非常帅气的ss多用户管理程序，搭建起来稍微有点麻烦，因此写了本一键脚本。示例网站：http://gz.feiyang.li/","text":"shadowsocks-manager是一个非常帅气的ss多用户管理程序，搭建起来稍微有点麻烦，因此写了本一键脚本。示例网站：http://gz.feiyang.li/ 我看了一下数据，大概70%的人会一次性安装成功，其余人大多卡在npm依赖安装不全的问题上；请注意：1、内存1g以下的vps，极有可能内存过小，导致依赖被kill掉。2、网络问题，请多次安装npm。如果实在解决不了，建议就不要用这个管理界面，这个管理界面的要求的确有点高，请理解。 效果 github： https://github.com/mmmwhy/ss-mgr 特点 非常帅气，各种图表一上，是不是很牛逼的感觉。 支持支付宝付款对账，站长们多出来的vps可以不用再继续吃灰了。 要求centos7 X64，在腾讯云，digitialocean,interserver,ethernetservers通过测试。其他版本还没有测试，理论上可用。 安装脚本安装ss-mgr本脚本包括主控端和节点端，安装时，自动添加本vps作为一个节点。1wget -N --no-check-certificate https://raw.githubusercontent.com/mmmwhy/ss-mgr/master/sm.sh &amp;&amp; chmod +x sm.sh &amp;&amp; bash sm.sh 坐等就可以了，没有什么需要做的东西。打开ip地址，就可以看到ss-mgr了。 增加节点本脚本为：已有vps安装好主控端，添加新节点时，在新节点使用的脚本。1wget -N --no-check-certificate https://raw.githubusercontent.com/mmmwhy/ss-mgr/master/sm_node.sh &amp;&amp; chmod +x sm_node.sh &amp;&amp; bash sm_node.sh 输入密码 前端页面填入，刚才的密码，选择加密方式。 docker方法备注 注册的第一个用户就是管理员. 注册第二个账号，可以看到自己的剩余时间，一般来说是8个小时。可以点击续费，选择任意一个额度，支付后，可以看到时间会增长。 默认使用hotmail邮箱，因为邮箱在国外，所以如果服务器在国内的话，可能会timeout。 某些系统内核版本过老，因此可能会出现如下症状，按回车就可以了。 被墙掉的资源都换成国内的了。 三条重要命令1234screen -dmS ss-manager ss-manager -m aes-256-cfb -u --manager-address 127.0.0.1:4000cd /root/shadowsocks-manager/screen -dmS ss node server.js -c /root/.ssmgr/ss.ymlscreen -dmS webgui node server.js -c /root/.ssmgr/webgui.yml 修改页面修改过文本后，使用npm run build重新生成页面。1screen -dmS webgui node server.js -c /root/.ssmgr/webgui.yml 一键BBR脚本123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 增加虚拟内存增加swap交换文件 使用dd命令创建一个swap交换文件dd if=/dev/zero of=/home/swap bs=1024 count=1024000这样就建立一个/home/swap的分区文件，大小为1G。 制作为swap格式文件：mkswap /home/swap 再用swapon命令把这个文件分区挂载swap分区/sbin/swapon /home/swap我们用free -m命令看一下，发现已经有交换分区了。但是重启系统后，swap分区又变成0了。 为防止重启后swap分区变成0，要修改/etc/fstab文件1vi /etc/fstab 在文件末尾（最后一行）加上/home/swap swap swap default 0 0这样就算重启系统，swap分区还是有值。 查看空间：1free -m 因为本工具较难配置，因此如果有问题的话，可以通过tg联系我。https://t.me/mmmwhy 参考以下链接：http://blog.csdn.net/lengyue1084/article/details/51405640https://code.momok.xyz/server/deploy-ss-manager.htmlhttps://github.com/shadowsocks/shadowsocks-manager","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://feiyang.li/categories/shadowsocks/"}],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"},{"name":"教程","slug":"教程","permalink":"http://feiyang.li/tags/教程/"},{"name":"vps","slug":"vps","permalink":"http://feiyang.li/tags/vps/"},{"name":"shell","slug":"shell","permalink":"http://feiyang.li/tags/shell/"}]},{"title":"Coursera ML(10)-机器学习诊断法","slug":"Coursera-ML-10-Evaluating-a-Hypothesis","date":"2017-05-11T04:28:16.000Z","updated":"2017-05-11T04:34:51.020Z","comments":true,"path":"2017/05/11/Coursera-ML-10-Evaluating-a-Hypothesis/index.html","link":"","permalink":"http://feiyang.li/2017/05/11/Coursera-ML-10-Evaluating-a-Hypothesis/index.html","excerpt":"假设你在开发一个机器学习系统，或者在改进一个机器学习系统的性能，应如何做？","text":"假设你在开发一个机器学习系统，或者在改进一个机器学习系统的性能，应如何做？ 目前已有的方法： Getting more training examples Trying smaller sets of features Trying additional features Trying polynomial features Increasing or decreasing λ 每种方法都有自己不同的应用场景 Evaluating a Hypothesis根据测试集得到参数，对训练集运用模型。有两种误差计算方法 For linear regression: $$J_{test}(\\Theta) = \\dfrac{1}{2m_{test}} \\sum_{i=1}^{m_{test}}(h_\\Theta(x^{(i)}_{test}) - y^{(i)}_{test})^2$$ For classification :误分类的比例，对于每一个测试实例，计算： $$err(h_\\Theta(x),y) = \\begin{matrix} 1 & \\mbox{if } h_\\Theta(x) \\geq 0.5\\ and\\ y = 0\\ or\\ h_\\Theta(x) < 0.5\\ and\\ y = 1\\newline 0 & \\mbox otherwise \\end{matrix}$$ 然后急死俺平均 $$\\text{Test Error} = \\dfrac{1}{m_{test}} \\sum^{m_{test}}_{i=1} err(h_\\Theta(x^{(i)}_{test}), y^{(i)}_{test})$$ Model Selection and Train/Validation/Test Sets(交叉验证机)使用60%的数据作为训练集，20%的数据作为交叉验证集，20%的数据作为测试集 Optimize the parameters in Θ using the training set for each polynomial degree. Find the polynomial degree d with the least error using the cross validation set. Estimate the generalization error using the test set with $J_{test}(\\Theta^{(d)})$, (d = theta from polynomial with lower error);简单来讲：训练集训练出 10 个模型 -&gt;10 个模型分别对交叉验证集计算得出交叉验证误差（代价函数的值）-&gt;选取代价函数值最小的模型-&gt;用选出的模型对测试集计算得出推广误差（代价函数的值） Diagnosing Bias vs. Variance high biais and high variance High bias (underfitting): both $J_{train}(\\Theta)$ and $J_{CV}(\\Theta)$ will be high. Also, $J_{CV}(\\Theta) \\approx J_{train}(\\Theta)$. High variance (overfitting): $J_{train}(\\Theta)$ will be low and $J_{CV}(\\Theta)$ will be much greater than $J_{train}(\\Theta)$. 很多情况下，欠拟合会导致高误差，高方差意味着拟合过度。 Decide Bias or Variance 训练集误差和交叉验证集误差近似时：偏差/欠拟合 交叉训练集误差 &gt;&gt; 训练集误差时：方法/过拟合 Regularization and Bias/Variance mark Create a list of lambdas (i.e. λ∈{0,0.01,0.02,0.04,0.08,0.16,0.32,0.64,1.28,2.56,5.12,10.24}); Create a set of models with different degrees or any other variants. Iterate through the $\\lambda$s and for each $\\lambda$ go through all the models to learn some $\\Theta$. Compute the cross validation error using the learned Θ (computed with λ) on the $J_{CV}(\\Theta)$ without regularization or λ = 0. Select the best combo that produces the lowest error on the cross validation set. Using the best combo Θ and λ, apply it on $J_{test}(\\Theta)$ to see if it has a good generalization of the problem.简单说：训练12个不同归一化的模型-&gt;分别对应交叉验证集计算误差-&gt;选出最小的那个-&gt;使用在测试集上Regularization 相关结论 当$\\lambda$较小时，训练集误差较小（过拟合）而交叉验证集误差较大。 随着$\\lambda$增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增大。 Learning Curves 学习曲线是一个很好的工具，我们会经常使用学习曲线来判断某一个学习算法是否处于偏差、方差问题。 学习曲线试讲训练集误差和交叉验证集误差作为训练集实例数量（m）的函数绘制的图表。 Experiencing high bias: **Low training set size**: causes $J_{train}(\\Theta)$ to be low and $J_{CV}(\\Theta)$ to be high. **Large training set size**: causes both $J_{train}(\\Theta)$ and $J_{CV}(\\Theta)$ to be high with $J_{train}(\\Theta)$≈$J_{CV}(\\Theta)$ 因此在高偏差（欠拟合）的情况下，增加训练集数量并不是一个好办法。此时，我们应当增加features。Experiencing high variance: **Low training set size**: $J_{train}(\\Theta)$ will be low and $J_{CV}(\\Theta)$ will be high. **Large training set size**: $J_{train}(\\Theta)$ increases with training set size and $J_{CV}(\\Theta)$ continues to decrease without leveling off. Also, $J_{train}(\\Theta)$ &lt; $J_{CV}(\\Theta)$ but the difference between them remains significant. 对比之下，如果在高方差（过拟合）的情况下，增加训练集数量可以明显降低误差，提高算法效果。 决定下一步做什么 获得更多的训练实例——解决高方差 high biais and high variance 尝试减少特征的数量——解决高方差 尝试获得更多的特征——解决高偏差 尝试增加多项式特征——解决高偏差 尝试减少归一化程度 λ—&gt;提高拟合准确度—&gt;解决高偏差 尝试增加归一化程度 λ—&gt;防止过拟合—&gt;解决高方差","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"}]},{"title":"Coursera ML(9)-Programming Exercise 4","slug":"Coursera-ML-9-Programming-Exercise-4","date":"2017-05-10T10:01:38.000Z","updated":"2017-05-11T01:21:35.719Z","comments":true,"path":"2017/05/10/Coursera-ML-9-Programming-Exercise-4/index.html","link":"","permalink":"http://feiyang.li/2017/05/10/Coursera-ML-9-Programming-Exercise-4/index.html","excerpt":"对应反向传播算法内容","text":"对应反向传播算法内容 Programming Exercise 4 - Neural Networks Learning1234567891011121314151617181920# %load ../../../standard_import.txtimport pandas as pdimport numpy as npimport matplotlib as mplimport matplotlib.pyplot as plt# load MATLAB filesfrom scipy.io import loadmatpd.set_option('display.notebook_repr_html', False)pd.set_option('display.max_columns', None)pd.set_option('display.max_rows', 150)pd.set_option('display.max_seq_items', None) #%config InlineBackend.figure_formats = &#123;'pdf',&#125;%matplotlib inlineimport seaborn as snssns.set_context('notebook')sns.set_style('darkgrid') Load MATLAB datafiles12data = loadmat('data/ex4data1.mat')data.keys() dict_keys([&apos;__header__&apos;, &apos;__version__&apos;, &apos;__globals__&apos;, &apos;X&apos;, &apos;y&apos;]) 123456y = data['y']# Add interceptX = np.c_[np.ones((data['X'].shape[0],1)), data['X']]print('X:',X.shape, '(with intercept)')print('y:',y.shape) X: (5000, 401) (with intercept) y: (5000, 1) 12weights = loadmat('data/ex3weights.mat')weights.keys() dict_keys([&apos;__header__&apos;, &apos;__version__&apos;, &apos;__globals__&apos;, &apos;Theta1&apos;, &apos;Theta2&apos;]) 12345theta1, theta2 = weights['Theta1'], weights['Theta2']print('theta1 :', theta1.shape)print('theta2 :', theta2.shape)params = np.r_[theta1.ravel(), theta2.ravel()]print('params :', params.shape) theta1 : (25, 401) theta2 : (10, 26) params : (10285,) Neural NetworkInput layer size = 400 (20x20 pixels) Hidden layer size = 25 Number of labels = 10 Neural Networks - Feed Forward and Cost Function12def sigmoid(z): return(1 / (1 + np.exp(-z))) Sigmoid gradient $$ g'(z) = g(z)(1 - g(z))$$ where $$ g(z) = \\frac{1}{1+e^{-z}}$$ 12def sigmoidGradient(z): return(sigmoid(z)*(1-sigmoid(z))) Cost Function $$ J(\\theta) = \\frac{1}{m}\\sum_{i=1}^{m}\\sum_{k=1}^{K}\\big[-y^{(i)}_{k}\\, log\\,(( h_\\theta\\,(x^{(i)}))_k)-(1-y^{(i)}_k)\\,log\\,(1-h_\\theta(x^{(i)}))_k)\\big]$$ Regularized Cost Function $$ J(\\theta) = \\frac{1}{m}\\sum_{i=1}^{m}\\sum_{k=1}^{K}\\bigg[-y^{(i)}_{k}\\, log\\,(( h_\\theta\\,(x^{(i)}))_k)-(1-y^{(i)}_k)\\,log\\,(1-h_\\theta(x^{(i)}))_k)\\bigg] + \\frac{\\lambda}{2m}\\bigg[\\sum_{j=1}^{25}\\sum_{k=1}^{400}(\\Theta_{j,k}^{(1)})^2+\\sum_{j=1}^{10}\\sum_{k=1}^{25}(\\Theta_{j,k}^{(2)})^2\\bigg]$$ 123456789101112131415161718192021222324252627282930313233343536def nnCostFunction(nn_params, input_layer_size, hidden_layer_size, num_labels, features, classes, reg): # When comparing to Octave code note that Python uses zero-indexed arrays. # But because Numpy indexing does not include the right side, the code is the same anyway. theta1 = nn_params[0:(hidden_layer_size*(input_layer_size+1))].reshape(hidden_layer_size,(input_layer_size+1)) theta2 = nn_params[(hidden_layer_size*(input_layer_size+1)):].reshape(num_labels,(hidden_layer_size+1)) m = features.shape[0] y_matrix = pd.get_dummies(classes.ravel()).as_matrix() # Cost a1 = features # 5000x401 z2 = theta1.dot(a1.T) # 25x401 * 401x5000 = 25x5000 a2 = np.c_[np.ones((features.shape[0],1)),sigmoid(z2.T)] # 5000x26 z3 = theta2.dot(a2.T) # 10x26 * 26x5000 = 10x5000 a3 = sigmoid(z3) # 10x5000 J = -1*(1/m)*np.sum((np.log(a3.T)*(y_matrix)+np.log(1-a3).T*(1-y_matrix))) + \\ (reg/(2*m))*(np.sum(np.square(theta1[:,1:])) + np.sum(np.square(theta2[:,1:]))) # Gradients d3 = a3.T - y_matrix # 5000x10 d2 = theta2[:,1:].T.dot(d3.T)*sigmoidGradient(z2) # 25x10 *10x5000 * 25x5000 = 25x5000 delta1 = d2.dot(a1) # 25x5000 * 5000x401 = 25x401 delta2 = d3.T.dot(a2) # 10x5000 *5000x26 = 10x26 theta1_ = np.c_[np.ones((theta1.shape[0],1)),theta1[:,1:]] theta2_ = np.c_[np.ones((theta2.shape[0],1)),theta2[:,1:]] theta1_grad = delta1/m + (theta1_*reg)/m theta2_grad = delta2/m + (theta2_*reg)/m return(J, theta1_grad, theta2_grad) 12# Regularization parameter = 0nnCostFunction(params, 400, 25, 10, X, y, 0)[0] 0.28762916516131892 12# Regularization parameter = 1nnCostFunction(params, 400, 25, 10, X, y, 1)[0] 0.38376985909092365 1[sigmoidGradient(z) for z in [-1, -0.5, 0, 0.5, 1]] [0.19661193324148185, 0.23500371220159449, 0.25, 0.23500371220159449, 0.19661193324148185]","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"ss-panel 一键安装脚本（前端后端全自动一键安装脚本）","slug":"ss-shell","date":"2017-05-09T13:58:57.000Z","updated":"2017-05-26T00:47:15.863Z","comments":true,"path":"2017/05/09/ss-shell/index.html","link":"","permalink":"http://feiyang.li/2017/05/09/ss-shell/index.html","excerpt":"上周接触了ss-panel，发现搭建起来异常的麻烦，对新手来说，到处都是坑，因此写了本ss-panel一键安装脚本 。示例站点：https://ss.feiyang.li/","text":"上周接触了ss-panel，发现搭建起来异常的麻烦，对新手来说，到处都是坑，因此写了本ss-panel一键安装脚本 。示例站点：https://ss.feiyang.li/ 特点 可以使用BBR加速：选择对应一键代码即可 使用supervisord，守护运行。（重启后输入supervisord，即可启动守护程序） 前端使用最新ss-panel v3，稳定性和可管理行都有明显提高。 后端使用shadowsocks-py-mu，多用户版本，与前端完美对接。 过程全自动，所以可能碰到的坑都提前做好处理。 被墙掉的资源都换成了墙内资源，不会出现被卡死的情况了。 效果 Github：https://github.com/mmmwhy/ss-panel-and-ss-py-mu 示例网站：https://ss.feiyang.li/ 系统要求建议CentOS7 X64，我用的是这个版本，目前在腾讯云，digitalocean，interserver上通过测试。理论上：CentOS 6+ / Debian 7+ / Ubuntu 14.04 + 都可以， 一键安装脚本 登陆后运行：1screen -S ss 如果提示screen: command not found 命令不存在可以执行：yum install screen 或 apt-get install screen安装（如果网络掉线，可以重新连接，再执行 screen -r ss 就会看到你的ss-panel安装进程。） 安装脚本1wget -N --no-check-certificate https://raw.githubusercontent.com/mmmwhy/ss-panel-and-ss-py-mu/master/ss-panel_node.sh &amp;&amp; chmod +x ss-panel_node.sh &amp;&amp; bash ss-panel_node.sh 运行脚本后会出现脚本操作菜单， ss-panel和ss-node同时安装选择并输入 1 因为ss-panel依赖于mysql,php,nginx，使用lnmp一键安装包，点击任意键开始安装。 LNMP包编译时间较长，可以喝杯茶吃个饭。大约30分钟左右，安装结束，提示登陆IP即可查看网站 默认账户：ss@feiyang.li 默认密码：feiyang 进入ss-panel页面后，记得在管理面板-&gt;节点管理-&gt;添加节点-&gt;输入节点信息 之后回到用户面板，就可以使用了。 仅安装ss-panel选择并输入 2出现的结果与1相同，只不过您vps上没有同时安装ss-py-mu 仅安装ss-node 先在网页增加节点信息，特别要记住这里的node_id，长这个样子的 选择并输入 3，用于新建节点。 输入相关信息，ip地址和域名（ss-panel的）都可以，但是需要加上http:// 或者 https:// ，注意区分自己域名有没有ssl。否则可能出现用户使用记录无法推送的问题。 如果使用本一键脚本搭建前端页面，第二个mukey可以直接按回车，默认是mupass 第三个位置输入之前那个node_id。 如果最后提示cat log失败，其实是不影响的，因为有没有记录是不影响的。查看 shadowsocks-manyuser 是否已经运行：12ps -ef | grep servers.pyroot 952 739 0 15:40 ? 00:00:00 python /root/shadowsocks-rm/shadowsocks/servers.p 出现底下那一行，就代表运行成功了。 其他补充内容 LNMP环境编译时间较长 php依赖安装会花费较长时间，特别是在国内 本页面停留时间较长 如果想设置更多的信息，请查看安装教程全文，本脚本和该教程内容完全一致。 常见错误在这里查看 不停的有人问“node不能添加”“启动不起来”“怎么添加域名”“怎么修改签到流量”“怎么修改初始流量”…….如果真的有什么问题，建议先看上边两个页面，其实写的很清楚了。 如果总是遇到不能连接的问题，建议直接关闭node节点的防火墙","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://feiyang.li/categories/shadowsocks/"}],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"},{"name":"教程","slug":"教程","permalink":"http://feiyang.li/tags/教程/"},{"name":"vps","slug":"vps","permalink":"http://feiyang.li/tags/vps/"},{"name":"shell","slug":"shell","permalink":"http://feiyang.li/tags/shell/"}]},{"title":"Coursera ML(8)-Neural Networks: Learning","slug":"Coursera-ML-8-Neural-Networks-Learning","date":"2017-05-06T13:52:23.000Z","updated":"2017-05-10T11:56:05.596Z","comments":true,"path":"2017/05/06/Coursera-ML-8-Neural-Networks-Learning/index.html","link":"","permalink":"http://feiyang.li/2017/05/06/Coursera-ML-8-Neural-Networks-Learning/index.html","excerpt":"本节笔记对应第五周Coursera课程 Neural Networks: Learning","text":"本节笔记对应第五周Coursera课程 Neural Networks: Learning Cost Fuction cost function $$\\begin{gather*} J(\\Theta) = - \\frac{1}{m} \\sum_{i=1}^m \\sum_{k=1}^K \\left[y^{(i)}_k \\log ((h_\\Theta (x^{(i)}))_k) + (1 - y^{(i)}_k)\\log (1 - (h_\\Theta(x^{(i)}))_k)\\right] \\end{gather*}$$ 我们使用循环，对每一行特征都预测K个不同的结果，然后利用循环在K个预测中选择可能性最高的一个，将其与y中的实际数据进行对比。 Similarly, the regularization term just sum up the square of all the parameters from all the layers: $$\\frac{\\lambda}{2m}\\sum_{l=1}^{L-1} \\sum_{i=1}^{s_l} \\sum_{j=1}^{s_{l+1}} ( \\Theta_{j,i}^{(l)})^2$$ 正则化的这一项，是在排除了每一层$\\theta_0$后，每一层的$\\Theta$矩阵的和。 最里层的循环$j$循环所有的行(由$s_{l+1}$层的激活单元数决定)。 循环$i$则循环所有的列，由该层(s_l层)的激活单元数决定。 Note:这个看起来很复杂的代价函数与之前代价函数思想是一样的，我们希望通过代价函数来观察算法预测的结果与真实情况的误差有多大。不同的是，对于每一行特征，我们都会给出K个预测。 Backpropagation Algorithm这一块我也看的不是很懂，先不做笔记。之后如果有新的感悟，再记回来。 没有就算了。 最终证明还是可以看懂的，csdn这个sb编辑器，害得我记得笔记丢失了一次，好气哦。又得抄大佬的笔记了。 In order to use optimization algorithms like gradient descent, we must calculate the derivative of the cost function. First we should calculate $\\delta$ for each layer using backpropagation algorithm. From $layer_l$ to $layer_{l+1}$ we have: $$\\delta^{(output)} = a^{(output)} - y\\\\\\delta^{(l)} = [\\Theta^{(l)}]^T \\delta^{(l+1)} .* g'(z^{(l)})$$ 误差$\\delta$表示激活单元的预测值与实际值之间的误差。第二行式子，是在后一层偏差的基础上，增加了本层的偏差。 注意：没有$\\delta_1$ 一点感悟 将这两个图，联系在一起，好像对反向传播有了一些理解。其实就是在正向传播的基础上，因为最终的对比结果是在最外层，那么我们从最外层开始，重新纠正一遍计算过程，这样可以减少误差。 For sigmoid function, $g’(z) = g(z)(1-g(z))$这个比较简单，就不推导了。 Then we have the derivative: $$\\frac {\\partial}{\\partial \\Theta_{ij}^{(l)}} J(\\Theta) = a_j^{(l)} \\delta_i^{(l+1)} \\\\\\Delta^{(l)} = \\delta^{(l+1)} (a^{(l)})^T$$ 在Coursera教程中，这个地方被草草带过，相比之下uci的这篇文章介绍的非常详细。 一个推导过程 另外一个推导BackPropagation算法BackPropagation算法是多层神经网络的训练中举足轻重的算法，简单的理解，它就是复合函数的链式法则。由于后面我的网络中会用到对数损失函数，所以在这里我们使用平方损失函数。对于单个样例，其平方损失函数为： 对于给定一个包含m个样例的数据集，我们可以定义整体代价函数为： 和直线的拟合类似，深度学习也有一个目标函数，通过这个目标函数我们可以知道参数为何值时对我们来说才是一组“好”的参数，这个函数就是前边提到的损失函数。训练的过程就是通过每一次迭代对网络中参数进行更新，来使损失函数的值达到最小(下图中α为学习率)。 利用BackPropagation算法计算偏导数由上一节可知，我们只需求出每一层的 ](http://cdn.mmmxcc.cn/blog/20170508/144525573.png) 和![ 即可完成该层的权值和偏置的更新。BP算法的整体思路如下：对于每个给定的训练样本，首先进行前向计算，计算出网络中每一层的激活值和网络的输出。对于最后一层(输出层)，我们可以直接计算出网络的输出值与已经给出的标签值(label)直接的差距，我们将这个值定义为残差δ。对于输出层之前的隐藏层L，我们将根据L+1层各节点的加权平均值来计算第L层的残差。 插入一些我个人对BP算法的一点比较容易理解的解释(如有错误请指出)：在反向传播过程中，若第x层的a节点通过权值W对x+1层的b节点有贡献，则在反向传播过程中，梯度通过权值W从b节点传播回a节点。不管下面的公式推导，还是后面的卷积神经网络，在反向传播的过程中，都是遵循这样的一个规律。 反向传播的具体步骤如下： 根据输入，计算出每一层的激活值。 对于输出层，我们使用如下公式计算每个单元的残差： 对于输出层之前的每一层，按照如下公式计算每一层的残差： 由残差计算每一层的偏导数： 最后，使用偏导数更新权值和偏置。 其实说到底，这两个推导方法其实是一回事，只不过换了几个字母而已。第二个推导更好一些 Instead of calculate the $\\Delta$ for all the training data, we could sum up all the inputs independantly, like:From i = 1 to m, do:$$\\Delta^{(l)} += \\delta^{(l+1)} (a^{(l)})^T $$Then we have: $$ \\\\\\frac {\\partial}{\\partial \\Theta_{ij}^{(l)}} J(\\Theta) = \\frac {1}{m} \\Delta_{ij}^{(l)}$$ (This step is the main step for mapreduce, see Large Scale Machine Learning) Then add regularzation term for partial derivative, we have: $ $\\frac {\\partial}{\\partial \\Theta_{ij}^{(l)}} J(\\Theta) = \\frac {1}{m} \\Delta_{ij}^{(l)} + \\frac {\\lambda}{m} \\Theta_{ij}^{(l)}$$ Finally, using $J(\\Theta)$ and $\\frac {\\partial}{\\partial \\Theta_{ij}^{(l)}} J(\\Theta)$, we could minimize the cost function using gradient descent as well as other optimization algorithms. Optional Section: How Backpropagation WorksUsing the same model as the last section: $$\\begin{align}\\frac {\\partial J}{\\partial \\Theta_{ij}^{(1)}} =\\frac {\\partial J}{\\partial a_i^{(2)}}\\frac {\\partial a_i^{(2)}}{\\partial z_i^{(2)}}\\frac {\\partial z_i^{(2)}}{\\partial \\Theta_{ij}^{(1)}} \\\\ =\\frac {\\partial J}{\\partial a_i^{(2)}} g’(z_i^{(2)}) a_i^{(1)}\\end{align}$$Then taking the total derivative with respect to $z^{(3)}$, a recursive expression for the derivative is obtained:$$\\begin{align}\\frac {\\partial J}{\\partial a_i^{(2)}} =\\sum\\limits_{m=1}^{s_3}\\frac {\\partial J}{\\partial z_m^{(3)}}\\frac {\\partial z_m^{(3)}}{\\partial a_i^{(2)}} \\\\ =\\sum\\limits_{m=1}^{s_3}\\frac {\\partial J}{\\partial a_m^{(3)}}\\frac {\\partial a_m^{(3)}}{\\partial z_m^{(3)}}\\frac {\\partial z_m^{(3)}}{\\partial a_i^{(2)}} \\\\ =\\sum\\limits_{m=1}^{s_3}\\frac {\\partial J}{\\partial a_m^{(3)}} g’(z_m^{(3)}) \\Theta_{mi}^{(2)}\\end{align}$$Let $\\delta_i^{(2)} =\\frac {\\partial J}{\\partial a_i^{2}} g’(z_i^{(2)})$, then from the result of the first formula We have: $\\frac {\\partial J}{\\partial \\Theta_{ij}^{1}} =\\delta_i^{(2)} a_i^{(1)}$, in which recursively, $\\delta_i^{(2)} =(\\sum\\limits_{m=1}^{s_3}\\delta_m^{(3)}\\Theta_{mi}^{(2)}) g’(z_i^{(2)})$ – Referance:http://www.wikiwand.com/en/Backpropagation#Derivationttp://blog.csdn.net/l691899397/article/details/52223998http://xxuan.me/2016-02-20-Neural-Networks-Learning.html","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"shadowsocks-Clients","slug":"ss-client","date":"2017-05-05T06:23:13.000Z","updated":"2017-05-20T01:22:29.813Z","comments":true,"path":"2017/05/05/ss-client/index.html","link":"","permalink":"http://feiyang.li/2017/05/05/ss-client/index.html","excerpt":"shadowsocks是目前fq速度最快的工具之一，可以转发udp。可以使用ipv6，对于很多高校学生来说，可以通过此方法节省流量费用。","text":"shadowsocks是目前fq速度最快的工具之一，可以转发udp。可以使用ipv6，对于很多高校学生来说，可以通过此方法节省流量费用。 Windowssshttp://home.ustc.edu.cn/~mmmwhy/Shadowsocks.exe 在任务栏找到 Shadowsocks 图标 在 服务器 菜单添加多个服务器 选择 启用系统代理 来启用系统代理。请禁用浏览器里的代理插件，或把它们设置为使用系统代理。 ssrhttp://home.ustc.edu.cn/~mmmwhy/ShadowsocksR-dotnet4.0.exe右键 纸飞机 -&gt; 扫描二维码 -&gt; 开启系统代理选择 -&gt;pac模式或者全局模式 如果遇到某个节点不能使用，可以换一个，因为本地运营商可能会把某些ip墙掉。 Mac OS Xhttps://github.com/shadowsocks/ShadowsocksX-NG/releasesOS X 下设置使用方法Mac 下使用极其方便，因为 GUI 已经集成了系统 Pac，所以无需设置任何科学上网的姿势，直接运行 ShadowsocksX ，然后输入服务商提供给你的账号信息，保存运行后，即可在所有浏览器里直接科学上网，如图： Linuxhttps://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation Androidssr 扫描二维码-&gt; 然后点小飞机就可以了 iOSSsrConnect - Proxy Utility 免费Network Proxy Utility 免费Shadowrocket 付费土豆丝 付费 OpenWRT shadowsocks-libevopkg install shadowsocks-libev shadowsocks-libev-polarsslopkg install shadowsocks-libev-polarssl","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://feiyang.li/categories/shadowsocks/"}],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"},{"name":"教程","slug":"教程","permalink":"http://feiyang.li/tags/教程/"},{"name":"vps","slug":"vps","permalink":"http://feiyang.li/tags/vps/"}]},{"title":"ss-panel + ss py mu安装教程","slug":"ss-panel-full","date":"2017-05-05T06:09:39.000Z","updated":"2017-05-26T01:13:00.278Z","comments":true,"path":"2017/05/05/ss-panel-full/index.html","link":"","permalink":"http://feiyang.li/2017/05/05/ss-panel-full/index.html","excerpt":"系统介绍： 1g内存，单核，也就是传说中的腾讯1元学生机。centos6.8 x32。","text":"系统介绍： 1g内存，单核，也就是传说中的腾讯1元学生机。centos6.8 x32。 读者建议：如果使用国外vps建议会快速很多。国内vps建议本方法。 lnmp环境配置这里使用最新的lnmp1.41wget -c http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz &amp;&amp; tar zxf lnmp1.4beta.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp 安装ss-panel前端下载 ss-panel 源码12cd /home/wwwroot/ git clone https://github.com/orvice/ss-panel.git 安装好之后，是这个样子的。 mark 配置 ss-panel.env文件配置安装依赖文件，并配置.env1234cd /home/wwwroot/ss-panel/curl -sS https://install.phpcomposer.com/installer | phpchmod +x composer.pharphp composer.phar install 安装依赖那一步时间会久一些，因为一共有75个依赖，而且很多被墙了（因此如果直接用国外vps，真的会好很多），换了国内源会稍微好一些。 漫长的等待 123chmod -R 777 storagecp .env.example .envvi .env 这里主要是修改数据库的内容，还有muKey。 nginx配置1234lnmp vhost add# 写入站点网址/home/wwwroot/ss-panel/public# 允许重写规则，其余一律是n 进入nginx配置文件再修改一下：1cd /usr/local/nginx/conf/vhost/ 完整配置文件应该是这个样子123456789101112131415161718192021222324252627282930313233server &#123; listen 80; #listen [::]:80;server_name ss.feiyang.li n;index index.html index.htm index.php default.html default.htm default.php;root /home/wwwroot/ss.feiyang.li/public; location / &#123; try_files $uri $uri/ /index.php$is_args$args; &#125;location ~ [^/]\\.php(/|$) &#123; # comment try_files $uri =404; to enable pathinfo try_files $uri =404; fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; #include pathinfo.conf;fastcgi_param PHP_ADMIN_VALUE &quot;open_basedir = /home/wwwroot/:/temp/:/proc&quot;;&#125; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d; &#125; location ~ .*\\.(js|css)?$ &#123; expires 12h; &#125; &#125; 新建ss数据库12345mysql -uroot -p# 输入自己的密码create database ss;use ss;source /home/wwwroot/ss-panel/db.sql; 现在访问你的站点，就可以看到 ss-panel 啦： 添加管理员账户文字排序会让强迫症奔溃。。。。。php xcat createAdmin 邮箱设置1234vi .envmailgun_key = &apos;key-0****c09&apos; //上面的KEYmailgun_domain = &apos;https://api.mailgun.net/v3/feiyang.li&apos; //你经过验证过的域名mailgun_sender = &apos;postmaster@****.net&apos; //postmaster@你经过验证过的域名 https证书lnmp ssl add/home/wwwroot/ss-panel/1_ss.feiyang.li_bundle.crt/home/wwwroot/ss-panel/2_ss.feiyang.li.key获得绿色小锁~ 安装 SS PY MU 服务端安装libsodium支持chacha20centos：123456yum -y groupinstall &quot;Development Tools&quot;wget https://github.com/jedisct1/libsodium/releases/download/1.0.11/libsodium-1.0.11.tar.gztar xf libsodium-1.0.11.tar.gz &amp;&amp; cd libsodium-1.0.11./configure &amp;&amp; make -j2 &amp;&amp; make installecho /usr/local/lib &gt; /etc/ld.so.conf.d/usr_local_lib.confldconfig ubuntu/debian：12345apt-get install build-essentialwget https://github.com/jedisct1/libsodium/releases/download/1.0.11/libsodium-1.0.11.tar.gztar xf libsodium-1.0.11.tar.gz &amp;&amp; cd libsodium-1.0.11./configure &amp;&amp; make -j2 &amp;&amp; make installldconfig 将代码 clone 到本地：123cd ~git clone https://github.com/fsgmhoward/shadowsocks-py-mu.gitcd ~/shadowsocks-py-mu/shadowsocks/ 其中的 shadowsocks 子目录才是我们需要的，外面的是 setup.py 的相关文件。 配置 shadowsocks-manyuser12cp config_example.py config.pyvi config.py 修改其中第 15 行和第 29~31 行的内容： 1234567# 启用 MultiUser APIAPI_ENABLED = True# 就是在你的站点地址后面加个 /muAPI_URL = &apos;http://ss.feiyang.li/mu&apos; # 还记得上面在 .env 中填写的 muKey 吗？把它填在这里API_PASS = &apos;api_key_just_for_test&apos; 由于我们选择使用 Mu API 来与前端通信，所以我们不需要修改 config.py 中任何关于数据库的配置。 好了，现在可以试着运行一下1python servers.py （注意，是 servers.py 而不是 server.py）。如果没错的话，应该可以看到这样的输出： 配置 ss-manyuser 守护进程 安装 supervisor （用的是上面安装过的 pip）： 12yum install python-setuptoolseasy_install supervisor 创建 supervisor 配置文件 1echo_supervisord_conf &gt; /etc/supervisord.conf 运行 supervisor 服务 1supervisord 配置 supervisor 以监控 ss-manyuser 运行 1vim /etc/supervisord.conf 在文件尾部添加如下内容并酌情修改： 12345[program:ss-manyuser]command = python /root/shadowsocks-py-mu/shadowsocks/servers.py user = root autostart = true autorestart = true 其中 command 里的目录请自行修改为你的 servers.py所在的绝对路径。 重启 supervisor 服务以加载配置 1killall -HUP supervisord 查看 shadowsocks-manyuser 是否已经运行： 12ps -ef | grep servers.pyroot 952 739 0 15:40 ? 00:00:00 python /root/shadowsocks-rm/shadowsocks/servers.py 可以通过以下命令管理 shadowsock-manyuser 的状态 1supervisorctl &#123;start|stop|restart&#125; ss-manyuser 谷歌BBR加速OpenVZ 以外的（ KVM 、 Xen 、 VMware 等）123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 详细信息见： https://www.91yun.org/archives/5174 OpenVZ 小鸡1wget --no-check-certificate https://raw.githubusercontent.com/mmmwhy/LKL_BBR/master/lkl/install.sh &amp;&amp; bash install.sh 如果运行之后，发现不能连接服务器，可能因为防火墙设置问题。可以直接关闭node节点的防火墙对于CentOS:12service iptables stop #关闭命令： chkconfig iptables off# 永久关闭防火墙： 详细内容见：https://www.91yun.org/archives/6281 其余常见错误：http://feiyang.li/2017/05/03/ss-panel/index.html#常见错误 与上文一样，本文参考了如下博主文章，在此致谢：https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/http://bitzhi.com/2016/03/install-ss-go-mu-and-ss-panel-v3/https://levyhsu.com/?p=98","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://feiyang.li/categories/shadowsocks/"}],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"},{"name":"教程","slug":"教程","permalink":"http://feiyang.li/tags/教程/"},{"name":"vps","slug":"vps","permalink":"http://feiyang.li/tags/vps/"}]},{"title":"可能是最简单的ss-panel安装教程","slug":"ss-panel","date":"2017-05-03T12:13:08.000Z","updated":"2017-05-26T01:13:17.621Z","comments":true,"path":"2017/05/03/ss-panel/index.html","link":"","permalink":"http://feiyang.li/2017/05/03/ss-panel/index.html","excerpt":"因为阿松同学找我要ss账号，因此我大概花了一天时间搞了搞ss-panel，顺便做个记录吧。网上那么多教程有些是写得笼统，有些还是瞎复制的。由此萌生了想要写一篇配置 ss-panel 和 ss-manyuser 的教程，希望能够帮到需要的人。","text":"因为阿松同学找我要ss账号，因此我大概花了一天时间搞了搞ss-panel，顺便做个记录吧。网上那么多教程有些是写得笼统，有些还是瞎复制的。由此萌生了想要写一篇配置 ss-panel 和 ss-manyuser 的教程，希望能够帮到需要的人。 好消息！！！ 我已经写好了ss-panel一键脚本，对小白非常友好~ 产品要求：fuck the wall、在可用范围内尽量简单一些（因此不考虑ssr，魔改panel也不考虑）读者建议：如果使用国外vps，建议本方法。国内vps建议 ss-panel前端我看官方文档，按部就班的做了一个前端，最后才发现竟然有ss-panel一键脚本，真的是血都要吐出来了。好气哦。这里直接介绍一键脚本方式。 脚本下载以及运行首先运行：12yum -y install screenscreen -S ssmanyuser 然后执行：123wget https://cloud.echoteen.com/s/24bSM2Ba48JTHlQ/download -O ss-install.binchmod a+x ss-install.binbash ss-install.bin 安装ss-panel选择1，安装ss-panel前端，注意，首先要安装好前端！所以输入1，然后回车！安装好了以后，打开网站配置文件 12cd /etc/nginx/conf.dvim ss-panel.conf 打开配置文件主要是检查server_name和root mark 数据库配置mysql_secure_installation首先输入上述代码进行数据库初始化配置数据库密码等，这个自行设置！然后就是创建数据库和导入数据库了12345mysql -uroot -p# 输入自己的密码create database ss;use ss;source /home/www/panel/db.sql 真的，有了这个脚本之后，解决了很多麻烦的问题。 配置配置文件配置网页文件（.env），就是站点信息，很简单的1vim .env 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// ss-panel v3 配置//// !!! 修改此key为随机字符串确保网站安全 !!!key = &apos;randomKey&apos;env = &apos;prod&apos; // 正式环境请保持env为prod确保安全debug = &apos;false&apos; // 正式环境请确保为falseappName = &apos;ss-panel3&apos; //站点名称baseUrl = &apos;https://www.google.com&apos; // 站点地址timeZone = &apos;PRC&apos; // RPC 天朝时间 UTC 格林时间pwdMethod = &apos;md5&apos; // 密码加密 可选 md5,sha256salt = &apos;&apos; // 密码加密用，从旧版升级请留空theme = &apos;default&apos; // 主题session = &apos;file&apos; //默认cache = &apos;file&apos; //默认tokenDriver = &apos;db&apos; //默认// mu key 用于校验ss-go mu的请求,后边会用到muKey = &apos;&apos;// 邮件mailDriver = &apos;mailgun&apos; // mailgun #smtp不在支持,仅供测试 // 注册限制,每天每个ip能注册的次数ipDayLimit = &apos;10&apos; // 邮箱验证设置emailVerifyEnabled = &apos;false&apos; // 是否开启注册时邮箱验证 (true:开启 false:关闭)emailVerifyCodeLength = &apos;8&apos; // 邮箱验证代码长度emailVerifyTTL = &apos;30&apos; // 验证代码有效时间 单位分钟 // 用户签到设置checkinTime = &apos;22&apos; // 签到间隔时间 单位小时checkinMin = &apos;93&apos; // 签到最少流量 单位MBcheckinMax = &apos;97&apos; // 签到最多流量 //defaultTraffic = &apos;1&apos; // 用户初始流量 单位GB// 注册后获得的邀请码数量inviteNum = &apos;2&apos; // 记录流量日志到dynamodb ,beta,请勿开启log_traffic_dynamodb = &apos;false&apos; # database 数据库配置db_driver = &apos;mysql&apos;db_host = &apos;localhost&apos;db_port = &apos;3306&apos;db_database = &apos;ss&apos;db_username = &apos;root&apos;db_password = &apos;root&apos;db_charset = &apos;utf8&apos;db_collation = &apos;utf8_general_ci&apos;db_prefix = &apos;&apos; # redisredis_scheme = &apos;tcp&apos;redis_host = &apos;127.0.0.1&apos;redis_port = &apos;6379&apos;redis_database = &apos;0&apos;redis_pass = &apos;&apos; # mailgunmailgun_key = &apos;&apos;mailgun_domain = &apos;&apos;mailgun_sender = &apos;&apos; # smtpsmtp_host = &apos;&apos;smtp_username = &apos;&apos;smtp_port = &apos;&apos;smtp_name = &apos;&apos;smtp_sender = &apos;&apos;smtp_passsword = &apos;&apos;smtp_ssl = &apos;true&apos; # awsaws_access_key_id = &apos;&apos;aws_secret_access_key = &apos;&apos;aws_region = &apos;ap-northeast-1&apos;aws_ses_region = &apos;us-east-1&apos;aws_ses_sender = &apos;&apos; 添加管理员12345678php xcat createAdminadd admin/创建管理员帐号..... Enter your email/输入管理员邮箱: h@prinzeugen.net Enter password for: h@prinzeugen.net /为 h@prinzeugen.net 添加密码 xxx Email: h@prinzeugen.net, Password: xxx Press [Y] to create admin..... 按下[Y]确认来确认创建管理员账户..... y start create admin accountSuccessful/ 添加成功! 最后登录下网站 以上内容全部复制自：https://www.echoteen.com/yijian-sspanel-many-user.html/comment-page-1 因为ss-panel前端是基于ss原版，而该一键脚本后端基于ssr，因此这里不建议采用该脚本。 部署并配置 shadowsocks-manyuser这里使用的是 https://github.com/mengskysama/shadowsocks/tree/manyuser 版ss 安装 shadowsocks-manyuser先将代码 clone 到本地：git clone https://github.com/fsgmhoward/shadowsocks-py-mu.git其中的 shadowsocks 子目录才是我们需要的，注意这个地方和其他版本的不一样，ssr里子文件表示单用户。本版根据server.py还是servers.py来判断是不是多用户版本。 配置 shadowsocks-manyuser进入 shadowsocks 目录，将 config_example.py 复制一份到 config.py： 12cp config_example.py config.pyvi config.py 修改其中第 15 行和第 29~31 行的内容：1234567# 启用 MultiUser APIAPI_ENABLED = True# 就是在你的站点地址后面加个 /muAPI_URL = &apos;http://ss.feiyang.li/mu&apos; # 还记得上面在 .env 中填写的 muKey 吗？把它填在这里API_PASS = &apos;api_key_just_for_test&apos; 由于我们选择使用 Mu API 来与前端通信，所以我们不需要修改 config.py 中任何关于数据库的配置。 好了，现在可以试着运行一下 $ python servers.py 了（注意，是 servers.py 而不是 server.py）。如果没错的话，应该可以看到这样的输出： 常见错误不能上网首先国际惯例查看连接： netstat -anp | grep 你的端口 正常的话，应该是这样的：1234567Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:62111 0.0.0.0:* LISTEN 32083/python tcp 0 0 162.233.122.111:62111 115.233.233.140:47177 TIME_WAIT - tcp 0 0 162.233.122.111:62111 115.233.233.140:47161 TIME_WAIT - tcp 0 0 162.233.122.111:62111 115.233.233.140:47160 TIME_WAIT - tcp 0 0 162.233.122.111:62111 115.233.233.140:47157 TIME_WAIT - 所以如果你要开放注册，就要这样配置你的 iptables：1234# 注意是半角冒号，意为允许 12450 及以上的端口# 也可以指定 1024:65535 这样的范围iptables -I INPUT -p tcp -m tcp --dport 1024: -j ACCEPTiptables-save 关闭防火墙一劳永逸解决问题，对于CentOS:12service iptables stop #关闭命令： chkconfig iptables off #永久关闭防火墙： ss-panel 的多节点配置其实多节点也没咋玄乎，说白了就是多个后端共用一个前端而已。而且我们的后端是使用 Mu API 来与前端进行交互的，所以多节点的配置就更简单了：只要把所有后端的 config.py 中的 API_URL 和 API_PASS 都改成一样即可（记得 API_ENABLED = True）。 ss服务端安装libsodium支持chacha20centos：123456yum -y groupinstall &quot;Development Tools&quot;wget https://github.com/jedisct1/libsodium/releases/download/1.0.11/libsodium-1.0.11.tar.gztar xf libsodium-1.0.11.tar.gz &amp;&amp; cd libsodium-1.0.11./configure &amp;&amp; make -j2 &amp;&amp; make installecho /usr/local/lib &gt; /etc/ld.so.conf.d/usr_local_lib.confldconfig ubuntu/debian：12345apt-get install build-essentialwget https://github.com/jedisct1/libsodium/releases/download/1.0.11/libsodium-1.0.11.tar.gztar xf libsodium-1.0.11.tar.gz &amp;&amp; cd libsodium-1.0.11./configure &amp;&amp; make -j2 &amp;&amp; make installldconfig 参考链接：https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/https://www.echoteen.com/yijian-sspanel-many-user.html/comment-page-1/#commentshttps://github.com/sendya/shadowsocks-panel/wiki/Shadowsocks-Panel-%E9%9D%A2%E6%9D%BF%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://feiyang.li/categories/shadowsocks/"}],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"},{"name":"教程","slug":"教程","permalink":"http://feiyang.li/tags/教程/"},{"name":"vps","slug":"vps","permalink":"http://feiyang.li/tags/vps/"}]},{"title":"Coursera ML(7)-Programming Exercise 3","slug":"Coursera-ML-7-Programming-Exercise-3","date":"2017-05-02T10:01:38.000Z","updated":"2017-05-02T10:04:58.026Z","comments":true,"path":"2017/05/02/Coursera-ML-7-Programming-Exercise-3/index.html","link":"","permalink":"http://feiyang.li/2017/05/02/Coursera-ML-7-Programming-Exercise-3/index.html","excerpt":"machine-learning-ex3.zip 下载链接，第四周的课程相对来说比较简单，大致介绍了神经网络相关内容。","text":"machine-learning-ex3.zip 下载链接，第四周的课程相对来说比较简单，大致介绍了神经网络相关内容。 注意，官方用的是matlab，这里我用的全部是python，代码是不一样的，更不能当做作业提交。 Programming Exercise 3 - Multi-class Classification and Neural Networks题目介绍For this exercise, you will use logistic regression and neural networks to recognize handwritten digits (from 0 to 9). ex3data1.mat提供了一个训练集，X包含5000个长度为400的向量，每个向量可以展示为一个20*20的图像。Y内为图像所对应的数字。 Code1234567891011121314151617181920212223# %load ../../standard_import.txtimport pandas as pdimport numpy as npimport matplotlib as mplimport matplotlib.pyplot as plt# load MATLAB filesfrom scipy.io import loadmatfrom scipy.optimize import minimizefrom sklearn.linear_model import LogisticRegressionpd.set_option('display.notebook_repr_html', False)pd.set_option('display.max_columns', None)pd.set_option('display.max_rows', 150)pd.set_option('display.max_seq_items', None) #%config InlineBackend.figure_formats = &#123;'pdf',&#125;%matplotlib inlineimport seaborn as snssns.set_context('notebook')sns.set_style('white') Load MATLAB datafiles12data = loadmat('data/ex3data1.mat')data.keys() dict_keys([&apos;__header__&apos;, &apos;__version__&apos;, &apos;__globals__&apos;, &apos;X&apos;, &apos;y&apos;]) 12weights = loadmat('data/ex3weights.mat')weights.keys() dict_keys([&apos;__header__&apos;, &apos;__version__&apos;, &apos;__globals__&apos;, &apos;Theta1&apos;, &apos;Theta2&apos;]) 123456y = data['y']# Add constant for interceptX = np.c_[np.ones((data['X'].shape[0],1)), data['X']]print('X: &#123;&#125; (with intercept)'.format(X.shape))print('y: &#123;&#125;'.format(y.shape)) X: (5000, 401) (with intercept) y: (5000, 1) 1234theta1, theta2 = weights['Theta1'], weights['Theta2']print('theta1: &#123;&#125;'.format(theta1.shape))print('theta2: &#123;&#125;'.format(theta2.shape)) theta1: (25, 401) theta2: (10, 26) 123sample = np.random.choice(X.shape[0], 20)plt.imshow(X[sample,1:].reshape(-1,20).T)plt.axis('off'); Multiclass ClassificationLogistic regression hypothesis $$ h_{\\theta}(x) = g(\\theta^{T}x)$$ $$ g(z)=\\frac{1}{1+e^{−z}} $$ 12def sigmoid(z): return(1 / (1 + np.exp(-z))) Regularized Cost Function $$ J(\\theta) = \\frac{1}{m}\\sum_{i=1}^{m}\\big[-y^{(i)}\\, log\\,( h_\\theta\\,(x^{(i)}))-(1-y^{(i)})\\,log\\,(1-h_\\theta(x^{(i)}))\\big] + \\frac{\\lambda}{2m}\\sum_{j=1}^{n}\\theta_{j}^{2}$$ Vectorized Cost Function $$ J(\\theta) = \\frac{1}{m}\\big((\\,log\\,(g(X\\theta))^Ty+(\\,log\\,(1-g(X\\theta))^T(1-y)\\big) + \\frac{\\lambda}{2m}\\sum_{j=1}^{n}\\theta_{j}^{2}$$ 123456789def lrcostFunctionReg(theta, reg, X, y): m = y.size h = sigmoid(X.dot(theta)) J = -1*(1/m)*(np.log(h).T.dot(y)+np.log(1-h).T.dot(1-y)) + (reg/(2*m))*np.sum(np.square(theta[1:])) if np.isnan(J[0]): return(np.inf) return(J[0]) 1234567def lrgradientReg(theta, reg, X,y): m = y.size h = sigmoid(X.dot(theta.reshape(-1,1))) grad = (1/m)*X.T.dot(h-y) + (reg/m)*np.r_[[[0]],theta[1:].reshape(-1,1)] return(grad.flatten()) One-vs-allOne-vs-all Classification123456789def oneVsAll(features, classes, n_labels, reg): initial_theta = np.zeros((X.shape[1],1)) # 401x1 all_theta = np.zeros((n_labels, X.shape[1])) #10x401 for c in np.arange(1, n_labels+1): res = minimize(lrcostFunctionReg, initial_theta, args=(reg, features, (classes == c)*1), method=None, jac=lrgradientReg, options=&#123;'maxiter':50&#125;) all_theta[c-1] = res.x return(all_theta) 1theta = oneVsAll(X, y, 10, 0.1) One-vs-all Prediction123456def predictOneVsAll(all_theta, features): probs = sigmoid(X.dot(all_theta.T)) # Adding one because Python uses zero based indexing for the 10 columns (0-9), # while the 10 classes are numbered from 1 to 10. return(np.argmax(probs, axis=1)+1) 12pred = predictOneVsAll(theta, X)print('Training set accuracy: &#123;&#125; %'.format(np.mean(pred == y.ravel())*100)) Training set accuracy: 93.24 % Multiclass Logistic Regression with scikit-learn123clf = LogisticRegression(C=10, penalty='l2', solver='liblinear')# Scikit-learn fits intercept automatically, so we exclude first column with 'ones' from X when fitting.clf.fit(X[:,1:],y.ravel()) LogisticRegression(C=10, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, max_iter=100, multi_class=&apos;ovr&apos;, n_jobs=1, penalty=&apos;l2&apos;, random_state=None, solver=&apos;liblinear&apos;, tol=0.0001, verbose=0, warm_start=False) 12pred2 = clf.predict(X[:,1:])print('Training set accuracy: &#123;&#125; %'.format(np.mean(pred2 == y.ravel())*100)) Training set accuracy: 96.5 % Neural Networks12345678def predict(theta_1, theta_2, features): z2 = theta_1.dot(features.T) a2 = np.c_[np.ones((data['X'].shape[0],1)), sigmoid(z2).T] z3 = a2.dot(theta_2.T) a3 = sigmoid(z3) return(np.argmax(a3, axis=1)+1) 12pred = predict(theta1, theta2, X)print('Training set accuracy: &#123;&#125; %'.format(np.mean(pred == y.ravel())*100)) Training set accuracy: 97.52 % Summary展示图片因为给的数据是矩阵的形式，所以需要分为单个向量，重新设置形状。然后展示出来，跟手写字体识别是很像。 12345678%matplotlib inlineimport scipy.io as sio import matplotlib.pyplot as pltmatfn='C:/Users/wing/Documents/MATLAB/ex3/ex3data1.mat' data=sio.loadmat(matfn) im = data['X'][0]im = im.reshape(20,20)plt.imshow(im , cmap='gray') mark 如果想要一次展示多个图像呢，写个循环就可以了。不过太多的话，可能就看不清了。。1234567im = []for i in range(500): plt.subplot(10, 50, i + 1) temp = data['X'][i] im.append(temp.reshape(20,20)) plt.imshow(im[i], cmap='gray')plt.show() reshape内-1的用法官方文档：numpy.reshape - NumPy v1.11 Manual 12345&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])&gt;&gt;&gt; np.reshape(a, (3,-1)) # the unspecified value is inferred to be 2array([[1, 2], [3, 4], [5, 6]]) -1表示我懒得计算该填什么数字，由python通过a和其他的值推测出来。 LogisticRegressionfrom sklearn.linear_model import LogisticRegression http://www.cnblogs.com/xupeizhi/archive/2013/07/05/3174703.htmlhttp://scikit-learn.org/stable/index.html","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Coursera ML(6)-Neural Networks Representation","slug":"Coursera-ML-6-Neural-Networks-Representation","date":"2017-04-15T13:42:33.000Z","updated":"2017-04-15T13:47:22.229Z","comments":true,"path":"2017/04/15/Coursera-ML-6-Neural-Networks-Representation/index.html","link":"","permalink":"http://feiyang.li/2017/04/15/Coursera-ML-6-Neural-Networks-Representation/index.html","excerpt":"神经网络模型","text":"神经网络模型 Neural Networks ModelA single neuron model: logistic unit $$\\begin{bmatrix}x_0 \\newline x_1 \\newline x_2 \\newline \\end{bmatrix}\\rightarrow\\begin{bmatrix}\\ \\ \\ \\newline \\end{bmatrix}\\rightarrow h_\\theta(x)$$ Takes 3+1 inputs(the extra input called bias is just like $θ_0$ in logistic regression, not shown in picture). Both input and output could be represented as vectors, in which each unit has its own parameters $θ$ All the units in the same layer take the same input $x$, as the pic shows. Each unit has only one output: $sigmoid(θ^Tx)$. Of course there’re other choices for sigmoid function. Neural Networks $$\\begin{bmatrix}x_0 \\newline x_1 \\newline x_2 \\newline x_3\\end{bmatrix}\\rightarrow\\begin{bmatrix}a_1^{(2)} \\newline a_2^{(2)} \\newline a_3^{(2)} \\newline \\end{bmatrix}\\rightarrow h_\\theta(x)$$ 其中 $$\\begin{align*}& a_i^{(j)} = \\text{\"activation\" of unit $i$ in layer $j$} \\newline& \\Theta^{(j)} = \\text{matrix of weights controlling function mapping from layer $j$ to layer $j+1$}\\end{align*}$$ Calculation from one layer to the next In the picture above, we have the networks from layer j to layer j+1, in which layer j has 3(+1) units while layer j+1 has 3 layers. Let $s_j=3$, $s_j+1=3$ $α^{(j)}$ : Output of the $j_{th}$ layer. $s_j+1$ dimension vector. $θ_i^{(j)}$ : Parameters in the $i{th}$ unit of $(j+1){th}$ layer. $s_j+1$ dimension vector. ${\\theta^{(j)}} = \\begin{bmatrix} \\theta_1^{(j)} & \\theta_2^{(j)} & \\cdots & \\theta_{s_(j + 1)}^{(j)} \\end{bmatrix}^T$ : All the network parameters from $j{th}$ layer to ${(j+1)}{th}$ layer. We have: $\\alpha^{(j+1)} = sigmoid(\\mathbf{\\theta^{(j)}}\\alpha^{(j)})$ add $\\alpha_0^{(j+1)}$ Multiclass Classification 分类器 Each $y^{(i)}$ represents a different image corresponding to either a car, pedestrian, truck, or motorcycle. The inner layers, each provide us with some new information which leads to our final hypothesis function. The setup looks like: Summary Example: layer 1 has 2 input nodes and layer 2 has 4 activation nodes. Dimension of $\\Theta^{(1)}$ is going to be 4×3 where $s_j = 2$ and $s_{j+1} = 4$, so $s_{j+1} \\times (s_j + 1) = 4 \\times 3$$ 今天苏州的天气真是闷热，实在是看不下去了。因此本小节笔记，有大段参考自 shawnau.github.io","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Coursera ML(5)-Logistic Regression and Regularization with Python","slug":"Coursera-ML-5-Programming-Exercise-2","date":"2017-03-30T04:46:00.000Z","updated":"2017-04-15T12:16:09.671Z","comments":true,"path":"2017/03/30/Coursera-ML-5-Programming-Exercise-2/index.html","link":"","permalink":"http://feiyang.li/2017/03/30/Coursera-ML-5-Programming-Exercise-2/index.html","excerpt":"线性回归算法，可用于房屋价格的估计及股票市场分析。 Logistic Regression （逻辑回归）是当前业界比较常用的机器学习方法，用于估计某种事物的可能性。比如某用户购买某商品的可能性，某病人患有某种疾病的可能性，以及某广告被用户点击的可能性等。相关公式推导在这里","text":"线性回归算法，可用于房屋价格的估计及股票市场分析。 Logistic Regression （逻辑回归）是当前业界比较常用的机器学习方法，用于估计某种事物的可能性。比如某用户购买某商品的可能性，某病人患有某种疾病的可能性，以及某广告被用户点击的可能性等。相关公式推导在这里 Stanford coursera Andrew Ng 机器学习课程编程作业（Exercise 2），作业下载链接貌似被墙了，下载链接放这。http://home.ustc.edu.cn/~mmmwhy/machine-learning-ex2.zip 预备知识这里应该分为 正常、过拟合和欠拟合，三种情况。 Cost Function $$J(\\theta) = - \\frac{1}{m} \\sum_{i=1}^m \\large[ y^{(i)}\\ \\log (h_\\theta (x^{(i)})) + (1 - y^{(i)})\\ \\log (1 - h_\\theta(x^{(i)}))\\large] + \\frac{\\lambda}{2m}\\sum_{j=1}^n \\theta_j^2$$ Gradient Descent $$\\begin{align*} & \\text{Repeat}\\ \\lbrace \\newline & \\ \\ \\ \\ \\theta_0 := \\theta_0 - \\alpha\\ \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\newline & \\ \\ \\ \\ \\theta_j := \\theta_j - \\alpha\\ \\left[ \\left( \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \\right) + \\frac{\\lambda}{m}\\theta_j \\right] &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j \\in \\lbrace 1,2...n\\rbrace\\newline & \\rbrace \\end{align*}$$ Grad $$Grad = \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)}+ \\frac{\\lambda}{m}\\theta_j$$ 后边有一个$\\frac{\\lambda}{2m}\\sum_{j=1}^n \\theta_j^2$和$\\frac{\\lambda}{m}\\theta_j$小尾巴，作用就是进行 Regularization，防止拟合过度。 Logistic Regression题目介绍 you will build a logistic regression model to predict whether a student gets admitted into a university.（根据各科目分数预测该学生是否能录取） For each training example, you have the applicant’s scores on two exams and the admissions decision. Your task is to build a classi cation model that estimates an applicant’s probability of admission based the scores from those two exams. dataset python code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from numpy import *import matplotlib.pyplot as pltfrom scipy import optimizedef init(path): X,y = load_dataset(path) # 调用底下那个东西 m, n = shape(X) initial_theta = zeros(n + 1) return X,y,m,n,initial_theta def load_dataset(path): data = loadtxt(path, delimiter=',') X = data[:,:2] y = data[:, 2] return X,ydef plotData(X,y): plt.plot(X[y==1][:,0],X[y==1][:,1],'k+',linewidth=2,) plt.plot(X[y==0][:,0],X[y==0][:,1],'ko',color='y',linewidth=2) plt.xlabel('科目一成绩', fontproperties='SimHei') plt.ylabel('科目二成绩', fontproperties='SimHei') plt.title('分数与录取的关系', fontproperties='SimHei') def sigmoid(X, theta): return 1 / (1 + exp(-dot(X, theta)))def get_cost(theta, X, y): J = sum((-y*log(sigmoid(X,theta)) - (1-y)*log(1-sigmoid(X,theta))))/len(X) return Jdef get_grad(theta, X, y): return (sigmoid(X,theta) - mat(y))*X*(1/m)def plotDecisionBoundary(theta, X, y): plotData(X[:, 1:3], y) if X.shape[1] &lt;= 3: plot_x = r_[X[:,2].min()-2, X[:,2].max()+2] plot_y = - (theta[1]*plot_x + theta[0])/theta[2] plt.plot(plot_x, plot_y) plt.axis([30,100,30,100]) plt.legend(['Accepted', 'Not Accepted', 'Decision Boundary']) plt.show() else: pass def predict(theta, X): prob = sigmoid([1,45,85] , result[0]) return prob if __name__==\"__main__\": path = 'C:\\\\Users\\\\wing\\\\Desktop\\\\machine-learning-ex2\\\\ex2\\\\ex2data1.txt' X,y,m,n,initial_theta = init(path) X = column_stack((ones(m), X)) cost = get_cost(initial_theta, X, y) grad = get_grad(initial_theta, X, y) # obtain the optimal theta result = optimize.fmin_tnc(func=get_cost, x0=initial_theta, fprime=get_grad, args=(X, y)) get_cost(result[0], X, y) # result = (array([-25.16131863, 0.20623159, 0.20147149]), 36, 0) # get_cost(result[0], X, y) = 0.20349770158947464 plotDecisionBoundary(result[0], X, y) print('For a student with scores 45 and 85, we predict an admission ' \\ 'probability of %f\\n'%predict(result[0], X))# For a student with scores 45 and 85, we predict an admission probability of 0.776291 运行结果 最后进行了一个测试，如果一个学生两门考试成绩，一门45分，另外一门85分，那么他被录取的概率为77%。幸亏是在外国，在中国这分数，连大专都考不上。 Logistic Regression and Regularization题目 Suppose you are the product manager of the factory and you have the test results for some microchips on two di erent tests. 对于一批产品，有两个检测环节，通过检测结果判断产品是否合格。比如，宜家会有三十年床垫保证，那么如果确保床垫合格（用30年），我们只能通过一些检测，来推测产品是否合格。 python code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from numpy import *import matplotlib.pyplot as pltfrom scipy import optimizedef init(path): X,y = load_dataset(path) dataplot(X,y) X = map_feature(X[:,0], X[:,1]) initial_theta = zeros(size(X[1])) lam = 1 return X,y,initial_theta,lamdef load_dataset(path): data = loadtxt(path, delimiter=',') X = data[:,:2] y = data[:, 2] return X,y def dataplot(X,y): plt.plot(X[y==1][:,0],X[y==1][:,1],'k+',linewidth=2) plt.plot(X[y==0][:,0],X[y==0][:,1],'ko',color='y',linewidth=2) plt.legend([ 'y = 1','y = 0'])def sigmoid(X, theta): return 1 / (1 + exp(-dot(X, theta)))def map_feature(x1, x2): #X1, X2, X1 ** 2, X2 ** 2, X1*X2, X1*X2 ** 2, etc... x1.shape = (x1.size, 1) x2.shape = (x2.size, 1) degree = 6 out = ones(shape=(x1[:, 0].size, 1)) m, n = out.shape for i in range(1, degree + 1): for j in range(i + 1): r = (x1 ** (i - j)) * (x2 ** j) out = append(out, r, axis=1) return outdef get_cost(theta, X, y,lam): hx = sigmoid(X,theta) thetaR = theta[1:] J = sum((-y*log(hx) - (1-y)*log(1-hx)))/len(X) \\ + (lam / (2.0 * len(X))) * (thetaR.T.dot(thetaR)) return Jdef get_grad(theta, X, y,lam): reg = (lam/len(y))*theta reg[0] = 0 grad = X.T.dot(sigmoid(X,theta)-y)/len(y)+reg return graddef plotDecisionBoundary(theta,lam): u = linspace(-1, 1.5, 50) v = linspace(-1, 1.5, 50) z = zeros(shape=(len(u), len(v))) for i in range(len(u)): for j in range(len(v)): z[i, j] = (map_feature(array(u[i]), array(v[j])).dot(array(theta))) z = z.T plt.contour(u, v, z) plt.title('lambda = %f' % lam) plt.xlabel('Microchip Test 1') plt.ylabel('Microchip Test 2') plt.axis([-0.85,1.1,-0.85,1.1]) plt.legend(['y = 1', 'y = 0', 'Decision boundary']) plt.show() if __name__==\"__main__\": path = 'C:\\\\Users\\\\wing\\\\Desktop\\\\machine-learning-ex2\\\\ex2\\\\ex2data2.txt' X,y,initial_theta,lam = init(path) result = optimize.fmin_tnc(func=get_cost, x0=initial_theta, fprime=get_grad, args=(X, y,lam)) plotDecisionBoundary(result[0],lam) 运算结果 过拟合lambda=0。不考虑 $\\frac{\\lambda}{2m}\\sum_{j=1}^n \\theta_j^2$和$\\frac{\\lambda}{m}\\theta_j$ ，我们可以看到图像已经被拟合过度。这样的答案没有通用性 欠拟合lambda=10，欠拟合会导致数据的很多细节被抛弃。 拟合较好lambda=1，准确性到91%左右，这个准确率算低的了吧，还有很大上升空间。 Summary熊辉上课的时候，说机器学习需要调参数，参数很不好调，需要使用者对数据有极高的敏感度。 参数lambda就是这种感觉，感觉真的是乱调一通，然后就发现，诶哟，好像还不错。 参考链接：scipy.optimize.minimizeLogistic regressionMachine Learning Exercises In Python, Part 3machine-learning-with-python-logistic 以上","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Coursera ML(4)-Logistic Regression","slug":"Coursera-ML-4-Logistic-Regression","date":"2017-03-27T11:13:38.000Z","updated":"2017-03-28T07:49:36.625Z","comments":true,"path":"2017/03/27/Coursera-ML-4-Logistic-Regression/index.html","link":"","permalink":"http://feiyang.li/2017/03/27/Coursera-ML-4-Logistic-Regression/index.html","excerpt":"本节笔记对应第三周Coursera课程 binary classification problem","text":"本节笔记对应第三周Coursera课程 binary classification problem Classification is not actually a linear function. Classification and RepresentationHypothesis Representation Sigmoid Function(or we called Logistic Function) $$\\begin{align*}& h_\\theta (x) = g ( \\theta^T x ) \\newline \\newline& z = \\theta^T x \\newline& g(z) = \\dfrac{1}{1 + e^{-z}}\\end{align*}$$ Sigmoid Function 可以使输出值范围在$(0,1)$之间。$g(z)$对应的图为： $h_\\theta(x)$ will give us the probability that our output is 1. Some basic knowledge of discrete $$\\begin{align*}& h_\\theta(x) = P(y=1 | x ; \\theta) = 1 - P(y=0 | x ; \\theta) \\newline& P(y = 0 | x;\\theta) + P(y = 1 | x ; \\theta) = 1\\end{align*}$$ Decision Boundary translate the output of the hypothesis function as follows: $$\\begin{align*}& h_\\theta(x) \\geq 0.5 \\rightarrow y = 1 \\newline& h_\\theta(x) < 0.5 \\rightarrow y = 0 \\newline\\end{align*}$$ From these statements we can now say: $$\\begin{align*}& \\theta^T x \\geq 0 \\Rightarrow y = 1 \\newline& \\theta^T x < 0 \\Rightarrow y = 0 \\newline\\end{align*}$$ Logistic Regression ModelCost function for one variable hypothesis To let the cost function be convex for gradient descent, it should be like this: $$J(\\theta) = \\dfrac{1}{m} \\sum_{i=1}^m \\mathrm{Cost}(h_\\theta(x^{(i)}),y^{(i)})$$ $$Cost(h_\\theta (x), y) =\\begin{cases}-log(h_\\theta (x)), (y = 1) \\\\-log(1 - h_\\theta (x)), (y = 0) \\\\\\end{cases}$$ example $$\\begin{align*}& \\mathrm{Cost}(h_\\theta(x),y) = 0 \\text{ if } h_\\theta(x) = y \\newline & \\mathrm{Cost}(h_\\theta(x),y) \\rightarrow \\infty \\text{ if } y = 0 \\; \\mathrm{and} \\; h_\\theta(x) \\rightarrow 1 \\newline & \\mathrm{Cost}(h_\\theta(x),y) \\rightarrow \\infty \\text{ if } y = 1 \\; \\mathrm{and} \\; h_\\theta(x) \\rightarrow 0 \\newline \\end{align*}$$ Simplified Cost Function and Gradient Descent compress our cost function’s two conditional cases into one case: $$\\mathrm{Cost}(h_\\theta(x),y) = - y \\; \\log(h_\\theta(x)) - (1 - y) \\log(1 - h_\\theta(x))$$ entire cost function $$J(\\theta) = - \\frac{1}{m} \\displaystyle \\sum_{i=1}^m [y^{(i)}\\log (h_\\theta (x^{(i)})) + (1 - y^{(i)})\\log (1 - h_\\theta(x^{(i)}))]$$ Gradient Descent the general form of gradient descent ，求偏导的得到$J(\\theta)$的极值 $$\\begin{align*}& Repeat \\; \\lbrace \\newline & \\; \\theta_j := \\theta_j - \\alpha \\dfrac{\\partial}{\\partial \\theta_j}J(\\theta) \\newline & \\rbrace\\end{align*}$$ using calculus $$\\frac{\\partial}{\\partial \\theta_j} J(\\theta) = \\frac{1}{m}\\sum\\limits_{i=1}^{m}[(h_\\theta (x^{(i)}) - y^{(i)})x_j^{(i)}]$$ get $$\\begin{align*} & Repeat \\; \\lbrace \\newline & \\; \\theta_j := \\theta_j - \\frac{\\alpha}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} \\newline & \\rbrace \\end{align*}$$ Multiclass Classification: One-vs-all For more than 2 features of y, do logisitc regression for each feature separately Train a logistic regression classifier $h_\\theta(x)$ for each class￼ to predict the probability that ￼ ￼y = i￼ ￼. To make a prediction on a new x, pick the class ￼that maximizes $ h_\\theta (x) $ Solving the Problem of OverfittingThe Problem of Overfitting address the issue of overfitting Reduce the number of features: Manually select which features to keep. Use a model selection algorithm (studied later in the course). Regularization: Keep all the features, but reduce the magnitude of parameters $θ_j$. Regularization works well when we have a lot of slightly useful features. Cost Function in a single summation $$min_\\theta\\ \\dfrac{1}{2m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})^2 + \\lambda\\ \\sum_{j=1}^n \\theta_j^2$$ The λ, or lambda, is the regularization parameter. It determines how much the costs of our theta parameters are inflated. Regularized Linear Regression Gradient Descent $$\\begin{align*} & \\text{Repeat}\\ \\lbrace \\newline & \\ \\ \\ \\ \\theta_0 := \\theta_0 - \\alpha\\ \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\newline & \\ \\ \\ \\ \\theta_j := \\theta_j - \\alpha\\ \\left[ \\left( \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \\right) + \\frac{\\lambda}{m}\\theta_j \\right] &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j \\in \\lbrace 1,2...n\\rbrace\\newline & \\rbrace \\end{align*}$$ Normal Equation $$\\begin{align*}& \\theta = \\left( X^TX + \\lambda \\cdot L \\right)^{-1} X^Ty \\newline& \\text{where}\\ \\ L = \\begin{bmatrix} 0 & & & & \\newline & 1 & & & \\newline & & 1 & & \\newline & & & \\ddots & \\newline & & & & 1 \\newline\\end{bmatrix}\\end{align*}$$ L is a matrix with 0 at the top left and 1’s down the diagonal, with 0’s everywhere else. It should have dimension (n+1)×(n+1) Recall that if m ≤ n, then $X^TX$ is non-invertible. However, when we add the term λ⋅L, then $X^TX + λ⋅L $becomes invertible. Summary我在这里整理一下上述两个方法，补全课程上的相关推导。 Logistic Regression Model$h_\\theta(x)$是假设函数 $$h_\\theta (x) = g ( \\theta^T x ) = \\dfrac{1}{1 + e^{- \\theta^T x}} $$ 注意假设函数和真实数据之间的区别 Cost Function $$J(\\theta) = - \\frac{1}{m} \\sum_{i=1}^m \\large[ y^{(i)}\\ \\log (h_\\theta (x^{(i)})) + (1 - y^{(i)})\\ \\log (1 - h_\\theta(x^{(i)}))\\large]$$ 回头看看上边的那个$h_\\theta (x)$ ，cost function定义了训练集给出的结果 和 当前计算结果之间的差距。当然，该差距越小越好，那么需要求导一下。 Gradient Descent 原始公式 $$\\theta_j := \\theta_j - \\alpha \\dfrac{\\partial}{\\partial \\theta_j}J(\\theta)$$ 求导计算 $$\\frac{\\partial}{\\partial \\theta_j} J(\\theta) = \\frac{1}{m}\\sum\\limits_{i=1}^{m}[(h_\\theta (x^{(i)}) - y^{(i)})x_j^{(i)}]$$ 计算结果 $$\\theta_j := \\theta_j - \\frac{\\alpha}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} $$ 这里推导一下$\\frac{\\partial}{\\partial \\theta_j} J(\\theta)$： 计算$h_\\theta’(x)$导数 $$\\begin{align*} &h_\\theta'(x) = ( \\frac1{1+e^{- \\theta x}})'\\newline &\\ \\ \\ \\ \\ \\ \\ \\ = \\frac{e^{- \\theta x}x}{1+e^{- \\theta x}}\\newline &\\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1+e^{- \\theta x}-1}{(1+e^{- \\theta x})^2}x\\newline &\\ \\ \\ \\ \\ \\ \\ \\ = \\large[\\frac{1}{1+e^{- \\theta x}}-\\frac{1}{(1+e^{- \\theta x})^2}\\large]x\\newline &\\ \\ \\ \\ \\ \\ \\ \\ = h_\\theta(x)(1-h_\\theta(x))x \\end{align*}$$ 推导$\\frac{\\partial}{\\partial \\theta_j} J(\\theta)$ $$\\begin{align*} &\\frac{\\partial}{\\partial \\theta_j} J(\\theta) = \\frac{\\partial}{\\partial \\theta_j} \\frac{1}{m} \\sum_{i=1}^m \\large[ -y^{(i)}\\ \\log (h_\\theta (x^{(i)})) - (1 - y^{(i)})\\ \\log (1 - h_\\theta(x^{(i)}))\\large] \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1}{m} \\sum_{i=1}^m \\large[ -y^{(i)}\\ \\frac1{h_\\theta(x^{(i)})}h_\\theta'(x^{(i)}) - (1 - y^{(i)}) \\frac{-1}{1-h_\\theta(x^{(i)})}h_\\theta'(x^{(i)})\\large] \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1}{m} \\sum_{i=1}^m \\large[ -y^{(i)}\\ \\frac1{h_\\theta(x^{(i)})}h_\\theta(x^{(i)})(1-h_\\theta(x^{(i)}))x^{(i)} \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ - (1 - y^{(i)}) \\frac{-1}{1-h_\\theta(x^{(i)})}h_\\theta(x^{(i)})(1-h_\\theta(x^{(i)}))x^{(i)}\\large] \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1}{m} \\sum_{i=1}^m \\large[ -y^{(i)}(1-h_\\theta(x^{(i)}) x^{(i)})+(1- y)h_\\theta(x^{(i)}) x^{(i)})\\large] \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1}{m} \\sum_{i=1}^m \\large[ -x^{(i)}y^{(i)}+x^{(i)}y^{(i)}h_\\theta(x^{(i)}) \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ +x^{(i)}h_\\theta(x^{(i)}) - x^{(i)}y^{(i)}h_\\theta(x^{(i)}) \\large] \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1}{m}\\sum\\limits_{i=1}^{m}[(h_\\theta (x^{(i)}) - y^{(i)})x_j^{(i)}] \\end{align*}$$ 即： $$\\begin{align*} &\\frac{\\partial}{\\partial \\theta_j} J(\\theta) = \\frac{1}{m}\\sum\\limits_{i=1}^{m}[(h_\\theta (x^{(i)}) - y^{(i)})x_j^{(i)}] \\end{align*}$$ Solving the Problem of Overfitting其他地方都一样，稍作修改 Cost Function $$J(\\theta) = - \\frac{1}{m} \\sum_{i=1}^m \\large[ y^{(i)}\\ \\log (h_\\theta (x^{(i)})) + (1 - y^{(i)})\\ \\log (1 - h_\\theta(x^{(i)}))\\large] + \\frac{\\lambda}{2m}\\sum_{j=1}^n \\theta_j^2$$ Gradient Descent $$\\begin{align*} & \\text{Repeat}\\ \\lbrace \\newline & \\ \\ \\ \\ \\theta_0 := \\theta_0 - \\alpha\\ \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\newline & \\ \\ \\ \\ \\theta_j := \\theta_j - \\alpha\\ \\left[ \\left( \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \\right) + \\frac{\\lambda}{m}\\theta_j \\right] &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j \\in \\lbrace 1,2...n\\rbrace\\newline & \\rbrace \\end{align*}$$ 以上","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Coursera ML(3)-Multivariate Linear Regression python实现","slug":"Coursera-ML-3-Multivariate-Linear-Regression-python","date":"2017-03-26T11:00:29.000Z","updated":"2017-03-27T11:32:14.121Z","comments":true,"path":"2017/03/26/Coursera-ML-3-Multivariate-Linear-Regression-python/index.html","link":"","permalink":"http://feiyang.li/2017/03/26/Coursera-ML-3-Multivariate-Linear-Regression-python/index.html","excerpt":"Multivariate Linear Regression and Programming Exercise 1","text":"Multivariate Linear Regression and Programming Exercise 1 Gradient Descent for Multiple Variables Suppose we have n variables, set hypothesis to be: Cost Function Gradient Descent Algorithm Get every feature into approximately [-1, 1]. Just normalize all the parameters :) Learning Rate:Not too big(fail to converge), not too small(too slow) Polynormal Regression:Use feature scalling. (Somewhat like normalizing dimension) Programming Exercise 1下载程序及相关数据Stanford coursera Andrew Ng 机器学习课程编程作业（Exercise 1），作业下载链接貌似被墙了，下载链接放这。http://home.ustc.edu.cn/~mmmwhy/machine-learning-ex1.zip 重新推导一下：其实这里一共就两个式子： computeCost $$h_\\theta (x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \\theta_3 x_3 + \\cdots + \\theta_n x_n$$ $$J(\\theta_0,\\theta_1 )=\\frac1{wm} \\sum_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})^w$$ gradientDescent $$\\begin{align*} \\text{repeat until convergence: } \\lbrace & \\newline \\theta_0 := & \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}(h_\\theta(x_{i}) - y_{i}) \\newline \\theta_1 := & \\theta_1 - \\alpha \\frac1m \\sum\\limits_{i=1}^m\\left((h_\\theta(x_i) - y_i) x_i\\right) \\newline \\rbrace& \\end{align*}$$ python拟合实现代码原本用的是matlab代码，我用python实现了一下，结果是一样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import numpy as npimport pandas as pdimport matplotlib.pyplot as pltdef readfile(path): X=[] y=[] with open(path,'r') as f: for line in f: X.append([1,float(line.split(',')[0])]) y.append(float(line.split(',')[1])) return X,ydef dataplot(x,theta,y): plt.plot(x, y, 'rx', markersize=10) plt.ylabel('Profit in $10,000s') plt.xlabel('Population of City in 10,000s') plt.plot(X[:,1],X*theta,'-') plt.show()def computeCost(X,y,theta): m = len(y) J = 0 for i in range(m): J = J + float((X[i]*theta-y[i])**2) return J/(2*m)def gradientDescent(X, y, theta, alpha, num_iters): m = len(y) num_iters = 1500 J_history = np.zeros(num_iters) for i in range(num_iters): S =X.T * (X * theta - np.mat(y).T) / m theta = theta - alpha * S; J_history[i] = computeCost(X,y,theta) return thetaif __name__==\"__main__\": theta = np.mat([[0],[0]]) iterations = 1500 alpha = 0.01 iterations = 1500 path = \"C:\\Users\\wing\\Documents\\MATLAB\\ex1\\ex1data1.txt\" x,y = readfile(path)# 小写的X不是矩阵，是list，大写的X是矩阵。 X = np.mat(x) J = computeCost(X, y, theta) theta = gradientDescent(X, y, theta, alpha, iterations) dataplot(X[:,1],theta,y) 输出的图有点小，就这样吧。","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Coursera ML(2)-Model and Cost Function","slug":"Coursera-ML-2-Model-and-Cost-Function","date":"2017-03-25T10:49:36.000Z","updated":"2017-05-12T02:28:04.638Z","comments":true,"path":"2017/03/25/Coursera-ML-2-Model-and-Cost-Function/index.html","link":"","permalink":"http://feiyang.li/2017/03/25/Coursera-ML-2-Model-and-Cost-Function/index.html","excerpt":"Model and Cost Function / Parameter Learning / Gradient Descent For Linear Regression","text":"Model and Cost Function / Parameter Learning / Gradient Descent For Linear Regression Model and Cost Function Tables Are Hypothesis $$h_{\\theta}={\\theta}_0+{\\theta}_1x$$ Parameter ${\\theta}_0$，${\\theta}_1$ Cost Function $J(\\theta_0,\\theta_1)= \\frac1{2m}\\sum_{i=1}^m(h_{\\theta}(x^i)-y^i)^w$ Goal $minimiseJ(\\theta_0,\\theta_1)$ Model Representation Hypothesis:$$h_{\\theta}={\\theta}_0+{\\theta}_1x$$${\\theta}_0$和${\\theta}_1$称为模型参数 Cost FunctionWe can measure the accuracy of our hypothesis function by using a cost function. his takes an average difference (actually a fancier version of an average) of all the results of the hypothesis with inputs from x’s and the actual output y’s. 如何尽可能的将直线与我们的数据相拟合 Parameter LearningGradient descent idea Turns out, that if you’re standing at that point on the hill, you look all around and you find that the best direction is to take a little step downhill is roughly that direction. Okay, and now you’re at this new point on your hill. You’re gonna, again, look all around and say what direction should I step in order to take a little baby step downhill? And if you do that and take another step, you take a step in that direction. Gradient descent algorithmrepeat until convergence:{ $\\theta_j:=\\theta_j-\\alpha\\frac\\partial{\\partial\\theta_j}J(\\theta_0,\\theta_1)$} use := to denote assignment, so it’s the assignment operator. $\\alpha$ called:learning rate.controls how big a step we take downhill with creating descent. $\\theta_0,\\theta_1 $should be updated simultaneously(using multiple temp var should work!) Gradient Descent For Linear Regression $$\\begin{align*} \\text{repeat until convergence: } \\lbrace & \\newline \\theta_0 := & \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}(h_\\theta(x_{i}) - y_{i}) \\newline \\theta_1 := & \\theta_1 - \\alpha \\frac1m \\sum\\limits_{i=1}^m\\left((h_\\theta(x_i) - y_i) x_i\\right) \\newline \\rbrace& \\end{align*}$$ where m is the size of the training set, $\\theta_0$ a constant that will be changing simultaneously with $\\theta_1$ and $x_i y_i$are values of the given training set (data). The $J(θ_0,θ_1)$ is a convex function, which means it has only one global minimun, which means gradient descent will always hit the best fit “Batch” Gradient Descent: “Batch” means the algo is trained from all the samples every time","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"}]},{"title":"算法导论 第15章 动态规划","slug":"dynamic-programming","date":"2017-03-24T09:05:47.000Z","updated":"2017-05-23T04:43:54.931Z","comments":true,"path":"2017/03/24/dynamic-programming/index.html","link":"","permalink":"http://feiyang.li/2017/03/24/dynamic-programming/index.html","excerpt":"《算法导论》这门课的老师是黄刘生和张曙，两位都是老人家了，代课很慢很没有激情，不过这一章非常有意思。","text":"《算法导论》这门课的老师是黄刘生和张曙，两位都是老人家了，代课很慢很没有激情，不过这一章非常有意思。 前言：书中列举四个常见问题，分析如何采用动态规划方法进行解决。 装配线调度问题 矩阵链乘问题： 最长公共子序列问题： 最优二叉查找树问题： 基本概念动态规划通常应用于最优化问题，此类问题可能包含多个可行解。每个解有一个值，而我们期望找到最大或者最小的解。 动态规划算法的设计可以分为以下4个步骤： 描述最优解的结构。 递归定义最优解的值。 按自底向上的方式计算最优解的值。（其实还应该有自顶向下的求解） 由计算出的结果构造一个最优解。 动态规划算法效率会非常高的原因在于，其特殊的实现方法，也就是第三步。 两种等价的实现方法： 带备忘的自顶向下法，此方法按照正常的递归编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中）。当需要一个子问题的解时，程序首先检查是否已经保存过此解。如果是，直接返回；若不是，递归计算这个子问题。这种递归方式是带备忘的。 自底而上法，这种方法需要恰当的定义子问题的规模，因为任何一个子问题的求解的依赖着更小的子问题。因此需要将问题进行排序，从小的问题开始处理。这样可以确保，在处理到大的问题时，其所依赖的更小的子问题已经求解完毕，结果已经保存。 因此，我们会说 动态规划算法属于典型的用空间换取时间。由于没有频繁的递归函数的开销，自底而上方法的时间复杂度会更好一些。 动态规划与分治法之间的区别： 分治法是指将问题分成一些独立的子问题，递归的求解各子问题。 动态规划适用于这些子问题不是独立的情况，也就是各子问题包含公共子问题。 动态规划基础什么时候可以使用动态规范方法解决问题呢？这个问题需要讨论一下，书中给出了采用动态规范方法的最优化问题中的两个要素：最优子结构和重叠子结构。 最优子结构（自下向上）最优子结构是指问题的一个最优解中包含了其子问题的最优解。在动态规划中，每次采用子问题的最优解来构造问题的一个最优解。 寻找最优子结构，遵循的共同的模式： 问题的一个解可以是做一个选择，得到一个或者多个有待解决的子问题。 假设对一个给定的问题，已知的是一个可以导致最优解的选择，不必关心如何确定这个选择。 在已知这个选择后，要确定哪些子问题会随之发生，如何最好地描述所得到的子问题空间。 利用“剪贴”技术，来证明问题的一个最优解中，使用的子问题的解本身也是最优的。 最优子结构在问题域中以两种方式变化： 有多少个子问题被使用在原问题的一个最优解中。 在决定一个最优解中使用哪些子问题时有多少个选择。 动态规划按照自底向上的策略利用最优子结构，即：首先找到子问题的最优解，解决子问题，然后逐步向上找到问题的一个最优解。 为了描述子问题空间，可以遵循这样一条有效的经验规则，就是尽量保持这个空间简单，然后在需要时再扩充它。 注意：在不能应用最优子结构的时候，就一定不能假设它能够应用。 警惕使用动态规划去解决缺乏最优子结构的问题！ 使用动态规划时，子问题之间必须是相互独立的！可以这样理解，N个子问题域互不相干，属于完全不同的空间。 重叠子问题（自上向下）用来解决原问题的递归算法可以反复地解同样的子问题，而不是总是产生新的子问题。 重叠子问题是指当一个递归算法不断地调用同一个问题。 动态规划算法总是充分利用重叠子问题，通过每个子问题只解一次，把解保存在一个需要时就可以查看的表中，每次查表的时间为常数。 由计算出的结果反向构造一个最优解：把动态规划或者是递归过程中作出的每一次选择（记住：保存的是每次作出的选择）都保存下来，在最后就一定可以通过这些保存的选择来反向构造出最优解。 做备忘录的递归方法：这种方法是动态规划的一个变形，它本质上与动态规划是一样的，但是比动态规划更好理解！ （1） 使用普通的递归结构，自上而下的解决问题。 （2） 当在递归算法的执行中每一次遇到一个子问题时，就计算它的解并填入一个表中。以后每次遇到该子问题时，只要查看并返回表中先前填入的值即可。 钢条切割问题题目 给定一个长度为n的钢条，以及一个价格表p，p中列出了每英寸钢条的价格，将长度为n的钢条切割为若干短钢条出售，求一个钢条的切割方案，使得收益最大，切割工序没有成本。比如价格表p如下： 长度为n的钢条，一共有$2^{n-1}$种不同的切割方案，因为可以再距离钢条左边为i（i=1,2,…,n-1）处，我们总是可以选择切割或者不切割。比如下图表示了n=4的切割情况： mark 理论依据我们称钢条切割问题满足最优子结构性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。 我们可以这样理解钢条问题：将钢条从左边切下一段长度为i的一段，对剩下的n-i的部分继续进行切割（递归求解），而不对左边长度为i的一段在进行切割。 这样问题的解就转化为最优解了。 自顶向下递归实现1234567CUT-ROD(p,n)if n == 0 return 0q = -∞for i = 1 to n q = max(q, p[i]+CUT-ROD(p, n-i))return q CUT-ROD的效率很差，这是因为CUT-ROD反复的求解一些相同的子问题，下图显示了当n==4时的调用情况： 带备忘的自顶向下12345678910111213141516MEMOIZED-CUT-ROD(p,n)let r[0..n] be a new arrayfor i = 0 to n r[i]= -∞return MEMOIZED-CUT-ROD-AUX(p, n, r) MEMOIZED-CUT-ROD-AUX(p,n, r)if r[n] &gt;= 0 return r[n]if n == 0 q = 0else q = -∞ for i = 1 to n q= max(q, p[i]+MEMOIZED-CUT-ROD-AUX(p, n-i,r))r[n] = qreturn q 该方法与之前的普通递归方法类似，只是会在过程中保存子问题的解，当需要一个子问题的解的时候，先查看是否已经保存过了，如果是，则直接使用即可。否则，按常规的递归方式计算子问题。所以称为带备忘的，因为它记住了之前已经计算出的结果。 自底向上的方法123456789BOTTOM-UP-CUT-ROD(p,n)let r[0..n] be a new arrayr[0]= 0for j = 1 to n q= -∞ for i = 1 to j q = max(q, p[i]+r[j-i]) r[j]= qreturn r[n] 方法采用子问题的自然顺序，因此过程中依次求解规模为$j=0,1,2,3,4…,n$的问题。 这两种算法具有相同的时间复杂度，BOTTOM-UP-CUT-ROD主要是双层嵌套循环，所以时间复杂度$Θ(n^2)$。MEMOIZED-CUT-ROD的时间复杂度也是$Θ(n^2)$。可以使用子问题图进行分析。 python实现切割钢条问题1234567891011121314151617181920def cut_rod(): p = [0,1,5,8,9,10,17,17,20,24,30] n = len(p) r = [0 for i in range(n)] s = [0 for i in range(n)] for j in range(n): q = -10 for i in range(j+1): if q &lt; (p[i]+r[j-i]): q = (p[i]+r[j-i]) s[j] = i #q = max(q,p[i]+r[j-i]) r[j] = q def find_way(n): cut_rod() print(n,'---&gt;',r[n]) while n &gt; 0: print(s[n]) n = n - s[n] 调用find_way(9)输出 矩阵链乘法题目给定n 个矩阵的序列，希望求它们的乘积：$A_1A_2A_3…A_n$ 。因为矩阵的乘法满足结合律，所以可以对n个矩阵序列加括号，来改变乘积顺序。比如对于矩阵链&lt; $A_1$, $A_2$,$A_3$,$A_4$&gt;可以有下面的加括号方案： 不同的加括号的方案，对于乘积运算的代价影响很大. 两个矩阵相乘，A为p q矩阵，B为q r矩阵。所以A 的乘法次数为pqr。 如果A（10,100 ），B（100,5）， C（5,50 ）三个矩阵相乘。 如果按照((AB)C)的顺序，则需要101005 + 10550 = 7500次乘法运算，如果按照(A(BC))的顺序，则需要100550 + 1010050 = 75000次乘法运算。所以，不同的加括号方案，对于矩阵链乘法的代价影响很大。 刻画最优解的结构特征通过寻找最优子结构，利用最优子结构从子问题的最优解中构造出原问题的最优解。假设$AiA{i+1}…A_j$的最优括号花方案的分割点是在$Ak$和$A{K+1}$之间，一个非平凡的矩阵链乘法任何时候都是需要划分链的，任何最优解都是有子问题的最优解构成的。 递归的定义最优解的值 令 $m[i,j] $表示计算矩阵 $A_{i,j} $所需标量乘法的最小值，也即原问题的最优解，计算$ A_{1..n} $的最低代价就是 $m[1,n]$ 对于i == j 的平凡问题，矩阵链只包含唯一的矩阵$A_{i,j}$。 对于 $A_i A_{i+1}...A_j$ 的最优括号化方案的切割点在 $A_k$和$A_{k+1}$之间。那么$m[i,j]$的解相当于计算$A_{i..k}$和$A_{k+1..j}$的代价加上，合并这两个子答案所需要的代价$p_{i-1}p_k p_j$ 因此，我们得到 $$m[i,j] = m[i,k]+m[k,j]+p_{i-1}p_k p_j$$ 计算最优解的值算法应当按照长度递增的顺序求解矩阵链括号化问题，并按照对应的顺序填写表m。对举证连$A_{i,j}$，其规模为链的长度j-i+1 伪代码就不写了，直接写python代码 python实现矩阵链乘法问题1234567891011121314151617181920212223242526272829303132def MATRIX_CHAIN_ORDER(p): n = len(p) s = [[0 for j in range(n)] for i in range(n)] m = [[0 for j in range(n)] for i in range(n)] for l in range(2, n): #l is the chain length for i in range(1, n-l+1): j = i + l - 1 m[i][j] = 1e9 for k in range(i, j): q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j] if q &lt; m[i][j]: m[i][j] = q s[i][j] = k PRINT_OPTIMAL_PARENS(s, 1, n-1) return m def PRINT_OPTIMAL_PARENS(s, i, j): if i == j: print('A', end = '') print(i, end = '') else: print('(', end = '') PRINT_OPTIMAL_PARENS(s, i, s[i][j]) PRINT_OPTIMAL_PARENS(s, s[i][j]+1, j) print(')', end = '') if __name__ == \"__main__\": A = [30, 35, 15, 5, 10, 20,25] m = MATRIX_CHAIN_ORDER(A) print('\\n','共计需要',m[1][n-1],'次相乘') 需要注意的问题是，这个算法的复杂度在O(n∧3)。而且这个算法和算法导论等地方的伪码比有些细微的差异体现在数组从0开始还是1开始上。大体上还是一致的。这里的空间复杂度也到了O(n∧2)。大致的计算顺序就是通过这个函数中的l来控制。l=2的时候，依次计算矩阵A[0]A[1], A[1]A[2], A[2]A[3]…的次数。l=3的时候就开始计算A[0]A[1]A[2], A[1]A[2]*A[3]..的次数。用更形象的话来说就是倒三角的顺序。下面的这个图就是对上面流程的描述： 以上","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://feiyang.li/tags/dynamic-programming/"}]},{"title":"Python读取mnist","slug":"python-mnist","date":"2017-03-17T08:25:27.000Z","updated":"2017-03-26T11:39:21.829Z","comments":true,"path":"2017/03/17/python-mnist/index.html","link":"","permalink":"http://feiyang.li/2017/03/17/python-mnist/index.html","excerpt":"在做 TensorFlow和Python实现神经网络的时候，需要利用到一个MNIST数据集，数据集的格式是以.idx1-ubyte后缀，包含60000个训练图像。将这些图像展示出来，需要利用到struct模块。","text":"在做 TensorFlow和Python实现神经网络的时候，需要利用到一个MNIST数据集，数据集的格式是以.idx1-ubyte后缀，包含60000个训练图像。将这些图像展示出来，需要利用到struct模块。 下载MNIST训练数据集手动下载下载链接为： http://yann.lecun.com/exdb/mnist/ 下载好之后解压就可以了，网站好像被墙了？ mark 使用tensorflow自带下载可以看到，这个地方是有监督学习 (有label这个东西嘛)12345678from tensorflow.examples.tutorials.mnist import input_data# 下载mnist数据集mnist = input_data.read_data_sets('/tmp/', one_hot=True)# 数字(label)只能是0-9，神经网络使用10个出口节点就可以编码表示0-9；# 1 -&gt; [0,1.0,0,0,0,0,0,0,0] one_hot表示只有一个出口节点是hot# 2 -&gt; [0,0.1,0,0,0,0,0,0,0]# 5 -&gt; [0,0,0,0,0,1.0,0,0,0]# /tmp是macOS的临时目录，重启系统数据丢失; Linux的临时目录也是/tmp 详细步骤读取文件12with open(filename ,'rb') as f1: buf1 = f1.read() 还有另外一种常用的方法，两个方法目前来看没有什么区别。12f1 = open(filename , 'rb')buf = binfile.read() # 先使用二进制方式把文件都读进来 跨过头部区域train-images-idx3-ubyte1234567891011TRAINING SET IMAGE FILE (train-images-idx3-ubyte):[offset] [type] [value] [description] 0000 32 bit integer 0x00000803(2051) magic number 0004 32 bit integer 60000 number of images 0008 32 bit integer 28 number of rows 0012 32 bit integer 28 number of columns 0016 unsigned byte ?? pixel 0017 unsigned byte ?? pixel ........ xxxx unsigned byte ?? pixel 可以看到头部有4个integer 类型，设置image_index += struct.calcsize(&#39;&gt;IIII&#39;)计算4个integer 值的位置，然后image_index 直接跳过去。至于为什么用IIII，愿意的话可以点击了解。 123temp = struct.unpack_from('&gt;784B', buf1, image_index) # '&gt;784B'的意思就是用大端法读取784( 28*28 )个unsigned byteim = np.reshape(temp,(28,28)) 最后那句np.reshape(temp,(28,28))是以下两句的缩写12im = np.array(im)im = im.reshape(28,28) train-labels-idx1-ubyte可以看到头部有2个integer 类型，同理，label_index 直接跳过去。12345678910TRAINING SET LABEL FILE (train-labels-idx1-ubyte):[offset] [type] [value] [description] 0000 32 bit integer 0x00000801(2049) magic number (MSB first) 0004 32 bit integer 60000 number of items 0008 unsigned byte ?? label 0009 unsigned byte ?? label ........ xxxx unsigned byte ?? labelThe labels values are 0 to 9. 显示图片1plt.imshow(im , cmap='gray') 应该就可以看到图片了，是一张5， 当然头部文件还是要有的12345678910111213%matplotlib inlineimport numpy as npimport structimport matplotlib.pyplot as pltpath = 'E:\\\\Machine Learning\\\\train-images.idx3-ubyte'with open(path,'rb') as f1: buf1 = f1.read() image_index = 0image_index += struct.calcsize('&gt;IIII')temp = struct.unpack_from('&gt;784B', buf1, image_index) # '&gt;784B'的意思就是用大端法读取784( 28*28 )个unsigned byteim = np.reshape(temp,(28,28))plt.imshow(im , cmap='gray') give me 5 多张图片读取 多张图片 12345678910111213141516171819202122232425262728293031323334353637383940414243# coding=utf-8import numpy as npimport structimport matplotlib.pyplot as pltdef readfile(): with open('E:\\\\Machine Learning\\\\train-images.idx3-ubyte','rb') as f1: buf1 = f1.read() with open('E:\\\\Machine Learning\\\\train-labels.idx1-ubyte','rb') as f2: buf2 = f2.read() return buf1, buf2def get_image(buf1): image_index = 0 image_index += struct.calcsize('&gt;IIII') im = [] for i in range(9): temp = struct.unpack_from('&gt;784B', buf1, image_index) # '&gt;784B'的意思就是用大端法读取784个unsigned byte im.append(np.reshape(temp,(28,28))) image_index += struct.calcsize('&gt;784B') # 每次增加784B return imdef get_label(buf2): # 得到标签数据 label_index = 0 label_index += struct.calcsize('&gt;II') return struct.unpack_from('&gt;9B', buf2, label_index)if __name__ == \"__main__\": image_data, label_data = readfile() im = get_image(image_data) label = get_label(label_data) for i in range(9): plt.subplot(3, 3, i + 1) title = u\"标签对应为：\"+ str(label[i]) plt.title(title, fontproperties='SimHei') plt.imshow(im[i], cmap='gray') plt.show() 遇到的一些坑： 中文标题乱码的问题 1plt.title(title, fontproperties='SimHei') # 后边这个字体**SimHei**加上就好了 标题内部不能用+在外部加好之后，赋值给新变量，然后放进title即可","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"细究Python struct 模块","slug":"python-struct","date":"2017-03-17T06:08:07.000Z","updated":"2017-03-26T11:39:20.941Z","comments":true,"path":"2017/03/17/python-struct/index.html","link":"","permalink":"http://feiyang.li/2017/03/17/python-struct/index.html","excerpt":"struct — Interpret bytes as packed binary data，将字节与二进制文件相互转化的工具Python struct 模块。","text":"struct — Interpret bytes as packed binary data，将字节与二进制文件相互转化的工具Python struct 模块。 关于格式字符串在Python手册中，给出了C语言中常用类型与Python类型对应的格式符： 格式符 C语言类型 Python类型 x pad byte no value c char string of length 1 b signed char integer B unsigned char integer ? _Bool bool h short integer H unsigned short integer i int integer I unsigned int integer or long l long integer L unsigned long long q long long long Q unsigned long long long f float float d double float s char[] string p char[] string P void * struct.pack(fmt, v1, v2, …) Return a string containing the values v1, v2, … packed according to the given format. The arguments must match the values required by the format exactly. struct.pack用于将Python的值根据格式符，转换为字符串,准确来说是Byte。这个地方我们之前有提过，Python3内的unicode和bytes，在Py3内文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。 Py2是没有Byte这么个东西的。参数fmt是格式字符串，v1, v2, …表示要转换的python值。下面的例子将两个整数转换为字符串: 12345678910111213141516import struct a = 20 b = 400byte = struct.pack(\"ii\", a, b) #转换后的str相当于其他语言中的字节流（字节数组），可以在网络上传输 big = struct.pack(\"&gt;ii\", a, b) #大端保存small = struct.pack(\"&lt;ii\", a, b) #小端保存print(byte)# &gt;&gt;&gt;:b'\\x14\\x00\\x00\\x00\\x90\\x01\\x00\\x00'print(big)# &gt;&gt;&gt;:b'\\x00\\x00\\x00\\x14\\x00\\x00\\x01\\x90'print(small)# &gt;&gt;&gt;:b'\\x14\\x00\\x00\\x00\\x90\\x01\\x00\\x00'print (byte[0],byte[4]) # &gt;&gt;&gt;:b'\\x14\\x00\\x00\\x00\\x90\\x01\\x00\\x00' 格式符”i”表示转换为int，’ii’表示有两个int变量。进行转换后的结果长度为8个字节（int类型占用4个字节，两个int为8个字节）可以看到输出的结果是乱码，因为结果是二进制数据，所以显示为乱码。可以使用python的内置函数repr来获取可识别的字符串 ，以上问题在Python3中不会出现了其中十六进制的0x00000014, 0x00000190分别表示20和400。 上一段代码最后那个很有意思诶，竟然是默认采用小端。 大端存储和小端存储小端：较高的有效字节存放在较高的存储器地址，较低的有效字节存放在较低的存储器地址。大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。 如果将一个16位的整数0x1234存放到一个短整型变量（short）中。这个短整型变量在内存中的存储在大小端模式由下表所示。 地址偏移 大端模式 小端模式 0x00 12（OP0） 34（OP1） 0x01 34（OP1） 12（OP0） 采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。 struct.unpack(fmt, buffer) Unpack from the buffer buffer (presumably packed by pack(fmt, …)) according to the format string fmt. The result is a tuple even if it contains exactly one item. The buffer’s size in bytes must match the size required by the format, as reflected by calcsize(). struct.unpack做的工作刚好与struct.pack相反，用于将字节流转换成python数据类型。它的函数原型为：struct.unpack(fmt, string)，该函数返回一个tuple。 123a1, a2 = struct.unpack(\"ii\", byte) print(type(struct.unpack(\"ii\", byte)),a1,a2)# &gt;&gt;&gt;:&lt;class 'tuple'&gt; 20 400 struct.calcsize(fmt) Return the size of the struct (and hence of the bytes object produced by pack(fmt, …)) corresponding to the format string fmt. struct.calcsize用于计算格式字符串所对应的结果的长度，如：struct.calcsize(‘ii’)，返回8。因为两个int类型所占用的长度是8个字节。 参考链接：https://docs.python.org/3/library/struct.htmlhttp://blog.csdn.net/occupy8/article/details/11052103","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Ubuntu14.04+CPU+Python的Caffe安装教程","slug":"Ubuntu-caffe","date":"2017-03-16T02:52:28.000Z","updated":"2017-03-25T10:51:10.817Z","comments":true,"path":"2017/03/16/Ubuntu-caffe/index.html","link":"","permalink":"http://feiyang.li/2017/03/16/Ubuntu-caffe/index.html","excerpt":"背景：手头只有一个win主机，虚拟机版本：Ubuntu14.04，目标是安装后CAFFE能作为PYTHON MODULE来使用，只使用CPU模式","text":"背景：手头只有一个win主机，虚拟机版本：Ubuntu14.04，目标是安装后CAFFE能作为PYTHON MODULE来使用，只使用CPU模式 安装开发所依赖的安装包 打开Ubuntu的终端，输入命令。1234sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compilersudo apt-get install --no-install-recommends libboost-all-devsudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-devsudo apt-get install libatlas-base-dev 升级g++1g++ --version&lt;/span&gt; 查看g++版本，由于编译需要至少4.8版本的g++，一般来说，自带版本应该时4.8。如果想要升级g++，这里也提供以下下载方式，并且设置默认编译的g++为最新版本。1234567sudo add-apt-repository ppa:ubuntu-toolchain-r/test #用来添加库信息的帮助脚本。 sudo apt-get update #更新 sudo apt-get install gcc-4.9 sudo apt-get install g++-4.9 #更新g++，gcc sudo ln -sf /usr/bin/gcc-4.9 /usr/bin/gcc #在调用的gcc库上做一个与最新版本的软连接，更改g++的默认版本。 sudo ln -sf /usr/bin/gcc-ar-4.9 /usr/bin/gcc-ar sudo ln -sf /usr/bin/gcc-ranlib-4.9 /usr/bin/gcc-ranlib 安装anaconda，建议安装。12wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-4.3.1-Linux-x86_64.shbash Anaconda3-4.3.1-Linux-x86_64.sh 安装过程中记得一直选择默认的就行，傻瓜式安装。是否在bashrc中添加路径，这里选择“yes”就可以。忘了的话，解决方法很麻烦，自己查查吧。 安装OpenCV2.4(这个经常失败，建议跳过，不影响使用)123git clone https://github.com/bearpaw/Install-OpenCVcd Install-OpenCV/Ubuntu/2.4sh ./opencv2_4_10.sh jayrambhia/Install-OpenCV.git 编译过程很慢，中间我还报过一次错，不得不重新来了一次。如果觉得难度不够的话，可以选择官网的安装包：http://opencv.org/，我这里是根据大神编译过的版本进行安装的。 安装atlas1sudo apt-get install libatlas-base-dev #安装atlas简单易行。 编译Caffe下载caffe12cd ~ git clone https://github.com/BVLC/caffe.git 修改Makefile配置123cd caffe cp Makefile.config.example Makefile.config gedit Makefile.config #我个人比较喜欢gedit ，用起来方便。 CPU_ONLY := 1 配置一些引用文件（增加部分主要是解决新版本下，HDF5的路径问题） 123INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serialLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu/hdf5/serialBLAS := atlas 编译caffe123make all -j8make test -j8make runtest -j8 另外, 这个make默认是用CPU单核运算,如果想要快一点, 比如我想使用四核, 在make后面加上-j4标签。如果上面4行某一行报错之后想要重试,建议先make clean再重新开始。 更新安装依赖。12cd caffe cat python/requirements.txt | xargs -L 1 sudo pip install 编译Python接口打开新的终端, 用which Python和which pip确定使用的是anaconda提供的python环境，然后进入caffe/python, 执行下列命令， 确保pip已经安装12sudo apt-get install python-pipfor req in $(cat requirements.txt); do pip install $req; done #python运行需要的库。 再次回到caffe根目录我们可以执行：在caffe根目录的python文件夹下，有一个requirements.txt的清单文件，上面列出了需要的依赖库，按照这个清单安装就可以了。在安装scipy库的时候，需要fortran编译器（gfortran)，如果没有这个编译器就会报错，因此，我们可以先安装一下。 回到caffe的根目录，然后执行安装代码： 1234cd ~/caffesudo apt-get install gfortrancd ./pythonfor req in $(cat requirements.txt); do pip install $req; done 安装完成以后，再次回到caffe根目录我们可以执行：1sudo pip install -r python/requirements.txt 就会看到，安装成功的，都会显示Requirement already satisfied, 没有安装成功的，会继续安装。 编译python接口1make pycaffe -j8 运行python进入caffe/python ，运行123456$ python2.7Python 2.7.12 (default, Jul 1 2016, 15:12:24) [GCC 5.4.0 20160609] on linux2Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; import caffe&gt;&gt;&gt; 加入PythonPathgedit ~/.bashrc将export PYTHONPATH=/home/wing/caffe/python:$PYTHONPATH添加到文件最后。source ~/.bashrc 使更改生效。这样，在其他地方打开python，也可以import caffe了。 出现过一个问题：error ：No module named google.protobuf.internal解决方法是：sudo chmod 777 -R anaconda（文件夹） 改变权限 然后conda install protobuf可以很方便的解决的问题","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Win10 Anaconda中安装Tensorflow并配置到jupter kernel","slug":"win10-conda-tensorflow","date":"2017-03-15T05:22:44.000Z","updated":"2017-03-16T02:57:34.710Z","comments":true,"path":"2017/03/15/win10-conda-tensorflow/index.html","link":"","permalink":"http://feiyang.li/2017/03/15/win10-conda-tensorflow/index.html","excerpt":"Windows环境下 Anaconda中安装Tensorflow，并且将Tensorflow配置到jupyter notebook中去。","text":"Windows环境下 Anaconda中安装Tensorflow，并且将Tensorflow配置到jupyter notebook中去。 安装Anaconda下载：https://www.continuum.io/downloads ，我用的是Python 3.5下载完以后，安装。 输入清华的仓库镜像，更新包更快：12conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes 推荐第一行命令输入两次，以便把这个镜像地址放在首位。 安装TensorFlow一般来说，我们推荐新建一个新的virtualenv，这样可以预防同一个环境中的包太多，相互发生冲突。1conda create -n tensorflow python=3.5 既然是建议，那么忽视上边这一句话，也是可以的。 1activate tensorflow 激活后，我选择安装的是CPU版本，输入： pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-0.12.0-cp35-cp35m-win_amd64.whl 安装失败的话多试几次 加入jupyter notebook的ipykernel内核123source activate tensorflow# On Windows, remove the word &apos;source&apos;install ipykernelpython -m ipykernel install --user --name tensorflow--display-name &quot;Python (myenv)&quot; 在激活状态下，安装ipykernel，后边那个展示名称，自己可以随便填。进入jupyter notebook ，运行一下测试文件，看是否可以使用。 如果不行，输入jupyter --paths 检查一下kernal是不是设置的有问题，比如我的就是C:\\Users\\wing\\AppData\\Roaming\\jupyter\\kernels\\tensorflow一般来说是环境所在的地址有问题，修改一下就可以啦。 通过这个方法，可以把自己手贱多加上去的kernel删掉。jupyter kernal 删除更多建议阅读官方文档 我记得这个地方蛮复杂的，我当时往kernel里边加入R内核，费了大力气。当时还没写博客的习惯，现在又忘记怎么加的，真是日了狗。 测试：12345678910import tensorflow as tftf.__version__&gt;&gt;&gt;:'1.0.1'sess = tf.InteractiveSession()x = tf.Variable([1.0, 2.0])a = tf.constant([3.0, 3.0])x.initializer.run()# 使用初始化器 initializer op 的 run() 方法初始化 ‘x‘ sub = tf.sub(x, a)# 增加一个减法 sub op, 从 ‘x‘ 减去 ‘a‘. 运行减法 op, 输出结果 sub.eval()&gt;&gt;&gt;:array([-2., -1.], dtype=float32) 我碰到了一个module &#39;tensorflow&#39; has no attribute &#39;sub&#39;，原因是tensorflow升级了之后，这个sub函数被改成了subtract，代码改成sub = tf.subtract(x, a)即可。","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://feiyang.li/tags/Jupyter/"}]},{"title":"《小萝莉的猴神大叔》","slug":"indian-movie","date":"2017-03-11T07:06:14.000Z","updated":"2017-03-13T10:45:25.356Z","comments":true,"path":"2017/03/11/indian-movie/index.html","link":"","permalink":"http://feiyang.li/2017/03/11/indian-movie/index.html","excerpt":"但行好事，莫问前程。真正能做到的能有几个呢？","text":"但行好事，莫问前程。真正能做到的能有几个呢？ 你是我心脏跳动的力量 没看过几部印度电影，算上三傻，这也仅仅是第二部而已。什么小萝莉的猴神大叔，印度电影命名水平还是一如既往的差。 刚开始看的时候呀，我一边哈哈哈一边和室友猜下边将发生啥，猜了好几次，竟然都猜对了。 后来不知道怎么了，就不想说话了，戴着耳机投入到猴神大叔的世界了。就算猜到了结尾，也丝毫不影响我看的时候哭的稀里哗啦的。 我其实不太懂印度巴基斯坦那边的渊源，也不太懂宗教信仰之类的，所以我觉得我应该错过了好多值得玩味的小细节。 印度电影中的人物好像总是一言不合就唱歌跳舞，开心也跳，难过也跳，想跳就跳，一跳还跳很长时间，但我还挺喜欢看的。 童话里的巴士 国家和国家之间，宗教和宗教之间也许有很多矛盾，但是爱和信仰是相通的。 善良朴实虔诚的猴神大叔因为对小女孩的一个承诺，毅然决然的走上了送小女孩回家的路。这一路，太凶险，却也不乏各种各样善良的人的帮助。 小女孩从小无法说话，后来又和家人走丢，这本是一件不幸的事，却因为遇到了猴神大叔，遇到正义的摄影师，遇到善良的伊斯兰教父，还有很多很多充满善意的人，才如此幸运的回到妈妈身边。 感觉这个世界上，像猴神大叔这样的好人还是太少了。 因为爱，扛起对一个陌生小姑娘的全部责任，从一个平庸的别人眼中的失败者，到无所不能面对重重困难都充满力量的人。 但行好事，莫问前程。真正能做到的能有几个呢？ 主题歌是这样唱的： 你是我的道路，你与我为伴 我找寻着你，也找到了自己 我是你的声音，而你是我的语言 我们相遇之后，我感觉充满了力量 我们相遇之后，我变得无所不能 尽管终点困难重重，但前方的路不再迷茫 我是你的小路，你是我的小棉袄 找到你的足迹，我也找到了自己 因为你是我心脏跳动的力量。 最后一幕永远定格在我的内心深处，人至善、水至柔、景至美、情至真！再铁骨铮铮的汉子也会为之动容。 记得有人说过，好人会受伤，会流泪，会不知所措，但好人永远是这个世界的魂，向好人致敬！","categories":[],"tags":[{"name":"臭臭","slug":"臭臭","permalink":"http://feiyang.li/tags/臭臭/"},{"name":"Movie","slug":"Movie","permalink":"http://feiyang.li/tags/Movie/"}]},{"title":"细究Python键盘输入","slug":"python-input","date":"2017-03-10T05:52:53.000Z","updated":"2017-03-27T11:44:05.567Z","comments":true,"path":"2017/03/10/python-input/index.html","link":"","permalink":"http://feiyang.li/2017/03/10/python-input/index.html","excerpt":"本文介绍了raw_input 和 input在python2和python3上的区别，以及如何利用正则表达式和input键盘输入一维数组和二维数组。","text":"本文介绍了raw_input 和 input在python2和python3上的区别，以及如何利用正则表达式和input键盘输入一维数组和二维数组。 raw_input 和 inputpython2中12raw_input_A = raw_input(\"raw_input: \")type(raw_input_A) 可以看到输出的是 str 12input_A = input(\"Input: \") #不能输入字母type(raw_input_A) 可以看到输出的是 int，并且我们发现，input根本不能输入字母，会直接报NameError: name &#39;abc&#39; is not defined，提示没有定义。 Python2报错 查看 Built-in Functions ，得知：input([prompt]) Equivalent to eval(raw_input(prompt)) input() 本质上还是使用 raw_input() 来实现的，只是调用完 raw_input() 之后再调用 eval() 函数，所以，你甚至可以将表达式作为 input() 的参数，并且它会计算表达式的值并返回它。不过在 Built-in Functions 里有一句话是这样写的：Consider using the raw_input() function for general input from users.除非对 input() 有特别需要，否则一般情况下我们都是推荐使用 raw_input() 来与用户交互。 python3中因为刚才说的那个原因，input其实没有什么必要，所以就被改进了。 简单来说，raw_input没有了，只剩下input。现在这个input就是之前那个raw_input。 查看 Python官方文档input([prompt]) ，得知： If the prompt argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, EOFError is raised. 简单说，返回的内容都是str，括号里边的prompt写什么，就会当做提示内容输出。比如底下的那个 --&gt;1234&gt;&gt;&gt; s = input('--&gt; ') --&gt; Monty Python's Flying Circus&gt;&gt;&gt; s \"Monty Python's Flying Circus\" 因为我一般都是用python3，接下来的内容都是以3为准。 Python输入数组一维数组 使用int()进行强制类型转型 当输入内容不为数字时，不能转型，发生except跳出循环。 先声明data是一个list，将input_A一个个+进去。123456789data = []while True: try: input_A = int(input(\"Input: \")) data +=[input_A] except: breakdatatype(data) 输入数组 在以上的基础上，我们可以用python输入二维数组 python输入二维数组正则表达式会利用非数字的字符，进行切割，因此数字之间插入什么都无所谓。 12345678910111213import redata2D = []while True: userInput = input('Input:') # 输入数组，用空格隔开即可 info = re.split(r'[\\D]',userInput)#正则表达式分割 data = []# 定义一维数组 try: for number in info: data+=[int(number)] # 一维数组加入数字 data2D+=[data] #一维数组加入到二维中去 except: break;data2D","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"算法导论 第7章 快速排序","slug":"Python-quick-order","date":"2017-03-09T14:22:16.000Z","updated":"2017-03-25T05:10:12.327Z","comments":true,"path":"2017/03/09/Python-quick-order/index.html","link":"","permalink":"http://feiyang.li/2017/03/09/Python-quick-order/index.html","excerpt":"快速排序是一种非常优秀的排序方法","text":"快速排序是一种非常优秀的排序方法 对于包含n个数的输入数组来说，快速排序是一种最坏情况是$$\\theta(n^{2})$$ 的算法，虽然表现出的状态和堆排序是相似的。但实际上，快速排序的复杂度绝大部分情况的都可以做到$$\\theta(nlgn)$$) 快排算法的描述快排算法分为两部分： 分解：数组A[p..r]被分解为A[p...q-1]和A[q+1...r]，其中A[p...q-1]内的元素都比A[q]小，A[q+1...r]中的元素都比A[q]大。 解决：通过调用快速排序，解决A[p...q-1]和A[q+1...r]。 合并：因为元素都是原址排序，因此不需要合并操作。 伪代码对整个数组进行递归排序：12345QUICKSORT(A,p,r)if p &lt; r: q = PARTITION(A,p,r); QUICKSORT(A,p,q-1); QUICKSORT(A,q+1,r); 快速排序算法的关键是PARTITION过程，它对A[p..r]进行就地重排：123456789PARTITION(A,p,r)x = A[r]i = p-1for j = p to r-1// A[j]是待比较的元素 if A[j] ≤ r// 若A[j]比主元小 i = i + 1 // i往后一位（符合，不用替换；不符合i就停在这个地方，等着j过来叫唤） exchange A[i] with A[j]//倘若A[j]比主元小，其实是不发生交换的。exchange A[i+1] with A[r]return i + 1 借用一张《算法导论》的图 Introduction to Algorithms 参考代码C++代码基本和伪代码是一样的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;void swap(int *a, int *b) &#123; int temp = *b; *b = *a; *a = temp;&#125;void print(int *A, int len) &#123; for (int i = 0; i &lt; len; i++) &#123; printf(\"%4d\", A[i]); &#125; printf(\"\\n\");&#125;int PARTITION(int *A, int p, int r) &#123; int i = p - 1; int x = A[r]; for (int j = p; j &lt; r; j++) &#123; if (A[j] &lt;= x) &#123; i++; swap(&amp;A[i], &amp;A[j]); &#125; &#125; swap(&amp;A[i + 1], &amp;A[r]); return i + 1;&#125;void QUICKSORT(int A[], int p, int r) &#123; if (p &lt; r) &#123; int q = PARTITION(A, p, r); QUICKSORT(A, p, q - 1); QUICKSORT(A, q + 1, r); &#125; return;&#125;int main() &#123; int A[] = &#123; 9,10,11,7,1,2,3,6,5,8,4 &#125;; print(A, 11); QUICKSORT(A, 0, 10); print(A,11); return 0;&#125; 期间出了一个错误，error C3861: 找不到标识符。后发现是因为把PARTITION放在了QUICKSORT后边，导致QUICKSORT找不到PARTITION。 python代码123456789101112131415161718192021222324252627# coding=utf-8def PARTITION(A,p,r): x = A[r] i = p - 1 for j in range(p,r): if A[j]&lt;=x: i = i + 1 temp = A[i] A[i] = A[j] A[j] = temp #python没有指针，这个地方稍微不一样 temp = A[i+1] A[i+1] = A[r] A[r] = temp return i+1def QUICKSORT(A,p,r): if p &gt;= r: return q = PARTITION(A,p,r) QUICKSORT(A,p,q-1) QUICKSORT(A,q+1,r) if __name__ == '__main__': l = [9,10,11,7,1,2,3,6,5,8,4] ; QUICKSORT(l,0,len(l)-1) print(l) 这里使用的数组是list，声明方式是l = [9,10,11,7,1,2,3,6,5,8,4]，注意那个[]。如果使用元组tuple，会导致元素不能修改。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"sort","slug":"sort","permalink":"http://feiyang.li/tags/sort/"},{"name":"cpp","slug":"cpp","permalink":"http://feiyang.li/tags/cpp/"}]},{"title":"Digitalocean一键搭建vpn","slug":"do-vpn","date":"2017-03-03T06:17:00.000Z","updated":"2017-05-11T05:59:33.985Z","comments":true,"path":"2017/03/03/do-vpn/index.html","link":"","permalink":"http://feiyang.li/2017/03/03/do-vpn/index.html","excerpt":"使用github学生优惠内的digitalocean，一键搭建vpn。获得60刀，免费用一年~","text":"使用github学生优惠内的digitalocean，一键搭建vpn。获得60刀，免费用一年~ 准备工作为什么选择DigitalOcean 可以不用信用卡，通过Paypal即可绑定。 有512MB内存、单核处理器可选，每月5美元。 每月1000GB的流量 申请github学生优惠包 前往 https://education.github.com/pack/ 申请学生优惠包 mark 有账号就直接登录，没有账号选择注册账号： mark 申请的时候，会问你是不是学生，那我肯定说是学生啦，我又不是撒 mark 然后会要求提供学校名称，所以那么骗人的edu邮箱基本是没有办法使用的。最后那句How do you plan to use GitHub? 你就说I&#39;ll public my program at github.或者什么I love github，开心就好，说什么无所谓。 mark 很快就会审核通过，会邮件通知。 领取 DigitalOcean 优惠包 看到这个码，50刀就到你手了。 mark 注册DO账号，用我的邀请链接注册，多送10刀。https://m.do.co/c/990a117f5061 ，注册之后需要付款5刀，这个时候不要用paypel的汇率，用本地的汇率。 使用DigitalOcean邀请注册之后就不能使用github学生包50刀的处理方法我看到很多人提到领取了这个10刀之后，那个50刀的github优惠包里边的码就不能用了。简直一派胡言，I’m angry。可以通过提交ticket mark 然后告诉他，我不知道github学生优惠包里边的码怎么用，让他给你处理。 mark 一般来说分分钟就会回复邮件，帮你加上50刀。如果使用我的推荐链接的话，我可以把我的回复内容复制给你。 安装vpn这里使用一键安装脚本，基于centos。 新建vps选择顶栏第一个 Droplets，点击create droplet mark 选择5刀，centos的这一款，地点选择San Francisco，这个新加坡，虽然离中国近，但是速度慢，旧金山还是比较合适的。 mark 选择确定之后，会发邮件告诉你IP地址以及账号密码。 一键安装vpn 使用putty 连接vps，我在打马赛克那个地方输入ip地址。然后点open mark 第一次进行会有个提示，点击确定就好。之后会要求输入当前密码账号，按照邮箱里边给的密码写就可以了。 成功登陆后，还会要求输入当前密码，然后自己设置新密码 一键安装vpn代码 12345wget https://raw.githubusercontent.com/mmmwhy/centos-setup-simple-pptp-vpn/master/setup.shchmod +x ./setup.sh./setup.sh 全部复制，点两下确定，然后坐等片刻，vpn就搭好了。 mark 搭建的是最常见的pptp协议类型的vpn，使用win自带拨号程序即可连接。 mark 修改账户密码sudo vi /etc/ppp/chap-secrets都有提示，按i之后修改就可以了。 小结之前一直懒得写这样一篇教程，但是发现好多人对这方面都不了解，我稍微解释了一下。 邀请得到的10刀和github50刀可以共存的问题 申请github学生优惠包的时候怎样描述自己的plan paypel付款时，不要用paypel的汇率，用本地的汇率 一键安装包用的是linuxeye的脚本，我略微修改，还请多多指教。","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://feiyang.li/categories/shadowsocks/"}],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"},{"name":"github","slug":"github","permalink":"http://feiyang.li/tags/github/"},{"name":"vpn","slug":"vpn","permalink":"http://feiyang.li/tags/vpn/"}]},{"title":"IntelliJ 、Pycharm激活码及激活服务器","slug":"jetbrains","date":"2017-02-26T13:28:39.000Z","updated":"2017-05-02T07:15:03.603Z","comments":true,"path":"2017/02/26/jetbrains/index.html","link":"","permalink":"http://feiyang.li/2017/02/26/jetbrains/index.html","excerpt":"jetbrains 家的东西都非常好看，但是价格贵的令人发指，所以我搭建了一个 Pycharm激活服务器，可以用来激活 Pycharm，IntelliJ IDEA，WebStorm。避免频繁更换激活码的问题。","text":"jetbrains 家的东西都非常好看，但是价格贵的令人发指，所以我搭建了一个 Pycharm激活服务器，可以用来激活 Pycharm，IntelliJ IDEA，WebStorm。避免频繁更换激活码的问题。 jetbrains 激活服务器搭建一台VPS连vps都没有，小拳头你怕不怕(ง •̀_•́)ง 。 那你用我的吧，╮(╯▽╰)╭ 。 一键脚本建议在特权模式下运行，即sudo -s一下1wget http://home.ustc.edu.cn/~mmmwhy/jetbrain.sh &amp;&amp; sh ./jetbrain.sh 会出现两个空，用于输入端口号和默认用户名，建议直接回车，否则可能会出现莫名其妙的错误。 将最后那个License sever地址记下，之后激活用。 激活选择License sever激活方式，输入激活地址 License sever激活 分分钟应该就会弹出提示，一劳永逸解决激活问题。 激活成功提示 激活服务器分享我搭建了一个激活服务器，直接公布会很容易被封，需要的请关注： 小小臭臭 回复“激活”即可获得地址。 Pycharm注册码 / IntelliJIDEA注册码紧急更新，因为之前的激活码已经被取消，修改hosts(C:\\Windows\\System32\\drivers\\etc)即可使用时需要将“0.0.0.0 account.jetbrains.com”添加到hosts文件中 mark 双击复制全部1CNEKJPQZEX-eyJsaWNlbnNlSWQiOiJDTkVLSlBRWkVYIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTgtMDEtMzAifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOC0wMS0zMCJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE4LTAxLTMwIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE4LTAxLTMwIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTgtMDEtMzAifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTgtMDEtMzAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxOC0wMS0zMCJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE4LTAxLTMwIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTgtMDEtMzAifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxOC0wMS0zMCJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE4LTAxLTMwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTgtMDEtMzAifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxOC0wMS0zMCJ9XSwiaGFzaCI6IjUxOTU1OTMvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-QOxwjWvRwJz6vo6J6adC3CJ4ukQHosbPYZ94URUVFna/Rbew8xK/M5gP3kAaPh6ZDveFdtMR1UBoumq3eCwXtXM3U3ls5noB4LIr+QplVlCj2pK5uNq7g/feyNyQcHpSXtvhIOnXDBLOecB05DOsxzm0p7ulGGJoAInmHeb9mc0eYjqc4RPpUQfh6HSYBnvEnKMlLF5bz4KEtzmsvvgA55CwzwQ3gRitm5Q/wUT7AQCBdjmBfNUjKVQL6TSjSDPp56FUdEs4Aab8LqstA2DIMbxocO64rvytmcUeIwu8Mi5uq87KQP5AQMSMYb59Inbd+dmVfx5cJo3fRS4/5s3/Hg==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 在Activate code处粘贴进去即可 Activate code 衷心感谢博主：ilanyu， http://blog.lanyus.com/","categories":[],"tags":[{"name":"Pycharm激活","slug":"Pycharm激活","permalink":"http://feiyang.li/tags/Pycharm激活/"}]},{"title":"Hexo博客中插入音乐/视频","slug":"Hexo-music-video","date":"2017-02-24T12:57:01.000Z","updated":"2017-02-25T05:59:28.975Z","comments":true,"path":"2017/02/24/Hexo-music-video/index.html","link":"","permalink":"http://feiyang.li/2017/02/24/Hexo-music-video/index.html","excerpt":"Hexo插入音乐/视频/网易云音乐/bilibili视频，会让博客看起来很洋气 (ง •̀_•́)ง","text":"Hexo插入音乐/视频/网易云音乐/bilibili视频，会让博客看起来很洋气 (ง •̀_•́)ง Markdown 通用的音乐视频插入方法iframe标签代码从网易云音乐获得 网易云音乐 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=430 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=114389&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt; 效果如下： embed标签1&lt;embed height=&quot;415&quot; width=&quot;544&quot; quality=&quot;high&quot; allowfullscreen=&quot;true&quot; type=&quot;application/x-shockwave-flash&quot; src=&quot;//static.hdslb.com/miniloader.swf&quot; flashvars=&quot;aid=8506694&amp;page=1&quot; pluginspage=&quot;//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&quot;&gt;&lt;/embed&gt; 效果如下： javascript标签举例1&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xiami.com/widget/player-single?uid=32329501&amp;sid=1776238762&amp;mode=js&quot;&gt;&lt;/script&gt; 使用 Hexo 插件插入音乐/视频两个好用的hexo插件： hexo-tag-aplayer：https://github.com/grzhan/hexo-tag-aplayer hexo-tag-dplayer： https://github.com/NextMoe/hexo-tag-dplayer 播放音乐的aplayer在cmd页面内，使用npm安装：npm install hexo-tag-aplayer 在markdown内添加以下代码： 1&#123;% aplayer &quot;她的睫毛&quot; &quot;周杰伦&quot; &quot;http://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3&quot; &quot;http://home.ustc.edu.cn/~mmmwhy/jay.jpg&quot; &quot;autoplay=false&quot; %&#125; 效果如下所示： new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: false, showlrc: 0, music: { title: \"她的睫毛\", author: \"周杰伦\", url: \"http://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", } }); 播放视频的dplayer在cmd页面内，使用npm安装：npm install hexo-tag-dplayer 在markdown内添加以下代码： 1&#123;% dplayer &quot;url=http://home.ustc.edu.cn/~mmmwhy/GEM.mp4&quot; &quot;pic=http://home.ustc.edu.cn/~mmmwhy/GEM.jpg&quot; &quot;loop=yes&quot; &quot;theme=#FADFA3&quot; &quot;autoplay=false&quot; &quot;token=tokendemo&quot; %&#125; 效果如下所示： var dplayer0 = new DPlayer({\"element\":document.getElementById(\"dplayer0\"),\"autoplay\":false,\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://home.ustc.edu.cn/~mmmwhy/GEM.mp4\",\"pic\":\"http://home.ustc.edu.cn/~mmmwhy/GEM.jpg\"}}); 以上","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://feiyang.li/tags/hexo/"},{"name":"plugins","slug":"plugins","permalink":"http://feiyang.li/tags/plugins/"}]},{"title":"Django 创建第一个项目","slug":"django-hello-world","date":"2017-02-18T11:37:59.000Z","updated":"2017-02-18T12:41:10.174Z","comments":true,"path":"2017/02/18/django-hello-world/index.html","link":"","permalink":"http://feiyang.li/2017/02/18/django-hello-world/index.html","excerpt":"上手使用Python的Web框架– Django","text":"上手使用Python的Web框架– Django 网上教程安装环境多是linux环境，所以我写一下windows系统下创建Django项目。基于Django 1.10 和Python3.5，作为学生狗的好处之一，就是有很多时间，慢慢琢磨新技术。 windows上virtualenv 安装及使用一开始我不太懂virtualenv 到底有什么意思，后来慢慢各种package装的多了后，发现还是很有必要的。举个例子：如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？ 这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。 正常安装过程 安装virtualenv 1pip install virtualenv 为项目安装虚拟环境为该虚拟环境起个名字，新建文件夹，cd进入。 1virtualenv env 激活环境 1your_env_dir\\Scripts\\activate Pycharm使用虚拟环境上边说的那种方法，完全没有实用性，太扯淡了。切换环境难于上青天，用Pycharm会简便很多。 新建项目 用Pycharm建立虚拟环境 mark 新建之后，在第一个图片那个地方进行选择就可以了，建议新建conda-env，自动新建在envs环境下，方便管理 至此，django环境搭建完毕，接下来学习django工程的创建，以及简单的在网页中显示出”Hello World”。 初识Django工程点击Create创建工程见创建后的工程截图： Django 文件如下: my_site: 项目的容器。 manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。 my_site/init.py: 一个空文件，告诉 Python 该目录是一个 Python 包。 my_site/settings.py: 该 Django 项目的设置/配置。 my_site/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。 my_site/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。 直接启动Django项目来看执行的结果，启动的方式是：1python manage.py runserver 0.0.0.0:8000 0.0.0.0让其它电脑可连接到开发服务器，8000为端口号。如果不说明，那么端口号默认为8000。 Pycharm启动Django项目 打开manage.py文件 在菜单栏中Run中选择Edit Configurations，见截图：修改Script parameters: runserver Script parameters ctrl + shift+ F10 运行 输出 页面 Hello world 新建 view.py在先前创建的 my_site 目录下的 my_site 目录新建一个 view.py 文件，并输入代码： 123from django.http import HttpResponsedef hello(request): return HttpResponse(\"Hello world ! \") 我们从 django.http 中导入了 HttpResponse 这个类。我们会在接下来用到这个类。 我们定义了一个叫做 hello 的视图函数(view function)。每个view function至少要有一个参数，通常被叫做 request 。这是一个对象，包含了触发这个 view function的Web请求的信息， 它是 django.http.HttpRequest 的一个实例(instance)。 在这个例子中，虽然我们不对这个 request 做任何处理，但是我们还必须要把它作为视图的第一个参数。 这个函数只有一行简单的代码：它仅仅返回一个 HttpResponse 对象，这个对象包含了文本“Hello world”。 记住，一个视图本身就是一个Python的函数，这个函数接受一个 HttpRequest 作为它的第一个参数，并返回 一个 HttpResponse 的实例。要想让一个Python函数成为一个Django的视图，你需要让它满足这两个条件。 修改urls.py1234567from django.conf.urls import include, urlfrom django.contrib import adminfrom my_site.view import hellourlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^hello/$', hello)] 代码分析 URLconf在Django里，要关联view function到一个URL，需要用到 URLconf。URLconf 就像是你的Django站点的目录。本质上，它是一个URL和这个URL将调用的view function之间的映射关系。 通过这种方式，你就可以告诉Django：“对于这个URL，调用这段代码，对于那个URL，调用那段代码。”例如，当用户访问 /hello/ 时，调用view function hello() ， 这个view function在 views.py 中。因此需要在使用function前，进行声明：from my_site.view import hello。 URLpattern首先，我们从模块mysite/views.py中导入了 hello 这个view function。Python的导入语法用mysite.views表示 mysite/views.py 。(这段代码假设了mysite/views.py在Python的搜索路径中) 接着，我们添加了url(r’^hello/$’, hello), 到 urlpatterns 中。这一行被叫做一个URLpattern。 url() 函数会告诉Django如何处理你配置的url。 url() 的第一个参数是一个模式匹配字符串( 正则表达式)，第二个参数处理这个URLpattern的view function。 补充 正则表达式我们在正则表达式字符串前面加了一个 r 。在Python中，这表示一个原始字符串(raw string)，Python不会去转义那些反斜杠()。在普通的Python字符串中，反斜杠会被用来转义特殊字符，比如字符串 ‘\\n’ 会被解释成换行符。当你加上 r 之后，Python就不会转义那些字符了， r’\\n’ 就是一个包括了一个反斜杠和一个小写字母“n”的字符串。正则表达式中反斜杠的用法和Python字符串中反斜杠的用法刚好冲突了。所以在Python中使用正则表达式的时候最好都加上 r 。本书中所有的URLpattern都会用这种形式。 URLpattern的语法 Django在检查URL模式之前，会移除每个URL最开始的斜杠。这意味着URLpattern并不包括 /hello 开头那个斜杠。(一开始，这可能不太直观，但是这样做简化了很多事情。) 匹配模式里面包括了一个脱字符( ^ )和一个美元符( \\$ )。这两个符号在正则表达式里面的有特别的意义： ^ 要求从字符串开头开始匹配， \\$ 则是要求对字符串尾部进行匹配。 这个URLconf中我们是把 hello 这个view function直接作为一个对象传递的，而不是去调用它。 这是Pyhton(作为动态语言)的一个重要特征，函数是一级对象(first-class objects)，你可以像 传递其它变量一样传递一个函数。很洋气吧？ 以上","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://feiyang.li/tags/Django/"}]},{"title":"第2.1题：Python统计日记最重要的词","slug":"python-camp2-1","date":"2017-02-17T09:04:55.000Z","updated":"2017-03-27T11:44:11.367Z","comments":true,"path":"2017/02/17/python-camp2-1/index.html","link":"","permalink":"http://feiyang.li/2017/02/17/python-camp2-1/index.html","excerpt":"题目来自：Python 练习册。题目2.1： 你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。","text":"题目来自：Python 练习册。题目2.1： 你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。 参考代码123456789101112131415161718192021222324252627282930#coding: utf-8import re, osfrom collections import Counter# 目标文件所在目录PATH = 'D:'def getCounter(source): #输入一个英文的纯文本文件，统计其中的单词出现的个数 with open(source) as f: data = f.read() data = data.lower()#字母全部小写 datalist = re.split(r'[\\s]+', data)#根据空白字符，将data进行划分 return Counter(datalist)def run(PATH): # 切换到目标文件所在目录 os.chdir(PATH) # 遍历该目录下的txt文件 total_counter = Counter() # 生成Counter()对象 for i in os.listdir(os.getcwd()): if os.path.splitext(i)[1] == '.txt':#分离扩展名 total_counter += getCounter(i)# 多个Counter()叠加 return total_counter.most_common()#Counter对象转化为list格式if __name__ == '__main__': dic = run(PATH) for i in range(len(dic)): print('%15s ----&gt; %3s' % (dic[i][0],dic[i][1])) 出现的错误编码问题UnicodeDecodeError: ‘gbk’ codec can’t decode byte…两种解决方法： decode(‘utf-8’)重新编码一下 123fp = open(filename,'rb')content = fp.read().decode('utf-8') open方法指定参数encoding=’UTF-8’: 1content= open('filename', mode='rb', encoding='UTF-8') 但是得注意一下，原文到底是不是UTF-8编码。反正Python编码这里是个大坑，多加小心。 文件名、目录名或卷标语法不正确Path里边的斜杠是 / 不是 \\PATH = &#39;E:/Python/pydata-book-master/ch02&#39; AttributeError: ‘list’ object has no attribute ‘…看看那个object到底是什么，print(type(name)) ，然后再查查其对应的函数。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://feiyang.li/tags/自然语言处理/"}]},{"title":"第1.9题：Python对密码加密","slug":"python-camp9","date":"2017-02-16T13:59:43.000Z","updated":"2017-03-27T11:44:14.250Z","comments":true,"path":"2017/02/16/python-camp9/index.html","link":"","permalink":"http://feiyang.li/2017/02/16/python-camp9/index.html","excerpt":"题目来自：Python 练习册。题目1.9： 通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。","text":"题目来自：Python 练习册。题目1.9： 通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。 思路：salt 加 hash 来单向转换密码明文 参考代码以下给出Py2和Py3两段代码，输出的内容是一样的。因为加密之后的内容不是unicode代码，所以存储可能不方便，可以使用base64.b64encode(hashed)转化为base64编码格式。 输出结果 Python2代码123456789101112131415161718192021222324252627282930313233import os,base64from hashlib import sha256from hmac import HMACdef encrypt_password(password, salt=None): \"\"\"Hash password on the fly.\"\"\" if salt is None: salt = os.urandom(8) # 64 bits. assert 8 == len(salt) assert isinstance(salt, str) if isinstance(password, unicode): password = password.encode('UTF-8') assert isinstance(password, str) result = password for i in xrange(10): result = HMAC(result, salt, sha256).digest() return salt + resultdef validate_password(hashed, input_password): return hashed == encrypt_password(input_password, salt=hashed[:8]) if __name__==\"__main__\": hashed = encrypt_password('secret password') assert validate_password(hashed, 'secret password') print (hashed) print (base64.b64encode(hashed)) print (base64.b64decode(base64.b64encode(hashed))) Python3代码123456789101112131415161718192021222324252627282930313233343536import os, base64from hashlib import sha256from hmac import HMACdef encrypt_password(password, salt=None): \"\"\"Hash password on the fly.\"\"\" if salt is None: salt = os.urandom(8) # 64 bits. assert 8 == len(salt) assert isinstance(salt, bytes) assert isinstance(password, str) if isinstance(password, str): password = password.encode('UTF-8') assert isinstance(password, bytes) result = password for i in range(10): result = HMAC(result, salt, sha256).digest() return salt + resultdef validate_password(hashed, input_password): return hashed == encrypt_password(input_password, salt=hashed[:8])if __name__ == \"__main__\": hashed = encrypt_password('secret password') assert validate_password(hashed, 'secret password') print (hashed) print (base64.b64encode(hashed)) print (base64.b64decode(base64.b64encode(hashed))) Python编码问题一开始直接在Python3环境运行第一段代码的时候，总会报错NameError: global name &#39;unicode&#39; is not defined，百思不得其解。 查了资料，才发现是因为Python更新的时候，Python 3 renamed the unicode type to str, the old str type has been replaced by bytes。在Python升级文档内可以查到相关内容，也就是unicode直接改名str，str改名成bytes。Python2和Python3，在编码方面挖下太多的坑举个简单的例子：12isinstance(u'中文', unicode) #python2内是正确的isinstance(u'中文', str) #python3内是正确的 Python3内的unicode和bytesPython 3最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。 在将字符串存入磁盘和从磁盘读取字符串的过程中，Python 自动地帮你完成了编码和解码的工作，你不需要关心它的过程，例如你能把一个中文赋值给字符串。而使用 bytes 类型，实质上是告诉 Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式。 参考链接：http://zhuoqiang.me/password-storage-and-python-example.htmlhttp://www.ituring.com.cn/article/61192","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"密码处理","slug":"密码处理","permalink":"http://feiyang.li/tags/密码处理/"}]},{"title":"第1.8题：文本读取转化","slug":"python-camp8","date":"2017-02-15T14:07:40.000Z","updated":"2017-03-27T11:44:20.470Z","comments":true,"path":"2017/02/15/python-camp8/index.html","link":"","permalink":"http://feiyang.li/2017/02/15/python-camp8/index.html","excerpt":"题目来自：Python 练习册。题目1.8： 将纯文本文件 student.txt为学生信息,，写到 student.xls 文件内。","text":"题目来自：Python 练习册。题目1.8： 将纯文本文件 student.txt为学生信息,，写到 student.xls 文件内。 题目描述题目1.8： 纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示： { &quot;1&quot;:[&quot;张三&quot;,150,120,100], &quot;2&quot;:[&quot;李四&quot;,90,99,95], &quot;3&quot;:[&quot;王五&quot;,60,66,68] } 请将上述内容写到 student.xls 文件中，如下图所示： student.xls 这个题使用到文件读取，数据读取，Xls文件输出三部分内容。 文件读取使用open()函数12with open('student.txt') as f: content = f.read() 数据读取1d = json.loads(content) xls文件输出12345678file = xlwt.Workbook()# 添加sheettable = file.add_sheet('test')for row, i in enumerate(list(d)): table.write(row, 0, i) for col, j in enumerate(d[i]): table.write(row, col + 1, j)file.save('student.xls') 参考代码student.txt 可以在这里下载~ http://cdn.mmmxcc.cn/blog/student.txt 1234567891011121314151617181920212223#coding: utf-8import osimport jsonimport xlwt# 存放文件的目录filepath = 'D:'os.chdir(filepath)# 读取文件内容with open('student.txt') as f: content = f.read()# 转为jsond = json.loads(content)file = xlwt.Workbook()# 添加sheettable = file.add_sheet('test')for row, i in enumerate(list(d)): table.write(row, 0, i) for col, j in enumerate(d[i]): table.write(row, col + 1, j)file.save('student.xls')","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://feiyang.li/tags/自然语言处理/"}]},{"title":"第1.7题：Python敏感词检测","slug":"python-camp7","date":"2017-02-15T11:28:20.000Z","updated":"2017-03-27T11:44:17.551Z","comments":true,"path":"2017/02/15/python-camp7/index.html","link":"","permalink":"http://feiyang.li/2017/02/15/python-camp7/index.html","excerpt":"题目来自：Python 练习册。题目1.7：敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。","text":"题目来自：Python 练习册。题目1.7：敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。 Python find()方法描述Python find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。 语法find()方法语法：str.find(str, beg=0, end=len(string)) 参数str – 指定检索的字符串beg – 开始索引，默认为0。end – 结束索引，默认为字符串的长度。 返回值如果包含子字符串返回开始的索引值，否则返回-1。 实例以下实例展示了find()方法的实例：12345678info = 'abca'print info.find('a')##从下标0开始，查找在字符串里第一个出现的子串，返回结果：0info = 'abca'print info.find('a',1)##从下标1开始，查找在字符串里第一个出现的子串：返回结果3info = 'abca'print info.find('333')##返回-1,查找不到返回-1 Python strip()方法描述Python strip() 方法用于移除字符串头尾指定的字符（默认为空格）。 语法strip()方法语法：str.strip([chars]); 参数chars – 移除字符串头尾指定的字符。 返回值返回移除字符串头尾指定的字符生成的新字符串。 实例以下实例展示了strip()函数的使用方法：12str = \"0000000this is string example....wow!!!0000000\";print str.strip( '0' ); 以上实例输出结果如下：this is string example….wow!!! Python map()方法描述很简单，第一个参数接收一个函数名，第二个参数接收一个可迭代对象。 语法map(f, iterable)基本上等于：[f(x) for x in iterable] 实例123456&gt;&gt;&gt; def add100(x):... return x+100... &gt;&gt;&gt; hh = [11,22,33]&gt;&gt;&gt; map(add100,hh)[111, 122, 133] 参考代码filtered_words.txt将文件下载到D盘内即可1234567891011121314151617181920212223242526#coding: utf-8import cmd# 存放敏感词文件的路径filtered_words_filepath = 'd:/filtered_words.txt'class CLI(cmd.Cmd): def __init__(self): #初始基础类方法 cmd.Cmd.__init__(self) # 初始化，提取敏感词列表 self.intro = 'Python敏感词检测:' #输出欢迎信息 f = open(filtered_words_filepath) self.words = list(map(lambda i: i.strip('\\n'), f.readlines())) self.prompt = \"&gt;&gt;&gt; \" # 定义提示符 def default(self, line): if any([i in line for i in self.words]): print ('Freedom') else: print ('Human Rights') def do_quit(self, arg): exit() return Trueif __name__ ==\"__main__\": cli = CLI() cli.cmdloop() 其实这个地方出现过一个错误，map()形成的iterable是一次性的。 也就是如果不保存，直接迭代之后，self.words =map(lambda i: i.strip(&#39;\\n&#39;), f.readlines())self.words 里边的数据会丢失，因此这个地方加了一个list()函数，将iterable到处保存。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://feiyang.li/tags/自然语言处理/"}]},{"title":"Coursera ML(1)-机器学习基础概念","slug":"Coursera-ML","date":"2017-02-14T11:19:17.000Z","updated":"2017-03-27T11:41:09.516Z","comments":true,"path":"2017/02/14/Coursera-ML/index.html","link":"","permalink":"http://feiyang.li/2017/02/14/Coursera-ML/index.html","excerpt":"在学习的过程中，抓住基本概念是非常重要的，这样可以防止自己陷入某些细节中无法自拔，可以让自己站在比较宏观的层面上看待问题。 更多见：李飞阳","text":"在学习的过程中，抓住基本概念是非常重要的，这样可以防止自己陷入某些细节中无法自拔，可以让自己站在比较宏观的层面上看待问题。 更多见：李飞阳 机器学习（Machine Learning） Coursera上机器学习课程的介绍中，第一句话是： Machine learning is the science of getting computers to act without being explicitly programmed. 机器学习是让电脑自己学会如何处理问题，而不需要人们刻意的编程。 Andrew Ng老师的讲义中（Coursera）给出的定义：Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”Example: playing checkers. · E = the experience of playing many games of checkers · T = the task of playing checkers. · P = the probability that the program will win the next game. 周志华的《机器学习》中定义：机器学习正是这样一门学科，它致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。在计算机系统中，“经验”通常以“数据”的形式存在，因此，机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”（model）的算法，即“学习算法”（learning algorithm）。有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时，模型会给我们提供相应的判断。 有监督学习（Supervised Learning） 维基百科Supervised learning is the machine learningtask of inferring a function from labeled training data.The training data consist of a set of training examples. In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a “reasonable” way. Example: Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem. We could turn this example into a classification problem by instead making our output about whether the house “sells for more or less than the asking price.” Here we are classifying the houses based on price into two discrete categories 无监督学习（Unsupervised Learning）维基百科： Unsupervised learning is the machine learning task of inferring a function to describe hidden structure from unlabeled data. Since the examples given to the learner are unlabeled, there is no error or reward signal to evaluate a potential solution. This distinguishes unsupervised learning from supervised learning and reinforcement learning. Unsupervised learning is closely related to the problem of density estimation in statistics.[1] However unsupervised learning also encompasses many other techniques that seek to summarize and explain key features of the data. Many methods employed in unsupervised learning are based on data mining methods used to preprocess data. Example: Clustering: Take a collection of 1000 essays written on the US Economy, and find a way to automatically group these essays into a small number that are somehow similar or related by different variables, such as word frequency, sentence length, page count, and so on. Associative: Suppose a doctor over years of experience forms associations in his mind between patient characteristics and illnesses that they have. If a new patient shows up then based on this patient’s characteristics such as symptoms, family medical history, physical attributes, mental outlook, etc the doctor associates possible illness or illnesses based on what the doctor has seen before with similar patients. This is not the same as rule based reasoning as in expert systems. In this case we would like to estimate a mapping function from patient characteristics into illnesses. 解释一下： 首先看什么是学习（learning）？一个成语就可概括：举一反三。此处以高考为例，高考的题目在上考场前我们未必做过，但在高中三年我们做过很多很多题目，懂解题方法，因此考场上面对陌生问题也可以算出答案。机器学习的思路也类似：我们能不能利用一些训练数据（已经做过的题），使机器能够利用它们（解题方法）分析未知数据（高考的题目）？ 最简单也最普遍的一类机器学习算法就是分类（classification）。对于分类，输入的训练数据有特征（feature），有标签（label）。所谓的学习，其本质就是找到特征和标签间的关系（mapping）。这样当有特征而无标签的未知数据输入时，我们就可以通过已有的关系得到未知数据标签。 在上述的分类过程中，如果所有训练数据都有标签，则为有监督学习（supervised learning）。如果数据没有标签，显然就是无监督学习（unsupervised learning）了，也即聚类（clustering）。 目前分类算法的效果还是不错的，但相对来讲，聚类算法就有些惨不忍睹了。确实，无监督学习本身的特点使其难以得到如分类一样近乎完美的结果。这也正如我们在高中做题，答案（标签）是非常重要的，假设两个完全相同的人进入高中，一个正常学习，另一人做的所有题目都没有答案，那么想必第一个人高考会发挥更好，第二个人会发疯。 这时各位可能要问，既然分类如此之好，聚类如此之不靠谱，那为何我们还可以容忍聚类的存在？因为在实际应用中，标签的获取常常需要极大的人工工作量，有时甚至非常困难。例如在自然语言处理（NLP）中，Penn Chinese Treebank在2年里只完成了4000句话的标签…… 这时有人可能会想，难道有监督学习和无监督学习就是非黑即白的关系吗？有没有灰呢？Good idea。灰是存在的。二者的中间带就是半监督学习（semi-supervised learning）。对于半监督学习，其训练数据的一部分是有标签的，另一部分没有标签，而没标签数据的数量常常极大于有标签数据数量（这也是符合现实情况的）。隐藏在半监督学习下的基本规律在于：数据的分布必然不是完全随机的，通过一些有标签数据的局部特征，以及更多没标签数据的整体分布，就可以得到可以接受甚至是非常好的分类结果。（此处大量忽略细节） 因此，learning家族的整体构造是这样的：有监督学习（分类，回归）↕半监督学习（分类，回归），transductive learning（分类，回归）↕半监督聚类（有标签数据的标签不是确定的，类似于：肯定不是xxx，很可能是yyy）↕无监督学习（聚类） 总结在Coursera上Andrew Ng的课程中，主要涉及： Supervised Learning，包括Linear Regression、Logistic Regression、Neural Networks、Support Vector Machines； Unsupervised Learning，包括Clustering、Dimensionality Reduction、Anomaly Detection、Recommender Systems。 参考资料Coursera - Machine learning( Andrew Ng) https://www.coursera.org/learn/machine-learning什么是无监督学习？ https://www.zhihu.com/question/23194489","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"}]},{"title":"《结网》","slug":"jiewang","date":"2017-02-13T13:39:16.000Z","updated":"2017-04-16T07:31:11.262Z","comments":true,"path":"2017/02/13/jiewang/index.html","link":"","permalink":"http://feiyang.li/2017/02/13/jiewang/index.html","excerpt":"对于产品经理来说，自己所负责的产品的表现就是自己的履历。","text":"对于产品经理来说，自己所负责的产品的表现就是自己的履历。 入坑说来惭愧，最初进入产品经理这个职位，是因为大二在OPPO的实习。 搬砖的地方 当时实习的时候，认识了许和高，许 瘦瘦高高的风格很让人喜欢。 许 当时应该算产品助理，但是不知道自己具体该做什么。 最开始只是单纯的觉得HR纪姐姐真的好漂亮，如果不能进去实习，岂不后悔莫及。 进入OPPO，很多时间是跟费费和飞哥玩，认识了女神。我们玩得时候，女神总默默的拿出自己的小Iphone用百词斩背单词。 有一次做展示的时候，和高 有吵，记得争论是OPPO论坛的改版问题。 我第一次对产品岗心生退意 更深大三暑假，走上了考研路，想想这一辈子应该也没有这样一次机会，这么长时间的去做一件事情。可以与喜欢的女孩，朝夕相处。 妹子 那时最大的梦想就是一起去吃 老五烧烤 吃 去年的这个时间，知道自己成绩后一脸懵逼。没有多想，立刻动身找工作。 当时有很多互联网公司在春招，因为 高 的推荐，拿到了搜狐的offer。之后又拿到了360的offer，都是做产品经理。选择了数字公司，做线上商城业务。 期间发现自己可以调剂，碾转奔波的面试，终于可以继续在象牙塔读书。 USTC 在360的时候，跟卢老师系统的学习了一些产品方面的知识，后来又和涛哥共事了很久。慢慢的掌握了一些产品经理的技能，比如不要重复发明轮子。现有的组件可以用上的，就尽量不要重复开发，提高共用性，需求的快速化迭代。如何将已有的功能，逻辑性的展示出来。 疾病症状搜索 之后，自己接手360全球好药的产品工作。看着薛姐、静姐、俊哥哥、欣欣，他们付出那么多心血，真心希望这个项目可以成功。页面还是我画的那个样子，好熟悉，时间过得真快。 一开始，这个项目跟我对接业务的是金，金 是武大生物学硕士。真是条条大道通CS，后来金跳槽去了杭州。之后跟我对接的是超哥，超哥又跳槽去了拼少少。我都有点怀疑自己了…… 上次跟超超聊，又升值加薪了，就差一个白富美。 期间发生了一些事，再加上我本身不喜与人当面争执，又一次对产品岗位心生退意 后记现在虽然已经远离产品经理这个角色，但是给我留下很多习惯。比如对一些细节会较真，会对一些人或事看的比较淡。 当初计划大四面试前看，但是那时图书馆没这本书。 谁知今天正好遇见它，也许是缘分吧。读了一些，做此感想。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"PM","slug":"PM","permalink":"http://feiyang.li/tags/PM/"}]},{"title":"第1.6题：使用Python生成字母验证码图片","slug":"python-camp6","date":"2017-02-13T05:36:02.000Z","updated":"2017-03-27T11:44:24.442Z","comments":true,"path":"2017/02/13/python-camp6/index.html","link":"","permalink":"http://feiyang.li/2017/02/13/python-camp6/index.html","excerpt":"题目来自：Python 练习册。题目1.6：使用 Python 生成类似于下图中的字母验证码图片查看更多于本人博客：李飞阳","text":"题目来自：Python 练习册。题目1.6：使用 Python 生成类似于下图中的字母验证码图片查看更多于本人博客：李飞阳 参考代码我们用随机颜色填充背景，再画上文字，最后对图像进行模糊，得到验证码图片如下：12345678910111213141516171819202122232425262728293031323334353637383940from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random# 随机字母:def rndChar(): return chr(random.randint(65, 90))# 随机颜色1:def rndColor(): return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))# 随机颜色2:def rndColor2(): return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))def compose(): # 240 x 60: width = 240 height = 60 image = Image.new('RGB', (width, height), (255, 255, 255)) # 创建Font对象: font = ImageFont.truetype('C:/windows/fonts/Arial.ttf', 36) # 创建Draw对象: draw = ImageDraw.Draw(image) # 填充每个像素: for x in range(width): for y in range(height): draw.point((x, y), fill=rndColor()) # 输出文字: letter = [] for t in range(4): letter.append(rndChar()) draw.text((60 * t + 10, 10), letter[t], font=font, fill=rndColor2()) # 模糊: image.save('code.jpg', 'jpeg') image = image.filter(ImageFilter.BLUR) image.save('filter.jpg', 'jpeg') print (letter)compose() 输出验证码原本数字： 运行结果 模糊前： mark image = image.filter(ImageFilter.BLUR) # 模糊:模糊后： mark 如果运行的时候报错：IOError: cannot open resource 这是因为PIL无法定位到字体文件的位置，可以根据操作系统提供绝对路径，比如：&#39;/Library/Fonts/Arial.ttf&#39; 要详细了解PIL的强大功能，请请参考Pillow官方文档：https://pillow.readthedocs.io/en/4.0.x/ 小结PIL提供了操作图像的强大功能，可以通过简单的代码完成复杂的图像处理。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"图片处理","slug":"图片处理","permalink":"http://feiyang.li/tags/图片处理/"}]},{"title":"第1.5题：使用Python处理图片","slug":"python-camp5","date":"2017-02-13T02:33:53.000Z","updated":"2017-03-27T11:44:28.359Z","comments":true,"path":"2017/02/13/python-camp5/index.html","link":"","permalink":"http://feiyang.li/2017/02/13/python-camp5/index.html","excerpt":"题目来自：Python 练习册。题目1.5：你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。查看更多于本人博客：李飞阳","text":"题目来自：Python 练习册。题目1.5：你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。查看更多于本人博客：李飞阳 使用python来处理图片是非常方便的，下面提供一小段python处理图片的代码，需要安装图像处理工具包PIL(Python Image Library)。 安装PIL我用的是anaconda(一个开源的Python发行版本，包含了常用的数据科学库。)，其中自带了PIL和Pillow，但是不能用，真是(ಥ _ ಥ) 。检查自己电脑是否支持PIL，可以在Python shell 页面输入：1from PIL import Image Image 如果没有报错的话，就可以代表正常。如果报错说[importError: No module named images]，使用pip卸载pillow，重新安装应该就可以了. 参考代码稍微注意一下，图片的宽高是两个数字，不能理所当然的认为图片都是宽大于高的。12345678910111213141516171819202122232425262728import os from PIL import Image pathDir='F:\\CloudMusic' os.chdir(pathDir) def get_imglist(): #获取照片名称list img_list=[] list_dir=os.listdir(pathDir) for x in list_dir: if '.jpg' in x: img_list.append(x) else: print(\"This is not a picture: \"+x) return img_list def modify_imgsize(): for filename in get_imglist(): img=Image.open(filename) if max(img.size)&gt;1136: value=max(img.size)/1136.0 newsize =(int(img.size[0]/value),int(img.size[1]/value)) newimg = img.resize(newsize,Image.ANTIALIAS) #修改大小 newimg.save('new_'+filename) else: print(\"This picture is availabe:\"+filename) if __name__ == '__main__': modify_imgsize()","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"图片处理","slug":"图片处理","permalink":"http://feiyang.li/tags/图片处理/"}]},{"title":"第1.4题：统计文件中单词出现个数","slug":"python_camp4","date":"2017-02-11T12:16:52.000Z","updated":"2017-03-27T11:43:09.407Z","comments":true,"path":"2017/02/11/python_camp4/index.html","link":"","permalink":"http://feiyang.li/2017/02/11/python_camp4/index.html","excerpt":"题目来自：Python 练习册。今天做第四题：任一英文的纯文本文件，统计其中的单词出现个数。","text":"题目来自：Python 练习册。今天做第四题：任一英文的纯文本文件，统计其中的单词出现个数。 铺垫工作这一期的铺垫工作比较多，所以单独写了一篇文章，详见 Python正则表达式 正文部分题目内容任一个英文的纯文本文件，统计其中的单词出现的个数。参考英文：12345678910111213141516171819202122232425262728If you are looking for someone you can pour out your love to, let me suggest the empowered woman. The empowered woman knows what she wants, knows how to get it, knows how to live fully, and she knows how to love you back without needing anyone’s approval or recognition. An empowered woman is unarguably one of the most magnificent beings you will ever come in contact with. Read on and find 10 reason why you should absolutely love and embrace the empowered women in your life! . 1. She knows how to love you in returnIt is difficult to give what you don’t have. It is impossible to love someone and feel fulfilled when they can’t love you in return because they don’t love themselves. This will never happen to you when you love an empowered woman. She loves herself (not in a narcissistic manner). In turn, she appreciates who you are and loves you in return. She will love you just like you deserve to be loved. 2. She will inspire youWhen life puts you down and you are at the end of your rope, the empowered woman will be there to see you through. Her drive, enthusiasm and (at times) hopeless optimism will inspire you to carry on despite the obstacles you face. 3. She is not afraid of failureWhile many out there are thoroughly terrified of failure, the empowered woman understands that failures are simply stepping stones in life. How can you not love someone that is thoroughly unafraid to try, fail, and give it a shot all over again?! 4. She is all about the legacyWhile most people are focused on the car, the house, the job, and corner office; the empowered woman is focused on leaving a legacy that will inspire others and change the world. The empowered woman is focused on empowering others to maximize their potential and fulfill their purpose. She is all about inspiring others to look beyond themselves and live a life of service to others. 5. She can laugh at her mistakes……and learn from them as well! She understands mistakes are part of the journey. The empowered woman can laugh and learn from her mistakes to ensure they never happen again. 6. She can be vulnerableThe empowered woman understands there is no debt in relationships without vulnerability. Although she is emotionally strong, she is willing to laugh and cry with you because all of these emotions are an essential part of life. 7. She can speak her mindWhile everyone else is too concerned with what others may think or say, the empowered woman is not afraid to speak her mind. She understands that her value comes from within, not from what others say or think about her. 8. She knows when to remain quietShe lives by Abe Lincoln’s words, “Better to remain silent and be thought a fool, than to speak out and remove all doubt.” 9. She knows how to have funWhether it is at the symphony or at a ball game, the empowered woman understands life is made up of experiences with people – not the places you go. She is able to live in the moment and enjoy it fully without being concerned for the future. After all, who’s got a guaranteed future? 10. She is not afraid of changeWhile most people rather continue on living unfulfilled lives as long as their comfort zone remains intact, the empowered woman is all about embracing change. She understands growth cannot happen without change. She understands that change is the gift life offers you to choose your destiny. Therefore, she is not afraid of change because it is her stepping stone towards success. 下载链接将文件下载到python的工作路径里去，如果不知道哪里是工作路径，输入123456import os#获取当前工作目录os.getcwd()#更改当前工作目录os.chdir('d:\\')os.getcwd() 参考代码每一步我都尽量附带上了解释123456789101112131415161718192021222324252627# coding=utf-8from collections import defaultdictimport re# 替换除了n't这类连字符外的所有非单词字符和数字字符def replace(s): if s.group(1) == 'n\\'t': return s.group(1) return ' 'def cal(filename='203305485.txt'): # 使用lambda来定义简单的函数 dic = defaultdict(lambda: 0)#dic = defaultdict(int)也可以 with open(filename, 'r') as f: data = f.read() # 全部变为小写字母 data = data.lower() # 替换除了n't这类连字符外的所有非单词字符和数字字符 data = re.sub(r'(n[\\']t)|([\\W\\d])', replace, data) datalist = re.split(r'[\\s\\n]+', data) for item in datalist: dic[item] += 1 del dic[''] return dicif __name__ == '__main__': dic = cal() for key, val in dic.items(): print('%15s ----&gt; %3s' % (key,val)) 运行结果如下： 结果 增加排序函数代码有参考 《利用python进行数据分析》12345def top_counts(dic, n=10): value_key_pairs = [(count, tz) for tz, count in dic.items()] value_key_pairs.sort() return value_key_pairs[-n:]top_counts(dic) 运行结果如下： 结果 可以看出，人们最喜欢用的词是定冠词the，下来是介词to……. 补充最近发现collections模块的Counter类 ，导入语句是：from collections import Counter，作用是：定义一个list数组，求数组中每个元素出现的次数修改之后代码量要少很多，而且可以直接排列好顺序~12345678910111213141516# coding=utf-8import refrom collections import Counterdef cal(filename='203305485.txt'): with open(filename, 'r') as f: data = f.read() data = data.lower() # 替换除了n't这类连字符外的所有非单词字符和数字字符 datalist = re.split(r'[\\s\\n]+', data) return Counter(datalist).most_common() if __name__ == '__main__': dic = cal() for i in range(len(dic)): print('%15s ----&gt; %3s' % (dic[i][0],dic[i][1])) 代码看起来行云流水，舒服多了。当然结论是一样的，人们还是比较喜欢说 the , you~ 修改后 以上~","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"Python正则表达式","slug":"Python_lambda","date":"2017-02-10T14:18:55.000Z","updated":"2017-03-27T11:44:32.213Z","comments":true,"path":"2017/02/10/Python_lambda/index.html","link":"","permalink":"http://feiyang.li/2017/02/10/Python_lambda/index.html","excerpt":"使用正则表达式，会使得字符串的处理很方便。","text":"使用正则表达式，会使得字符串的处理很方便。 正则表达式基础常用语法Python中经常要对字符串进行处理，处理用户的输入，对文本的编辑等等。使用正则表达式，会使得字符串的处理很方便。 Python支持的正则表达式元字符和语法 数量词的贪婪模式与非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。 Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。 例如：正则表达式”ab“如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab?”，将找到”a”。 re模块开始使用rePython通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。 12345678910111213# encoding: UTF-8import redef test(): # 将正则表达式编译成Pattern对象 pattern1 = re.compile(r'hello') # 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None return pattern1.match('hello world!') if test(): # 使用Match获得分组信息 print (\"match\")else: print (\"not match\") re.compile(strPattern[, flag]):这个方法用于将字符串形式的正则表达式编译为Pattern对象， 第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。可选值有： re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同） M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图） S(DOTALL): 点任意匹配模式，改变’.’的行为 L(LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 U(UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：1234a = re.compile(r\"\"\"\\d + # the integral part \\. # the decimal point \\d * # some fractional digits\"\"\", re.X)b = re.compile(r\"\\d+\\.\\d*\") re提供了众多模块方法用于完成正则表达式的功能。这些方法可以使用Pattern实例的相应方法替代，唯一的好处是少写一行re.compile()代码，但同时也无法复用编译后的Pattern对象。12m = re.match(r'hello', 'hello world!')print m.group() re模块还提供了一个方法escape(string)，用于将string中的正则表达式元字符如*/+/?等之前加上转义符再返回，在需要大量匹配元字符时有那么一点用。 MatchMatch对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。 属性： string: 匹配时使用的文本。 re: 匹配时使用的Pattern对象。 pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。 lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。 方法： group([group1, …]):获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 groups([default]): 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 groupdict([default]): 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。 start([group]): 返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。 end([group]): 返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。 span([group]): 返回(start(group), end(group))。 expand(template): 将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。 1234567891011121314151617import rem = re.match(r'(\\w+) (\\w+)(?P&lt;sign&gt;.*)', 'hello world!') print (\"m.string:\", m.string)print (\"m.re:\", m.re)print (\"m.pos:\", m.pos)print (\"m.endpos:\", m.endpos)print (\"m.lastindex:\", m.lastindex)print (\"m.lastgroup:\", m.lastgroup) print (\"m.group(1,2):\", m.group(1, 2))print (\"m.groups():\", m.groups())print (\"m.groupdict():\", m.groupdict())print (\"m.start(2):\", m.start(2))print (\"m.end(2):\", m.end(2))print (\"m.span(2):\", m.span(2))print (r\"m.expand(r'\\2 \\1\\3'):\", m.expand(r'\\2 \\1\\3')) 输出内容如下：12345678910111213m.string: hello world!m.re: re.compile(&apos;(\\\\w+) (\\\\w+)(?P&lt;sign&gt;.*)&apos;)m.pos: 0m.endpos: 12m.lastindex: 3m.lastgroup: signm.group(1,2): (&apos;hello&apos;, &apos;world&apos;)m.groups(): (&apos;hello&apos;, &apos;world&apos;, &apos;!&apos;)m.groupdict(): &#123;&apos;sign&apos;: &apos;!&apos;&#125;m.start(2): 6m.end(2): 11m.span(2): (6, 11)m.expand(r&apos;\\2 \\1\\3&apos;): world hello! PatternPattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。 Pattern不能直接实例化，必须使用re.compile()进行构造。 Pattern提供了几个可读属性用于获取表达式的相关信息： pattern: 编译时用的表达式字符串。 flags: 编译时用的匹配模式。数字形式。 groups: 表达式中分组的数量。 groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。 12345678910111213import rep = re.compile(r'(\\w+) (\\w+)(?P&lt;sign&gt;.*)', re.DOTALL) print (\"p.pattern:\", p.pattern)print (\"p.flags:\", p.flags)print (\"p.groups:\", p.groups)print (\"p.groupindex:\", p.groupindex) ### output #### p.pattern: (\\w+) (\\w+)(?P&lt;sign&gt;.*)# p.flags: 16# p.groups: 3# p.groupindex: &#123;'sign': 3&#125; 实例方法[ | re模块方法]： match(string[, pos[, endpos]]) | re.match(pattern, string[, flags]): 这个方法将从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’。 search(string[, pos[, endpos]]) | re.search(pattern, string[, flags]): 这个方法用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。 12345678910111213141516# encoding: UTF-8 import re # 将正则表达式编译成Pattern对象 pattern = re.compile(r'world') # 使用search()查找匹配的子串，不存在能匹配的子串时将返回None # 这个例子中使用match()无法成功匹配 match = pattern.search('hello world!') if match: # 使用Match获得分组信息 print (match.group() ) ### 输出 ### # world split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]): 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 1234567import re p = re.compile(r'\\d+')print (p.split('one1two2three3four4')) ### output #### ['one', 'two', 'three', 'four', ''] findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags]): 搜索string，以列表形式返回全部能匹配的子串。 1234567import re p = re.compile(r'\\d+')print (p.findall('one1two2three3four4')) ### output #### ['1', '2', '3', '4'] finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags]): 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。 12345678import re p = re.compile(r'\\d+')for m in p.finditer('one1two2three3four4'): print m.group(), ### output #### 1 2 3 4 sub(repl, string[, count]) | re.sub(pattern, repl, string[, count]): 使用repl替换string中每一个匹配的子串后返回替换后的字符串。当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。 123456789101112131415import re p = re.compile(r'(\\w+) (\\w+)')s = 'i say, hello world!' print p.sub(r'\\2 \\1', s) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print p.sub(func, s) ### output #### say i, world hello!# I Say, Hello World! subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]): 返回 (sub(repl, string[, count]), 替换次数)。 123456789101112131415import re p = re.compile(r'(\\w+) (\\w+)')s = 'i say, hello world!' print p.subn(r'\\2 \\1', s) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print p.subn(func, s) ### output #### ('say i, world hello!', 2)# ('I Say, Hello World!', 2) 以上就是Python对于正则表达式的支持。熟练掌握正则表达式是每一个程序员必须具备的技能。笔者也是看的迷迷糊糊，文章来自cnblog，原版博客基于Python2.4完成，年代有点久，我稍微修改了一下代码。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python-camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"第1.3题：将  200 个激活码保存到 MySQL","slug":"python_camp3","date":"2017-02-10T07:16:52.000Z","updated":"2017-03-27T11:43:22.581Z","comments":true,"path":"2017/02/10/python_camp3/index.html","link":"","permalink":"http://feiyang.li/2017/02/10/python_camp3/index.html","excerpt":"题目来自：Python 练习册，今天做的是第三题，使用 Python 将激活码保存到 MySQL。","text":"题目来自：Python 练习册，今天做的是第三题，使用 Python 将激活码保存到 MySQL。 准备姿势安装Mysql如果是windows 用户，mysql 的安装非常简单，直接下载安装文件，双击安装文件一步一步进行操作即可。 Linux 下的安装可能会更加简单，除了下载安装包进行安装外，一般的linux 仓库中都会有mysql ，我们只需要通过一个命令就可以下载安装： Ubuntu\\deepin12sudo apt-get install mysql-server sudo apt-get install mysql-client centOS/redhat1yum install mysql 安装MySQL-python要想使python可以操作mysql 就需要MySQL-python驱动，它是python 操作mysql必不可少的模块。 下载地址：https://pypi.python.org/pypi/MySQL-python/ 下载MySQL-python-1.2.5.zip 文件之后直接解压。进入MySQL-python-1.2.5目录: 1python setup.py install 可能会提示缺少“error: Microsoft Visual C++ 9.0 is required (Unable to find vcvarsall.bat). Get it from http://aka.ms/vcpython27”这个地方查找了很多资料，有的说要修改注册表，有的说要改VS2015的配置。简直一派胡言，I am angry。直接按照要求，在这个http://aka.ms/vcpython27下载安装就可以了。 Microsoft Visual C++ Compiler for Python 2.7 测试输入1import MySQLdb 或者1import mysql 如果不报错，那么就安装成功了。 mysql 的基本操作 启动mysql 1mysql -u root -p 查看当前所有的数据库 1show databases; 新建数据库表 1create database if not exists test; 使用某表 1use test; 添加数据 1insert into user values(&apos;Alen&apos;,&apos;7875&apos;); 查看数据 1select * from student 删除数据 1delete from user where name = &apos;Jack&apos;; 删除table 1drop table if exists student 删除database 1drop database if exists test mysql卡死怎么办查看目前连接情况： 1show processlist; 卡死 发现多个线程数据处理间出现了死锁，也没什么好的办法，kill掉就可以了。1kill 65; 然后就可以继续使用了。python 操作mysql基本语法 建立数据库连接注意，这个地方的test表要存在，否则无法连接123456789import MySQLdbconn=MySQLdb.connect( host='localhost', port = 3306, #默认3306端口，不写也可以 user='root', passwd='123456', db ='test',)cur = conn.cursor() cursor 是游标, 通过获取到的数据库连接conn下的cursor()方法来创建游标。其中，第二行代码可以缩写为：1connect(&apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;test&apos;) 创建数据表 12cur.execute(&quot;create table student(id int ,name varchar(20),class varchar(30),age varchar(10))&quot;) #通过游标cur 操作execute()方法可以写入纯sql语句。通过execute()方法中写如sql语句来对数据进行操作。 插入一条数据 1cur.execute(&quot;insert into student values(&apos;2&apos;,&apos;Tom&apos;,&apos;3 year 2 class&apos;,&apos;9&apos;)&quot;) 修改查询条件的数据 1cur.execute(&quot;update student set class=&apos;3 year 1 class&apos; where name = &apos;Tom&apos;&quot;) 删除查询条件的数据 1cur.execute(&quot;delete from student where age=&apos;9&apos;&quot;) 关闭游标 1cur.close() 提交数据向数据库插入一条数据时必须要有这个方法，否则数据不会被真正的插入。 1conn.commit() 关闭数据库连接 1conn.close() 打印表中所有数据1234567891011121314151617181920212223#coding=utf-8import MySQLdbconn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='123456', db ='test', )cur = conn.cursor()#获得表中有多少条数据aa=cur.execute(\"select * from student\")print aa#打印表中的多少数据info = cur.fetchmany(aa)for ii in info: print iicur.close()conn.commit()conn.close() 插入数据1234567891011121314151617181920212223#coding=utf-8import MySQLdbconn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='123456', db ='test', )cur = conn.cursor()#一次插入多条记录sqli=\"insert into student values(%s,%s,%s,%s)\"cur.executemany(sqli,[ ('3','Tom','1 year 1 class','6'), ('3','Jack','2 year 1 class','7'), ('3','Yaheng','2 year 2 class','7'), ])cur.close()conn.commit()conn.close() 以上两段代码参考 虫师的博客 正式代码经过以上铺垫之后，就可以写出满足要求的代码了。 12345678910111213141516171819202122232425262728293031323334353637from uuid import uuid4import MySQLdb,random, stringchars = string.digits + string.lettersdef uuidkey(num):# 使用uuid方法得到随机值 id_list = [str(uuid4()) for i in range(num)] return id_listdef randomkey(num):# 使用random随机取数据值 id_list = [\"\".join(random.sample(chars, 20)) for i in range(num)] return id_list def create_table_put_keys(id_list,table):#将获得的随机值存入mysql conn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='lyyc12345', db ='test', ) cur = conn.cursor() cur.execute(\"drop table if exists %s\" % table) #若存在table表则删除 cur.execute(\"create table %s(id int, coupon char(40))\" % table) #创建数据表 temp = 1 for i in id_list: #将id_list里边的数据插入到mysql中 cur.execute(\"insert into %s values('%d','%s')\" %(table,temp,i)) temp=temp+1 cur.close() #关闭游标 conn.commit() #提交数据 conn.close() #关闭数据库连接def main(): create_table_put_keys(uuidkey(200),'uuidtable') create_table_put_keys(randomkey(200),'randomtable')if __name__ == '__main__': main() 总结 python 中 % 的使用：cur.execute(&quot;insert into %s values(&#39;%d&#39;,&#39;%s&#39;)&quot; %(table,temp,i))，前后两部分用%相隔 提交数据conn.commit()，否则数据将不会保存。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"frp内网穿透","slug":"frp","date":"2017-02-09T02:56:15.000Z","updated":"2017-02-11T13:20:27.500Z","comments":true,"path":"2017/02/09/frp/index.html","link":"","permalink":"http://feiyang.li/2017/02/09/frp/index.html","excerpt":"我之前写过一篇文章是用Ngrok方式进行内网穿透，该方法需要借助到别人的服务器，非常麻烦。后来发现了Frp这个神器，只需要有一台公网的主机，就可以进行端口穿透，同时还可以转发tcp，udp，dns查询。","text":"我之前写过一篇文章是用Ngrok方式进行内网穿透，该方法需要借助到别人的服务器，非常麻烦。后来发现了Frp这个神器，只需要有一台公网的主机，就可以进行端口穿透，同时还可以转发tcp，udp，dns查询。 这里仅使用的到最简单的端口映射，需要一台有公网的vps，以及一台本地主机。 ssh登录公网vps下载frp安装包这里下载的是64位安装包wget http://home.ustc.edu.cn/~mmmwhy/frp/frp_0.9.3_linux_amd64.tar.gz如果你的系统版本是32位，那么建议使用如下命令：(如果不知道自己系统版本的，也用这个)wget http://home.ustc.edu.cn/~mmmwhy/frp/frp_0.9.3_linux_386.tar.gz frp 解压安装包tar -xzvf frp_0.9.3_linux_386.tar.gz frp 修改 frps.ini 文件，配置一个名为 ssh 的反向代理：cd frp_0.9.3_linux_386/ &amp;&amp; vi frps.ini1234567# frps.ini[common]bind_port = 7000[ssh]listen_port = 6000auth_token = 123 [ssh]后边写vps自己的端口。 公网端口 ssh端口号 启动 frps：./frps -c ./frps.ini 登录无公网主机下载frp安装包与 解压安装包，与上部相同，在此不赘述。 修改 frpc.ini 文件，配置一个名为 ssh 的反向代理：cd frp_0.9.3_linux_386/ &amp;&amp; vi frpc.ini如果希望转发到本地8888端口12345678[common]server_addr = 115.159.102.118server_port = 7000auth_token = 123[ssh]local_ip = 127.0.0.1local_port = 8888 启动 frpc：./frpc -c ./frpc.ini","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"},{"name":"frp","slug":"frp","permalink":"http://feiyang.li/tags/frp/"}]},{"title":"第1.2题：使用 Python 如何生成 200 个激活码","slug":"python_camp2","date":"2017-02-07T11:50:11.000Z","updated":"2017-03-27T11:43:20.920Z","comments":true,"path":"2017/02/07/python_camp2/index.html","link":"","permalink":"http://feiyang.li/2017/02/07/python_camp2/index.html","excerpt":"题目来自：Python 练习册，今天做的是第二题，使用 Python 如何生成 200 个激活码。","text":"题目来自：Python 练习册，今天做的是第二题，使用 Python 如何生成 200 个激活码。 random模块介绍我们可以使用python中的random模块，用于生成随机浮点数、整数、字符串，甚至帮助你随机选择列表序列中的一个元素，打乱一组数据等。 random模块五个函数 random() 返回0&lt;=n&lt;1之间的随机实数n； choice(seq) 从序列seq中返回随机的元素； getrandbits(n) 以长整型形式返回n个随机位； shuffle(seq[, random]) 原地指定seq序列； sample(seq, n) 从序列seq中选择n个随机且独立的元素； random模块方法说明 random.random()函数是这个模块中最常用的方法了，它会生成一个随机的浮点数，范围是在0.0~1.0之间。 random.uniform()正好弥补了上面函数的不足，它可以设定浮点数的范围，一个是上限，一个是下限。 random.randint()随机生一个整数int类型，可以指定这个整数的范围，同样有上限和下限值，python random.randint。 random.choice()可以从任何序列，比如list列表中，选取一个随机的元素返回，可以用于字符串、列表、元组等。 random.shuffle()如果你想将一个序列中的元素，随机打乱的话可以用这个函数方法。 random.sample()可以从指定的序列中，随机的截取指定长度的片断，不作原地修改。 使用random直接随机抽取从26个大小字母+10个数字，随机选取10个数字，组成一组激活码。重复此过程200次即可。 设定字符串内容123import random, stringchars = string.letters + string.digitsprint chars 输出内容为：abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 从给定内容中随机选取使用random.choice()和random.sample()两个函数123s= \"\".join(random.choice(chars) for i in range(10))gene = \"\".join(random.sample(chars, 10))print s +\" /////// \" + gene 其中s与gene分别可以获得两个随机序列，从这里我们可以看出两个函数使用上的差异，相对来说，random.sample()简单一些。 使用UUIDUUID是128位的全局唯一标识符，通常由32字节的字符串表示。 它可以保证时间和空间的唯一性，也称为GUID，全称为：Universally Unique IDentifie。 UUID的五种实现方法 uuid1()——基于时间戳由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。 uuid2()——基于分布式计算环境DCE（Python中没有这个函数）算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID，实际中很少用到该方法。 uuid3()——基于名字的MD5散列值通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。 uuid4()——基于随机数由伪随机数得到，有一定的重复概率，该概率可以计算出来。 uuid5()——基于名字的SHA-1散列值算法与uuid3相同，不同的是使用 Secure Hash Algorithm 1 算法使用UUID生成激活码123import uuidfor i in range(20): print uuid.uuid1() 输出：ebb4911e-ed1e-11e6-82ec-708bcda57790 ebb4b82e-ed1e-11e6-9f24-708bcda57790 ebb4b82f-ed1e-11e6-9d5c-708bcda57790 ebb4b830-ed1e-11e6-9f8b-708bcda57790 ebb4b831-ed1e-11e6-89d4-708bcda57790 ebb4b832-ed1e-11e6-903a-708bcda57790 ebb4b833-ed1e-11e6-9038-708bcda57790 ebb4b834-ed1e-11e6-b1dc-708bcda57790 ebb4b835-ed1e-11e6-8fb8-708bcda57790 ebb4b836-ed1e-11e6-a399-708bcda57790 ebb4b837-ed1e-11e6-a9a0-708bcda57790 ebb4b838-ed1e-11e6-8f85-708bcda57790 ebb4b839-ed1e-11e6-9ac2-708bcda57790 ebb4b83a-ed1e-11e6-8f48-708bcda57790 ebb4b83b-ed1e-11e6-b6d8-708bcda57790 ebb4b83c-ed1e-11e6-9bde-708bcda57790 ebb4b83d-ed1e-11e6-b03f-708bcda57790 ebb4b83e-ed1e-11e6-ac70-708bcda57790 ebb4b83f-ed1e-11e6-baf1-708bcda57790 ebb4b840-ed1e-11e6-a694-708bcda57790 写入文件代码示例12345678910111213141516import randomimport stringFIELD = string.digits + string.lettersdef generate(n, many=1, where=None): def getCode(n): return \"\".join(random.sample(FIELD, n)) gene = [getCode(n) for i in range(many)] return genedef writeIn(n, many, where): count = 1 for i in generate(n, many): with open(where, \"a\") as boom: boom.write(str(count).rjust(3)+\" \"+i+\"\\n\") count += 1if __name__ == '__main__': writeIn(20, 200, \"coupon.txt\") 以上","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"Github Pages + CDN全站加速","slug":"Github-Pages-CDN","date":"2017-02-07T05:38:38.000Z","updated":"2017-04-16T07:29:45.192Z","comments":true,"path":"2017/02/07/Github-Pages-CDN/index.html","link":"","permalink":"http://feiyang.li/2017/02/07/Github-Pages-CDN/index.html","excerpt":"常见的Pages服务有 Coding Pages和Github Pages，因为众所周知的原因，此类服务仅能放在国外，通过国内CDN加速Pages访问速度是一种不错的选择。以Coding Pages和腾讯CDN为例。 本方法同样可以对虚拟主机进行CDN加速。","text":"常见的Pages服务有 Coding Pages和Github Pages，因为众所周知的原因，此类服务仅能放在国外，通过国内CDN加速Pages访问速度是一种不错的选择。以Coding Pages和腾讯CDN为例。 本方法同样可以对虚拟主机进行CDN加速。 本方法可解决以下问题： 提高Pages的访问速度； 利用 CDN 解决百度爬虫被 Github Pages 拒绝的问题； 加速效果展示不使用CDN加速 不使用CDN 平均响应时间130ms，比我想象中要好。可能因为现在是上午11点上网的人少（?），之前我在学校测得时候动辄200ms。 使用CDN加速 CDN加速后 可以看到平均响应时间大约24.2ms，祖国山河一片绿。多环保~ 利用Pages搭建个人网站这一步在网上搜一下，有很多教程，在此不赘述。 使用CDN为Pages加速推荐腾讯云CDN，https://www.qcloud.com/product/cdn 目前可以免费送300G流量。根据服务商的要求，如Coding要求为： 在您的域名管理面板中添加 CNAME 记录指向到 pages.coding.me。 获得CNAME的IP地址ping 一下 pages.coding.me，获得IP地址： 23.248.162.138，源站设置为该IP。 设置源站 接下来，加速服务配置，默认时长都是30天。明显这个时间忒长了，我们可以设置为1天或者几个小时。 设置缓存逻辑 点击提交 ，过约5分钟会返回提示成功。点击管理进一步设置； 配置回源host我们可以把回源host理解为，访问23.248.162.138这个IP地址的服务器时，向服务器发出的url访问请求，服务器根据host头部里边的url地址，映射到内部相应访问空间去。回源host是用于CDN回源到源站时的访问域名，即http请求包包头的host字段内容。 回源host 配置域名CNAME CNAME 为域名配置相应的CNAME，常见的是@和www 检查ping 一下自己的域名，如果PING到后缀为cdntip.com或后缀为tcdn.qq.com表示域名CNAME已生效。 使用CDN为Pages加速，到这一步已经算结束了。但是由于使用国内CDN，使得网站在国外加载速度会慢的令人发指。 分地区DNS国内国外设置不同CANME，国外指向 mmmwhy.github.io或者pages.coding.me（设置自己的），国内的指向刚才CDN给出的地址。 以上 通过此方法可以将pages或者国外的免费空间，速度快到令人发指的地步~祝新年快乐~","categories":[],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://feiyang.li/tags/CDN/"},{"name":"Pages","slug":"Pages","permalink":"http://feiyang.li/tags/Pages/"}]},{"title":"jupyter notebook使用帮助","slug":"jupyter-notebook","date":"2017-01-12T12:50:52.000Z","updated":"2017-04-16T07:29:02.431Z","comments":true,"path":"2017/01/12/jupyter-notebook/index.html","link":"","permalink":"http://feiyang.li/2017/01/12/jupyter-notebook/index.html","excerpt":"jupyer notebook 使用的时候常见换主题，以及换工作空间的问题。","text":"jupyer notebook 使用的时候常见换主题，以及换工作空间的问题。 jupyter notebook 换字体换颜色换主题jupyter notebook自带的默认颜色实在是阳春白雪，看的多了眼睛有点累。页面的相关定义都是在CSS内完成的，我们可以通过修改CSS来达到目标。但是这样实在是太累了，在Github有一个jupyter-themes工具，真的很好用，通过pip进行安装，分分钟更换成自己喜欢的主题。 安装 jupyterthemespip install jupyterthemes通过pip安装省时省力，如果你当前pip安装速度很慢，可以考虑使用清华源，代码如下：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jupyterthemes 命令行格式1234usage: jt [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT] [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-alt] [-vim] [-T] [-N] [-r] options arg default Usage help -h – List Themes -l – Theme Name to Install -t – Code Font -f droidmono Code Font-Size -fs 11 Notebook Font -nf exosans Notebook Font Size -nfs 13 Text/MD Cell Font -tf loraserif Text/MD Cell Fontsize -tfs 13 Intro Page Margins -m auto Cell Width -cellw 980 Line Height -lineh 170 Cursor Width -cursw 2 Cursor Color -cursc – Alt Text/MD Layout -alt – Alt Prompt Layout -altp – Style Vim NBExt* -vim – Toolbar Visible -T – Name &amp; Logo Visible -N – Restore Default -r – 举个例子jt -t oceans16 -f roboto -fs 15意味着选择oceans16主题，roboto字体，大小为15，效果如下。 恢复原始主题，重新启动Jupyter notebook，如果主题没有改变，Ctrl+F5刷新即可。jt -r 目前我自己用的是jt -t onedork -cellw 1600 -lineh 170 -tf georgiaserif -nf droidsans -fs 15效果如下：主要修改了宽度，因为我电脑分辨率是1920*1080，使用默认的900宽度有点小了。 jupyter notebook换工作空间 打开 cmd 输入命令jupyter notebook --generate-config 进入自己工作目录，.jupyter，打开jupyter_notebook_config.py ctrl+f查到c.NotebookApp.notebook_dir，将这一行改为c.NotebookApp.notebook_dir = ‘自己的位置’ 启动 jupyter notebook","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://feiyang.li/tags/Jupyter/"}]},{"title":"部署在线IPyhton notebook(在线python编译器)","slug":"IPyhton-notebook","date":"2016-12-31T14:52:39.000Z","updated":"2017-04-16T07:28:29.789Z","comments":true,"path":"2016/12/31/IPyhton-notebook/index.html","link":"","permalink":"http://feiyang.li/2016/12/31/IPyhton-notebook/index.html","excerpt":"jupyter notebook在数据分析时使用非常的方便，特别那优美的页面，简直让我着迷。","text":"jupyter notebook在数据分析时使用非常的方便，特别那优美的页面，简直让我着迷。 优点： 支持的格式很多，Markdown，Latex等都支持，还有很方便的快捷键。 可以将代码可视化分享给其他人，From notebook to slides 像一张草稿纸，可以一边通过它来进行你的思考探索过程，交互式的进行，每一步都能看到结果，也很方便查看之前的结果。可以到IPython Notebook看一下，密码是Jupyter，我把《利用Python进行数据挖掘》的所有数据集和代码都放到了服务器里边2333333 本地安装Jupyter推荐先安装python科学计算包ANACONDA点击进入官网下载，按要求下载安装完成之后。期间会有一步提示是否加入Path，勾选加入环境变量。如果但是没有勾选，对于win事后可以手动添加环境变量。对于linux，使用export PATH=~/anaconda2/bin:$PATH进行添加。anaconda安装完后，对于win10用户，可以看到已经成功安装Jupyter Notebook，点击即可打开食用~ 点击之后，默认直接打开浏览器localhost:8888 用命令行也可以打开此页面，并且在打开的页面会形成.ipynb文件 线上部署 Jupyter Notebook在本地部署好了之后，其实给了我一些灵感，既然可以在浏览器运行。那么其实部署在服务器上也是可以的，大家如果看过我看过我之前的文章，就知道我对vps很感兴趣。其实在本地看到的那个localhost:8888，在外网也可以访问，只需要稍微加以设置即可。 首先要申请虚拟机这里推荐腾讯云或者DO，通过本链接注册送$10。然后再加上github的学生优惠包，可以很便宜哦。设置好之后，使用SSH连接上服务器。 服务器下载Anaconda 如果选择国内服务器，推荐清华Anaconda 镜像，点击进入，选择与自己服务器相符的版本。wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda-2.3.0-Linux-x86_64.sh 如果选择国外服务器，使用代码wget https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh本来想推荐科大源的，但是科大源实在是烂泥扶不上墙，目前清华源是国内比较好的了。 安装Anacondasudo bash Miniconda-latest-Linux-x86_64.shMiniconda-latest-Linux-x86_64.sh这个地方，输入自己下载的文件名称，其实只要写前几个字母，然后敲Tab，就可以自动补全了。安装好时候输入conda --v检查一下，如果输出为conda的版本则正常。如果输出conda: command not found，出现这种情况的原因是conda没有在path添加，使用export PATH=~/anaconda2/bin:$PATH 添加即可。 打开Ipython ,设置密码设置过程中要设置用于远程登录的密码，把生成的密文‘sha:ce…’复制下来 mark 12345In [1]: from IPython.lib import passwdIn [2]: passwd()Enter password:Verify password: Out[2]: &apos;sha1:7467b73*************************3003b****&apos; 生成配置文件终端输入：jupyter notebook --generate-config这个时候在当前目录会生成一个.jupyter的隐藏文件夹，修改文件内的jupyter_notebook_config.pyvim ~/.jupyter/jupyter_notebook_config.py 关于vim的常用功能：按a在光标所在位置插入内容（进入编辑模式），Esc退出编辑模式，连续按两下z，保存并退出。 jupyter_notebook_config.py内包含以下内容，稍作修改即可1234c.NotebookApp.ip=&apos;*&apos; # 就是设置所有ip皆可访问c.NotebookApp.password = u&apos;sha:ce...刚才复制的那个密文&apos;c.NotebookApp.open_browser = False # 禁止自动打开浏览器c.NotebookApp.port =8888 #随便指定一个端口 启动jupyter notebookjupyter notebook 此时应该可以直接从本地浏览器直接访问http://address_of_remote:8888就可以看到jupyter的登陆界面。 如果希望不要在退出SSH命令行的时候，同时也停止jupyter notebook服务，推荐nohup ，之前写过篇博客解释过nohup的作用在线python编译器就搭建好了，是不是很洋气~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://feiyang.li/tags/Jupyter/"},{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"}]},{"title":"第1.1题：Python图片添加水印","slug":"python_camp1","date":"2016-12-31T04:16:16.000Z","updated":"2017-04-16T07:27:53.862Z","comments":true,"path":"2016/12/31/python_camp1/index.html","link":"","permalink":"http://feiyang.li/2016/12/31/python_camp1/index.html","excerpt":"题目来自：Python 练习册，今天做的是第一题，将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。","text":"题目来自：Python 练习册，今天做的是第一题，将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 添加文字水印初始图像 我的头像 Python代码123456789101112131415from PIL import Image, ImageDraw, ImageFontdef add_num(img): draw = ImageDraw.Draw(img) myfont = ImageFont.truetype('C:/windows/fonts/Arial.ttf', size=40) fillcolor = \"#ff0000\" width, height = img.size draw.text((width-50, 5), '99', font=myfont, fill=fillcolor) img.save('result.jpg','jpeg') return 0if __name__ == '__main__': image = Image.open('F:/Picture/touxiang.jpg') add_num(image) image.show() 代码解释 from PIL import Image, ImageDraw, ImageFont 导入PIL图像处理库 draw = ImageDraw.Draw(img)，查了一下ImageDraw作用： 创建绘画对象 ImageDraw module creates drawing surface for image123import Image, ImageDrawim = Image.open(“vacation.jpeg\") drawSurface = ImageDraw.Draw(im) draw.text((width-50, 5), &#39;99&#39;, font=myfont, fill=fillcolor) 第一个括号填写的是位置，表示在x轴在width-50，y轴在5的位置加入文字，也就是右上角的意思。 效果展示 文字水印 添加图片水印Python代码1234567891011121314from PIL import Image, ImageDraw, ImageFontdef add_num(im,mark): layer = Image.new('RGBA', im.size, (0, 0, 0, 0)) layer.paste(mark, (im.size[0] - 150, im.size[1] - 150)) out = Image.composite(layer, im, layer) out.save('result.jpg','jpeg') out.show() return 0if __name__ == '__main__': image = Image.open('F:/Picture/touxiang.jpg') mark = Image.open('F:/Picture/1022.png') add_num(image,mark) 代码解释 Image.composite(layer, im, layer) 解释一下Image.composite()的意思使用案例Image.composite(image1, image2, mask) =&gt; image使用遮罩（mask）作为alpha，通过在两个图像之间进行插值来创建一个新图像。遮罩图像的模式可以是“1”，“L”，或者“RGBA”。所有的图像的大小必须有相同。 out.save(&#39;result.jpg&#39;,&#39;jpeg&#39;)，对图片进行保存，设置文件名和文件格式。 效果展示 图片水印 参考文章Python图像处理库：PIL中Image,ImageDraw等基本模块介绍","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"Python练习册","slug":"python_camp","date":"2016-12-31T03:35:04.000Z","updated":"2017-04-16T07:27:00.700Z","comments":true,"path":"2016/12/31/python_camp/index.html","link":"","permalink":"http://feiyang.li/2016/12/31/python_camp/index.html","excerpt":"参考代码一同附上，分析过程见李飞阳，请多指教。","text":"参考代码一同附上，分析过程见李飞阳，请多指教。 一、基础问题题目1.1：图片加水印，类似于微信未读信息数量那种提示效果 头像 题目1.2：使用 Python 如何生成 200 个激活码（或者优惠券） 题目1.3：将 0002 题生成的 200 个激活码（或者优惠券）保存到 MySQL 关系型数据库中。 题目1.4：任一个英文的纯文本文件，统计其中的单词出现的个数。 题目1.5：你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。 题目1.6：使用 Python 生成类似于下图中的字母验证码图片 字母验证码 阅读资料 题目1.7： 敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。 北京 程序员 公务员 领导 牛比 牛逼 你娘 你妈 love sex jiangge 题目1.8： 纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示： { &quot;1&quot;:[&quot;张三&quot;,150,120,100], &quot;2&quot;:[&quot;李四&quot;,90,99,95], &quot;3&quot;:[&quot;王五&quot;,60,66,68] } 请将上述内容写到 student.xls 文件中，如下图所示： student.xls 阅读资料 腾讯游戏开发 XML 和 Excel 内容相互转换 题目1.9： 通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。 阅读资料 用户密码的存储与 Python 示例 阅读资料 Hashing Strings with Python 阅读资料 Python’s safest method to store and retrieve passwords from a database 题目1.10： python输入二维数组 二、数据分析题目2.1：你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。 题目2.2：有个目录，里面是你自己写过的程序，统计一下你写过多少行代码。包括空行和注释，但是要分别列出来。 题目2.3： 登陆中国联通网上营业厅 后选择「自助服务」 –&gt; 「详单查询」，然后选择你要查询的时间段，点击「查询」按钮，查询结果页面的最下方，点击「导出」，就会生成类似于 2014年10月01日～2014年10月31日通话详单.xls 文件。写代码，对每月通话时间做个统计。 三、爬虫方面题目3.1：一个HTML文件，找出里面的正文。 题目3.2：一个HTML文件，找出里面的链接。 题目3.3： 用 Python 写一个爬图片的程序，可以参考Python爬取图片（使用urllib2），如果出现问题，可以尝试selenium自动化测试工具 四、Web问题题目4.1： 使用 Python 的 Web 框架，做一个 Web 版本 留言簿 应用。 阅读资料：Python 有哪些 Web 框架 留言簿参考 题目4.2： 使用 Python 的 Web 框架，做一个 Web 版本 TodoList 应用。 SpringSide 版TodoList 题目来自 易枭寒的Github","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"使用Python selenium处理页面延迟加载问题","slug":"Python-selenium","date":"2016-12-29T08:06:43.000Z","updated":"2017-03-27T11:44:39.069Z","comments":true,"path":"2016/12/29/Python-selenium/index.html","link":"","permalink":"http://feiyang.li/2016/12/29/Python-selenium/index.html","excerpt":"使用python爬取数据的时候，碰到了一个非常无语的问题。有个网站，在输入url进入页面之后，会强制加载一段动画，之后才显示正确内容。后来发现了selenium这个神器，不过还是折腾了我好久。","text":"使用python爬取数据的时候，碰到了一个非常无语的问题。有个网站，在输入url进入页面之后，会强制加载一段动画，之后才显示正确内容。后来发现了selenium这个神器，不过还是折腾了我好久。 用selenium 设置浏览器等待时间很多人问，这个下拉框定位不到、那个弹出框定位不到…各种定位不到，其实大多数情况下就是两种问题：1 有frame，2 没有加等待。殊不知，你的代码运行速度是什么量级的，而浏览器加载渲染速度又是什么量级的，就好比闪电侠和奥特曼约好去打怪兽，然后闪电侠打完回来之后问奥特曼你为啥还在穿鞋没出门？奥特曼分分中内心一万只羊驼飞过，欺负哥速度慢，哥不跟运行需要两个前提，每个都不好搞。。 首先需要安装selenium ，推荐使用pip安装,pip install selenium或者直接下载selenium包:https://pypi.python.org/pypi/selenium 解压，cmd进入目录:python setup.py install 接下来安装 ChromeDriver推荐在这里 https://sites.google.com/a/chromium.org/chromedriver/downloads 下载，然后放在Chrome浏览器目录内，配置Path环境变量为形如 XXGoogle\\Chrome\\Application的形式你玩了，抛个异常撂挑子了。 最简单粗暴的一种办法就是强制等待sleep(xx)，强制让闪电侠等xx时间，不管凹凸曼能不能跟上速度，还是已经提前到了，都必须等xx时间。 12345678# coding: utf-8from selenium import webdriverfrom time import sleepdriver = webdriver.Chrome()driver.get('https://feiyang.li')sleep(3) # 强制等待3秒再执行下一步print driver.titledriver.quit() 结合selenium使用Xpath获得所需信息 需要注意的是，selenium内find_elements的方法有很多种，xpath表达式的要求很严格，所以可以试试find_elements_id等方法。 Xpath表达式可以检测文字中是否包含某文字，以此为标准过滤。 mark Xpath表达式支持and 和 or。 1234def extract_from(browser): links = browser.find_elements_by_xpath(\"//p[contains(text(), '出处') or contains(text(), '组成') or contains(text(), '组成') or contains(text(), '主治') or contains(text(), '用法')] \") print(browser.title) return [link.text for link in links] 中文输入输出问题 send_keys() 不能正确的输入关键字，在中文前边加一个u即可，比如elem.send_keys(u&#39;你好哇&#39;) 不能正确的输出中文，print (&#39;\\n&#39;.join(extract_from(browser)))以上两个问题都跟python2的特性有关，升级至3之后应当不会出现此类问题。 写了一个小demo，解释中文输入输出问题12345678910111213141516171819# coding=utf-8import timefrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdef search(key): elem = browser.find_element_by_xpath(\"//input[@id='kw']\") elem.send_keys(key) elem.send_keys(Keys.RETURN) time.sleep(1)def extract_from(browser): links = browser.find_elements_by_xpath(\"//div[contains(text(),'李银河')]\") return [link.text for link in links]key = u\"你好哇\"browser = webdriver.Chrome()browser.get('http://www.baidu.com')search(key)print ('\\n'.join(extract_from(browser)))browser.close() 运行结果见下，可以抽取出对应文字。 运行结果 Code1234567891011121314151617181920212223242526272829303132# coding=utf-8import timeimport requestsfrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdef search(key): elem = browser.find_element_by_xpath(\"//input[@id='simple_search_filed']\") elem.send_keys(key) elem.send_keys(Keys.RETURN) time.sleep(3)def extract_from(browser): links = browser.find_elements_by_xpath(\"//p[contains(text(), '出处') or contains(text(), '组成') or contains(text(), '组成') or contains(text(), '主治') or contains(text(), '用法')] \") print(browser.title) return [link.text for link in links]from lxml import etreehtml = requests.get(\"http://www.zk120.com/fang/\")html.encoding = 'utf-8'selector = etree.HTML(html.text)content = selector.xpath(\"//ul/li/a/span[@class='free_icon_r']/../@href\")for imgurl in content: imgurl = \"http://www.zk120.com\" +imgurl browser = webdriver.Chrome() browser.get(imgurl) time.sleep(2) print ('\\n'.join(extract_from(browser))) print(\"------------\") browser.close() 参考代码在搜索资料的时候，同时发现了一个非常好的示例代码 1234567891011121314151617181920212223242526272829303132import refrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdef extract_data(browser): links = browser.find_elements_by_xpath('//i[@class=\"RecordStats\"]/a') return [link.get_attribute('href') for link in links]browser = webdriver.Firefox()browser.get(\"http://www.scba.gov.ar/jurisprudencia/Navbar.asp?Busca=Fallos+Completos&amp;SearchString=Inconstitucionalidad\")# get max pageselement = WebDriverWait(browser, 10).until(EC.presence_of_element_located((By.XPATH, \"//p[@class='c'][last()]\")))max_pages = int(re.search(r'\\d+ de (\\d+)', element.text).group(1), re.UNICODE)# extract from the current (1) pageprint \"Page 1\"print extract_data(browser)# loop over the rest of the pagesfor page in xrange(2, max_pages + 1): print \"Page %d\" % page next_page = browser.find_element_by_xpath(\"//table[last()]//td[last()]/a\").click() print extract_data(browser) print \"-----\" 这个地方真的花费了我好大的精力啊，让人头疼。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://feiyang.li/tags/爬虫/"},{"name":"Xpath","slug":"Xpath","permalink":"http://feiyang.li/tags/Xpath/"},{"name":"selenium","slug":"selenium","permalink":"http://feiyang.li/tags/selenium/"}]},{"title":"牛顿迭代法计算平方根(Java,Python实现)","slug":"Newton-Raphson_method-Java-Python","date":"2016-12-28T08:33:55.000Z","updated":"2017-03-27T11:44:42.774Z","comments":true,"path":"2016/12/28/Newton-Raphson_method-Java-Python/index.html","link":"","permalink":"http://feiyang.li/2016/12/28/Newton-Raphson_method-Java-Python/index.html","excerpt":"牛顿法的作用是使用迭代的方法来求解函数方程的根。简单地说，牛顿法就是不断求取切线的过程。","text":"牛顿法的作用是使用迭代的方法来求解函数方程的根。简单地说，牛顿法就是不断求取切线的过程。 数学推导假设c为原数，t为c的根数。 $$ t^2 \\quad = \\quad c$$$$2t^2 \\quad = \\quad c + \\quad t^2$$$$2t \\quad = \\quad \\frac{c}{t}+ \\quad t$$$$t \\quad = \\quad \\frac{\\frac{c}{t} + t}{2.0}$$ Java代码实现123456789101112131415161718192021package test;import java.io.IOException;import java.util.Scanner;public class QuickFindUF &#123; public static double sqrt (double c)&#123; if(c&lt;0) return Double.NaN; double err = 1e-15; double t = c; while(Math.abs(t-c/t)&gt;err) t = (c/t+t)/2.0; return t; &#125; public static void main(String args[]) throws IOException&#123; Scanner sc = new Scanner(System.in); double a = sqrt(sc.nextDouble()); System.out.println(a); &#125;&#125; Python代码实现123456c = input()err = 1e-15t = cwhile abs(t - c/t)&gt;err: t = (c/t+t)/2.0print(t) Python代码真心简洁啊","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"Java","slug":"Java","permalink":"http://feiyang.li/tags/Java/"}]},{"title":"LaTex 编辑公式","slug":"LaTex","date":"2016-12-28T07:21:21.000Z","updated":"2017-02-11T13:23:33.245Z","comments":true,"path":"2016/12/28/LaTex/index.html","link":"","permalink":"http://feiyang.li/2016/12/28/LaTex/index.html","excerpt":"在计算机直接输入数学公式是一件棘手的事情，我一般是用一个专业的数学工具MathType，但最近在使用Markdown写作，遂产生念头用LaTex输入公式。发现目前网上的语法介绍往往不够全面，于是自己写了一份。","text":"在计算机直接输入数学公式是一件棘手的事情，我一般是用一个专业的数学工具MathType，但最近在使用Markdown写作，遂产生念头用LaTex输入公式。发现目前网上的语法介绍往往不够全面，于是自己写了一份。 LaTex 公式通用语法 使用单 $ 围住表达式，居左展示。 使用双 $$ 围住表达式，可以居中显示。 空格当前环境标准字体宽度为 M 两个quad空格 a \\qquad b 两个m的宽度$$ C_1 \\qquad C_2 $$$$ C_1 \\qquad C_2 $$ quad空格 a \\quad b 一个m的宽度$$ C_1 \\quad C_2 $$$$ C_1 \\quad C_2 $$ 大空格 a\\ b 1/3m宽度$$ C_1 \\ C_2 $$$$ C_1 \\ C_2 $$ 中等空格 C_1\\;C_2 2/7m宽度$$C_1\\;C_2$$$$C_1\\;C_2$$ 小空格 C_1\\,C_2 1/6m宽度$$C_1\\,C_2$$$$C_1\\,C_2$$ 没有空格 C_1C_2$$C_1C_2$$$$C_1C_2$$ 紧贴 C_1!C_2 缩进1/6m宽度$$C_1\\!C_2$$ 上下标 上标符号 ^$$ c_{1}^{2}=a^{2}+b^{2} $$$$ c_{1}^{2}=a^{2}+b^{2} $$ 下标符号_$$C_{m,n}$$$$C_{m,n}$$ 希腊字母$$\\lambda,\\xi,\\pi,\\mu,\\Phi,\\Omega,\\alpha, \\beta, \\gamma,\\Gamma, \\Delta $$$$\\lambda,\\xi,\\pi,\\mu,\\Phi,\\Omega,\\alpha, \\beta, \\gamma,\\Gamma, \\Delta $$ 值比较符 大于等于小于，使用正常&gt;,&lt;,=即可 大于等于使用 \\geq$$e^{x^2} \\geq {e^x}^2$$$$e^{x^2} \\geq {e^x}^2$$ 小于等于使用\\leq$$e^{x^2} \\leq {e^x}^2$$$$e^{x^2} \\leq {e^x}^2$$ 不等于使用neq$$e^{x^2} \\neq {e^x}^2$$$$e^{x^2} \\neq {e^x}^2$$ 平方根使用\\sqrt或 \\surd$$\\sqrt{x+y}$$$$\\sqrt{x+y}$$ 水平线使用 \\overline,\\underline$$\\overline{m+n} \\quad \\underline{m+n}$$$$\\overline{m+n} \\quad \\underline{m+n}$$ 水平括号使用\\overbrace 和 \\underbrace$$ \\underbrace{a+b+\\cdots+z}_{26}$$$$ \\underbrace{a+b+\\cdots+z}_{26}$$ 重音号使用\\widetilde 和 \\widehat$$y’=3\\widetilde a+4\\widehat b$$ 向量使用\\overrightarrow 和 \\overleftarrow$$\\overrightarrow {AC} = \\overrightarrow {AB} +\\overrightarrow {BC} $$$$\\overrightarrow {AC} = \\overleftarrow {AB} +\\overrightarrow {BC} $$ 圆点使用\\cdot, \\cdots,\\vdots,\\ddot$$ a \\vdots =b \\cdot c \\cdots d \\ddot e$$$$ a \\vdots =b \\cdot c \\cdots d \\ddot e$$ 函数名\\arccos \\cos \\csc \\arcsin \\cosh \\deg \\arctan \\cot \\det \\arg \\coth \\dim \\sinh \\sup \\tan [\\lim_{x \\rightarrow 0} \\frac{\\sin x}{x}=1] \\exp \\ker \\limsup \\min \\gcd \\lg \\ln \\Pr \\hom \\lim \\log \\sec \\inf \\liminf \\max \\sin \\tanh $$lim_{x \\rightarrow 0} \\frac{\\sin x}{x}=1$$$$lim_{x \\rightarrow 0} \\frac{\\sin x}{x}=1$$ 数学符\\mathbf$$ x^{2} \\geq 0\\qquad \\textrm{for all }x\\in\\mathbf{R} $$$$ x^{2} \\geq 0\\qquad \\textrm{for all }x\\in\\mathbf{R} $$ 分数直接输入或者\\frac{}{} $$\\sin \\alpha = \\frac{a}{c} $$$$\\sin \\alpha = \\frac{a}{c} $$ $$x^{1/2} $$$$x^{1/2} $$ 二项系数{… \\choose …} 或 {… \\atop …}。第二个命令与第一个命令的输出相同,只是没有括号。$${n\\choose m} \\qquad {x\\atop y+2}$$$${n\\choose m} \\qquad {x\\atop y+2}$$ 前缀符号\\int,\\sum,\\prod $$ {\\int_{0}^{\\frac{\\pi}{2}}} $$$$ {\\int_{0}^{\\frac{\\pi}{2}}} $$ $$ \\sum_{i=1}^{n}$$$$ \\sum_{i=1}^{n}$$ $$\\prod_\\epsilon$$$$\\prod_\\epsilon$$ 转义符号有时保留字需要加入\\来进行转义$${a,b,c}\\neq\\{a,b,c\\}$$$${a,b,c}\\neq{a,b,c}$$ 括号层次 正确的括号大小\\left和\\right。如果将命令 \\left 放在开分隔符前,TEX会自动决定分隔符的正确大 小。注意必须用对应的右分隔符 \\right 来关闭每一个左分隔符 \\left,并 且只有当这两个分隔符排在同一行时大小才会被正确确定。我们可以看到右式没有采用\\left形式，不能正确确定括号大小$$ 1+\\left(\\frac {1}{1-x^2}\\right) ^3 \\qquad 1+(\\frac {1}{1-x^2}) ^3$$$$ 1+\\left(\\frac {1}{1-x^2}\\right) ^3 \\qquad 1+(\\frac {1}{1-x^2}) ^3$$ 另外也可以手工指出括号大小，使用\\big,\\Big,\\bigg,\\Bigg。 $$ \\Big( (x+y) (x-y) \\Big)^{2} $$$$ \\Big( (x+y) (x-y) \\Big)^{2} $$ $$\\big(\\Big(\\bigg(\\Bigg($$$$\\big(\\Big(\\bigg(\\Bigg($$ $$\\big\\}\\Big\\}\\bigg\\}\\Bigg\\} $$$$\\big}\\Big}\\bigg}\\Bigg} $$ $$\\big\\|\\Big\\|\\bigg\\|\\Bigg\\| $$$$\\big|\\Big|\\bigg|\\Bigg| $$ 垂直对齐使用array命令，并\\命令来分行。注意转义 123456$$\\mathbf&#123;X&#125; = \\left( \\begin&#123;array&#125;&#123;ccc&#125; x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \\ldots \\\\\\ x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \\ldots \\\\\\ \\vdots &amp; \\vdots &amp; \\ddots \\end&#123;array&#125; \\right) $$","categories":[],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://feiyang.li/tags/LaTex/"}]},{"title":"Nginx环境下配置HTTPS","slug":"Nginx_HTTPS","date":"2016-12-18T08:47:29.000Z","updated":"2017-04-16T07:26:15.285Z","comments":true,"path":"2016/12/18/Nginx_HTTPS/index.html","link":"","permalink":"http://feiyang.li/2016/12/18/Nginx_HTTPS/index.html","excerpt":"现在，你应该能在访问https://feiyang.li 的时候，在地址栏里看到一个漂亮的小绿锁 作为肤浅的人，为了这么洋气的小绿锁也要上HTTPS~","text":"现在，你应该能在访问https://feiyang.li 的时候，在地址栏里看到一个漂亮的小绿锁 作为肤浅的人，为了这么洋气的小绿锁也要上HTTPS~ 申请免费SSL证书普通的SSL证书动辄好几千，简直令人发指。不过别担心，我找到了3个免费申请HTTPS证书的方式。 StartSSL也免费提供了一个证书（纯英文）申请地址：https://www.startssl.com/Account?r=L1ZhbGlkYXRl 阿里云免费提供的证书https://common-buy.aliyun.com/?spm=5176.7968328.231195.3.Vh92u7&amp;commodityCode=cas#/buy 腾讯云免费申请https://console.qcloud.com/ssl 获得证书之后，下载至本地。 VPS上安装SSL证书以Nginx 为例 获取证书Nginx文件夹内获得SSL证书文件 1_www.domain.com_bundle.crt 和私钥文件 2_www.domain.com.key, 1_www.domain.com_bundle.crt 文件包括两段证书代码 “—–BEGIN CERTIFICATE—–”和“—–END CERTIFICATE—–”,2_www.domain.com.key 文件包括一段私钥代码“—–BEGIN RSA PRIVATE KEY—–”和“—–END RSA PRIVATE KEY—–”。 上传和部署SSL证书将域名 www.domain.com 的证书文件1_www.domain.com_bundle.crt 、私钥文件2_www.domain.com.key保存到同一个目录，例如/usr/local/nginx/conf目录下。更新Nginx根目录下 conf/nginx.conf 文件如下：123456789101112131415server &#123; listen 443; server_name www.domain.com; #填写绑定证书的域名 ssl on; ssl_certificate 1_www.domain.com_bundle.crt; ssl_certificate_key 2_www.domain.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; root html; #站点目录 index index.html index.htm; &#125; &#125; 配置文件参数 说明 listen 443 SSL访问端口号为443 ssl on 启用SSL功能 ssl_certificate 证书文件 ssl_certificate_key 私钥文件 ssl_protocols 使用的协议 ssl_ciphers 配置加密套件，写法遵循openssl标准 重启Nginx输入 nginx -s reload ：修改配置后重新加载生效可以看到SSL证书生效，且HTTPS可以访问站点。","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"},{"name":"Nginx","slug":"Nginx","permalink":"http://feiyang.li/tags/Nginx/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://feiyang.li/tags/HTTPS/"}]},{"title":"使用Python插入排序","slug":"Python_get_order","date":"2016-12-15T13:44:51.000Z","updated":"2017-03-09T14:37:28.515Z","comments":true,"path":"2016/12/15/Python_get_order/index.html","link":"","permalink":"http://feiyang.li/2016/12/15/Python_get_order/index.html","excerpt":"使用Python进行数据结构操作比较少见，但为了更深入的理解Python的操作原理，提升自己的算法能力。我决定认真过一遍 普林斯顿大学教授Robert Sedgewick主讲的《Algorithms》","text":"使用Python进行数据结构操作比较少见，但为了更深入的理解Python的操作原理，提升自己的算法能力。我决定认真过一遍 普林斯顿大学教授Robert Sedgewick主讲的《Algorithms》 【普林斯顿算法下载链接】普林斯顿大学教授Robert Sedgewick主讲的《Algorithms》 使用C++插入排序12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; int a[] = &#123; 4,3,9,0,1,2,5,6,7,8 &#125;; for(int i = 1; i &lt; 10; i++) &#123; int key = a[i]; int j = i - 1; while (j &gt;= 0&amp;&amp;a[j] &gt; key) &#123; a[j + 1] = a[j]; j--; &#125; a[j + 1] = key; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 这一段比较简单，我也就不多说了。 使用Python进行排序123456789data = [4,3,9,0,1]for i in range(1,len(data)): key = data[i] j = i - 1 while j &gt;= 0 and data[j] &gt; key: data[j+1]=data[j] j = j - 1 data[j+1] = keyprint(data) 总结： Python的确比CPP简洁得多； while循环体中条件部分可以使用 and ，不能用&amp;&amp; python没有{}，需要对齐，输入Tab或者敲空格。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"sort","slug":"sort","permalink":"http://feiyang.li/tags/sort/"}]},{"title":"Python爬取图片（使用urllib2）","slug":"Python_use_urllib2","date":"2016-12-15T11:14:24.000Z","updated":"2017-04-16T07:21:08.292Z","comments":true,"path":"2016/12/15/Python_use_urllib2/index.html","link":"","permalink":"http://feiyang.li/2016/12/15/Python_use_urllib2/index.html","excerpt":"上篇文章 使用 XPath 提取网页信息 之后，将链接中的内容下载至本地，需要使用到 urllib2 。","text":"上篇文章 使用 XPath 提取网页信息 之后，将链接中的内容下载至本地，需要使用到 urllib2 。 urllib2 简介urllib2提供一个基础函数urlopen，通过向指定的URL发出请求来获取数据。最简单的形式就是： 123import urllib2 response = urllib2.urlopen('http://feiyang.li/') html = response.read() 可以将上述代码看作两个步骤，我们指定一个域名并发送请求1request=urllib2.request(&apos;http://feiyang.li/&apos;) 接着服务端响应来自客户端的请求 1response=urllib2.urlopen(request) 运行结果 我们可以发现title这个地方本来应该是中文的，但因为编码的原因，导致出现乱码。通过将html页面重新用”utf-8”编码，可以解决这个问题。 将获得的response保存至本地使用Xpath表达式提取图片链接详见上一文章 http://feiyang.li/2016/12/13/get_html/ ，关于XPath和beautifulsoup，可以参考python中的beautifulsoup和xpath有什么异同点？ 这里需要导入lxml，代码格式如下。 123456import requestsfrom lxml import etreehtml = requests.get(\"http://jandan.net/ooxx\")html.encoding = 'utf-8'selector = etree.HTML(html.text)content = selector.xpath('//ol[@class = \"commentlist\"]//@src') 单独运行 以上代码可以获得 Xpath运行结果 设置保存的位置需要使用到os库中的 os.chdir(r””)函数，””中间插入地址。注意这个位置必须是存在的，如果位置不存在，函数会报错。因为该函数的意义是：将工作空间从python代码所在位置，改为指定的这个位置。 模拟正常浏览器下载图片（如果Python下载的图片不显示 ）有时你会碰到，程序也对，但是服务器拒绝你的访问。这是为什么呢? 问题出在请求中的头信息(header)。 有的服务端有洁癖，不喜欢程序来触摸它。 这个时候你需要将你的程序伪装成浏览器来发出请求。请求的方式就包含在header中。 123456header = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.114 Safari/537.36', 'Cookie': 'AspxAutoDetectCookieSupport=1', &#125; request = urllib2.Request(imgurl, None, header) response = urllib2.urlopen(request) 可以看到urllib2.Request()里边加入了一个header，用于模拟浏览器访问，第二个位置None表示data，用Python官方文档的说法：Sometimes you want to send data to a URL (often the URL will refer to a CGI (Common Gateway Interface) script [1] or other web application). With HTTP, this is often done using what’s known as a POST request. 暂时我们用不着，所以不深究，等我碰到这个问题了再说。 为图片命名（下载图片只有一张）在获得response之后，将图片直接保存为某个特定名字的话。会导致之后抓取到的图片顶替掉之前的图片，导致图片看起来只有一张。 1234with open(\"%s.jpg\" %name, \"wb\") as f: f.write(response.read()) print(imgurl) name += 1 使用with as语句，将文件名保存为%s.jpg，类似于C语言的输出。循环结束的时候name++，保证文件名不重复。 使用with as 函数Python’s with statement provides a very convenient way of dealing with the situation where you have to do a setup and teardown to make something happen. A very good example for this is the situation where you want to gain a handler to a file, read data from the file and the close the file handler.有一些任务，可能事先需要设置，事后做清理工作。对于这种场景，Python的with语句提供了一种非常方便的处理方式。一个很好的例子是文件处理，你需要获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。 Without the with statement, one would write something along the lines of:如果不用with语句，代码如下：123file = open(\"/tmp/foo.txt\")data = file.read()file.close() 使用with as之后代码为：12with open(\"%s.jpg\" %name, \"wb\") as f: f.write(response.read()) 总结本文通过XPath表达式提取页面图片链接，使用urllib2下载，其中使用header模仿浏览器访问。解决了以下问题： Python下载的图片不显示 下载图片只有一张 设置保存的位置 使用with f函数 效果如下： 抓取到的图片 完整代码 # coding=utf-8 import requests import urllib2 import os from lxml import etree html = requests.get(\"http://cl.d5j.biz/htm_mob/7/1612/2172569.html\") html.encoding = 'utf-8' selector = etree.HTML(html.text) content = selector.xpath('//table//img/@src') for imgurl in content: name = imgurl[-9:]; os.chdir(r\"D:\") header = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.114 Safari/537.36', 'Cookie': 'AspxAutoDetectCookieSupport=1', } request = urllib2.Request(imgurl, None, header) #刻意增加头部header，否则本行与下一行可以写为：response = urllib2.urlopen(imgurl) response = urllib2.urlopen(request) f = open(name , 'wb') f.write(response.read()) f.close() print(imgurl) 代码重新修改了一下，上手运行会发现D盘有惊喜哦~加入print(imgurl)，运行起来更洋气~ 输入下载来源","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://feiyang.li/tags/爬虫/"},{"name":"urllib2","slug":"urllib2","permalink":"http://feiyang.li/tags/urllib2/"}]},{"title":"使用 XPath 提取网页信息","slug":"get_html","date":"2016-12-13T08:24:34.000Z","updated":"2017-04-16T07:11:39.517Z","comments":true,"path":"2016/12/13/get_html/index.html","link":"","permalink":"http://feiyang.li/2016/12/13/get_html/index.html","excerpt":"以1024举例，使用XPath提取图片链接以及磁力链接地址。","text":"以1024举例，使用XPath提取图片链接以及磁力链接地址。 学习XPath的基本知识推荐 Xpath教程 很容易理解。推荐可以将常用的语法记下来，不常用的可以等用的时候再查。 推荐使用Chrome浏览器中的XPath Helper，良心之作. 左边输入XPath表达式，右侧会自动展示结果。 选择元素之后按下ctral + shift + x，可以自动提取该元素的XPath表达式。 使用Xpath Helper自带提取功能 常用语法 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 @ 选取属性，常见使用方法为[@class = “title”] 举例，比如在双面胶-淘宝搜索 页面 输入: //*[@class=”m-itemlist”]//a[@trace-price&lt;20]/@href，用来提取出class为itemlist内a标签里所有price 小于20的产品，并将其href(即超链接)输出 结果展示 需要结合Chrome浏览器的F12一起使用，先选定大致的框架，比如itemlist这个class，然后逐渐加上更多的要求，具体见文首给出的链接学习。 知道这些就可以抓取1024上的图片和磁力链接了，目测是不是很简单 挑选网页实验一下 作为一名1024资深游客，首先在技术讨论区选择一篇好文，这里用的是[榴民资讯]11月精品主题推荐（49期） 使用F12查看网页的结构有两个主要标签 header 和 main ，鼠标移动到main上，可以看到内容页面都被包含起来，所以第一个节点应该选main。 main标签 使用XPath表达式筛选图片链接我们看到图片前边都有一个属性src，这个src后边就是我们所需的图片链接。 综上，使用XPath表达式: //*[@id=”main”]//@src mark 输入XPath代码，获得图片链接。 mark 使用XPath表达式筛选磁力链接同理，我们可以发现，磁力链接前边都有一个blockquote，与上一条处理方式类似，使用XPath表达式: //*[@id=”main”]//blockquote 磁力链接 以上","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://feiyang.li/tags/爬虫/"},{"name":"Xpath","slug":"Xpath","permalink":"http://feiyang.li/tags/Xpath/"}]},{"title":"永远的7012","slug":"forever_7012","date":"2016-10-28T13:33:08.000Z","updated":"2017-04-16T07:10:32.051Z","comments":true,"path":"2016/10/28/forever_7012/index.html","link":"","permalink":"http://feiyang.li/2016/10/28/forever_7012/index.html","excerpt":"Gary要从Running man下车了，这真是10月以来最悲伤的一件事了。","text":"Gary要从Running man下车了，这真是10月以来最悲伤的一件事了。 慌张在这件事情还没有成为热搜之前，室友私下给我发了这个消息。 当时我第一反应就觉得是假的，“怎么可能嘛，Gary之前说过七个人要永远在一起的啊。” 就算我信誓旦旦的否认了，可还是忍不住又把这个消息多看了好几遍，想找到这是个假消息的依据。 可到后来我越看越慌，直到过了两个小时以后，热搜出现Gary的名字，我才被迫相信，但还是不愿接受。 缘起其实我并没有认识他们太长时间，但却在最短的时间内被他们所吸引。 因为他们七个人，让我爱上了一个国家。 我觉得这就是韩国跑男的魅力吧，他们永远谦逊，努力，敬业，总是希望把最好的一面呈献给观众。他们七个人的感情好到让我嫉妒，多少不经意间的小动作让我们觉得这就是一家人的感觉，这种感情，绝对不是靠”We are family“就能喊出来的。 七年Running man在一起跑了七年了，每个周一都准时准点的出现在我们面前，风雨无阻，真的不是所有的综艺都可以坚持那么久的。 王鼻子大叔已经50岁了，体力明显跟不上了。 金钟国浑身是伤，根本无法再扮演能力者的角色。 其他的成员也是或多或少身体状况都不佳，不可能再回到大规模撕名牌的环节中。 我们看得出来现在的running man确实不如以前好看了，可是看到他们七个人在一起，就是最开心的事。 我知道我们总有一天要和Runningman告别，我也曾想过很多次他们会以怎样的方式跟我们说再见。可这种方式是我最不愿意见到的。 与其Gary一人离开，不如节目就到此为止吧。 因为在我心里，他们就是一个整体，谁也不能替代，谁也无法分割。 不知道RM以后会怎么发展下去，但我知道所有深爱过这个节目的人，都不会责怪他们。 就算不舍，也会把最真的祝福送给每一位成员。并且要告诉他们：谢谢他们七年的陪伴，谢谢他们为我们所做的努力，谢谢他们给我们带来那么多的快乐。 综艺人姜Gary，我们有缘再见！音乐人姜Gary，我们敬请期待！","categories":[],"tags":[{"name":"臭臭","slug":"臭臭","permalink":"http://feiyang.li/tags/臭臭/"},{"name":"Running man","slug":"Running-man","permalink":"http://feiyang.li/tags/Running-man/"}]},{"title":"C / C++ 文件读取写入、文件夹的打开","slug":"C_read","date":"2016-10-28T11:09:24.000Z","updated":"2017-02-11T13:27:15.125Z","comments":true,"path":"2016/10/28/C_read/index.html","link":"","permalink":"http://feiyang.li/2016/10/28/C_read/index.html","excerpt":"使用C++做文件处理时常用的几个函数","text":"使用C++做文件处理时常用的几个函数 文件的打开与关闭 (open和close函数)文件读取之前，使用open函数进行打开。文件使用完毕后，使用close命令关闭。 12infile.open(\"E:\\\\hello.txt\");infile.close(); 文件读取与写入(infile &gt;&gt; income,outfile &lt;&lt; “income:”)C++中可以调用库 #include&lt;fstream&gt; 之后可以使用，”&gt;&gt;”和”&lt;&lt;”输入输出流的形式进行文件的读取 12345678while (infile &gt;&gt; income) &#123; if (income &lt; cutoff) tax = rate1*income; else tax = rate2*income; outfile &lt;&lt; \"income:\"&lt;&lt;left&lt;&lt;setw(6) &lt;&lt; income &lt;&lt; right&lt;&lt;setw(8) &lt;&lt; \"Tax:\" &lt;&lt;tax&lt;&lt; endl; &#125; 文件夹/文件的打开在程序运行完之后，你可能会希望自动将输出的结果文件打开。调 Windows Exploler 打开一个文件夹， 1system(\"start E:\\\\tax.out\"); E:\\tax.out 就是你文件的地址 运行程序demo读取hello.txt文件内的收入数据，计算税金，并输出到tax.txt中 demo hello.txt，直接 Ctrl+S 保存到E盘即可 C++代码如下1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;iomanip&gt;using namespace std;const int cutoff = 6000;const float rate1 = 0.3;const float rate2 = 0.6;void main() &#123; ifstream infile; ofstream outfile; int income, tax; infile.open(\"E:\\\\hello.txt\"); outfile.open(\"E:\\\\tax.txt\"); while (infile &gt;&gt; income) &#123; if (income &lt; cutoff) tax = rate1*income; else tax = rate2*income; outfile &lt;&lt; \"income:\"&lt;&lt;left&lt;&lt;setw(6) &lt;&lt; income &lt;&lt; right&lt;&lt;setw(8) &lt;&lt; \"Tax:\" &lt;&lt;tax&lt;&lt; endl; &#125; infile.close(); outfile.close(); cout &lt;&lt; \"done\"&lt;&lt;endl; system(\"start E:\\\\tax.txt\");&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://feiyang.li/tags/C/"}]},{"title":"《解忧杂货店》","slug":"book","date":"2016-10-28T04:30:59.000Z","updated":"2017-04-16T07:25:03.332Z","comments":true,"path":"2016/10/28/book/index.html","link":"","permalink":"http://feiyang.li/2016/10/28/book/index.html","excerpt":"我一直很努力去当一个善良的人，却总是在现实中受到各种打击。","text":"我一直很努力去当一个善良的人，却总是在现实中受到各种打击。 以至于让我觉得根本不需要总是对别人那么好，或者说其实我希望可以一直对别人保持一颗有爱的心，只不过我需要力量支撑而已。 而解忧杂货店就给了我这种力量。 解忧杂货店 浪矢爷爷说，人的心声是最不能被忽视的。所以不管是什么内容的信，玩笑的或是严肃的，甚至是一张白纸，他都会认认真真的回复。 因为人与人之间本来就是相互影响的，你的一举一动，一句在你看来是无所谓的话，却可能对别人造成很大的影响。 不要总想着设身处地，我们永远不是别人，总是很难站在别人角度考虑问题，稍不留神就以己度人了。 所以，子所不欲勿施于人，己所欲也勿施于人。 收到那么多封烦恼咨询信后，我慢慢发现其实很多人在写信的时候心里就已经有自己的答案了，他们写信的目的就是为了让别人可以支持他们的想法。 但他们读过回信之后会再写信过来，就说明双方观点不太一样。所以才会反反复复进行那么多次通信，就为了说服别人同意自己的想法。 我就想到每次我想买啥东西又不好意思买的时候，就会假装向阳询问，而阳就会 二话不说 立马给我买了。他竟然那么早就懂了这个道理，真是好棒呀！ 我不知道别人判断一本好书的标准是什么，我不认识东野圭吾，不知道kindle里边他的排名，就只是很喜欢这种故事，有爱情，有亲情，有事业，有梦想。 很平凡，平凡到感觉里边的人物就是生活中的你和我。但文学总是高于生活的，时空的交错，奇妙的构思让我觉得善良的人在冥冥之中总会受到保佑。 文章中的最后一段话好像是这样的，敦也从信纸上抬起头，正好对上了另两个人的视线，他发现他俩的眼里闪着光芒，他想他的眼里也一定是这样的。而我想说，读完这本书以后，我也是这样的感觉。 mark","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"臭臭","slug":"臭臭","permalink":"http://feiyang.li/tags/臭臭/"}]},{"title":"Python基础","slug":"Python_basic","date":"2016-10-27T03:38:32.000Z","updated":"2017-03-27T11:44:35.727Z","comments":true,"path":"2016/10/27/Python_basic/index.html","link":"","permalink":"http://feiyang.li/2016/10/27/Python_basic/index.html","excerpt":"脚本运行 Windows 下需将python加入的系统变量中； Linux 下需添加头部","text":"脚本运行 Windows 下需将python加入的系统变量中； Linux 下需添加头部 12#! /usr/bin/enc python print('Hello World!') 循环 for 循环for 元素 in 序列: statement while 循环while 条件: statement 函数函数的定义123def square_sum(a,b): c = a**2 + b**2 return c def，这个关键字通知python：我在定义一个函数。square_sum是函数名。括号中的a, b是函数的参数，是对函数的输入。 函数调用和参数传递12345678910111213141516171819a = 1def change_integer(a): a = a + 1 return aprint (change_integer(a)) #注意观察结果print (a) #注意观察结果#===(Python中 \"#\" 后面跟的内容是注释，不执行 )b = [1,2,3]def change_list(b): b[0] = b[0] + 1 return bprint (change_list(b)) #注意观察结果print (b) #注意观察结果 运行结果 第一个例子，我们将一个整数变量传递给函数，函数对它进行操作，但原整数变量a不发生变化。第二个例子，我们将一个表传递给函数，函数进行操作，原来的表b发生变化。对于基本数据类型的变量，变量传递给函数后，函数会在内存中复制一个新的变量，从而不影响原来的变量。（我们称此为值传递）但是对于表来说，表传递给函数的是一个指针，指针指向序列在内存中的位置，在函数中对表的操作将在原有内存中进行，从而影响原有变量。 （我们称此为指针传递）。 类我们定义一个类“鸟”，鸟有羽毛，鸟的方法是下蛋，定义一个函数fly()。123456789101112class Bird(object): feather = True way = 'egg' def fly(self, dx, dy): position = [0,0] position[0] = position[0] + dx position[1] = position[1] + dy return positionsummer = Bird()print (after move:',summer.fly(5,8)) 方法的第一个参数必须是self，无论是否用到。 我的summer可以飞了。 常见python os 命令 os.getcwd() 函数得到当前工作目录，即当前Python脚本工作的目录路径。 os.listdir() 返回指定目录下的所有文件和目录名。 os.remove() 删除一个文件。 os.chdir(dirname) 改变工作目录到dirname","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Android正则表达式及Pattern Matcher使用","slug":"Android_Pattern Matcher","date":"2016-10-19T13:25:57.000Z","updated":"2016-10-20T07:14:18.936Z","comments":true,"path":"2016/10/19/Android_Pattern Matcher/index.html","link":"","permalink":"http://feiyang.li/2016/10/19/Android_Pattern Matcher/index.html","excerpt":"Pattern Matcher使用众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生","text":"Pattern Matcher使用众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生 而这些情况有时又比较复杂，如果用纯编码方式解决，往往会浪费程序员的时间及精力。因此，学习及使用正则表达式，便成了解决这一矛盾的主要手段。 一个正则表达式就是由普通的字符（例如字符a到z）以及特殊字符（元字符）组成的文字模式，它用以描述在查找文字主体时待匹配的一个或多个字符串。 加入特定限制条件「[]」 [a-z] 条件限制在小写a to z范围中一个字符 [A-Z] 条件限制在大写A to Z范围中一个字符 [a-zA-Z] 条件限制在小写a to z或大写A to Z范围中一个字符 [0-9] 条件限制在小写0 to 9范围中一个字符 [0-9a-z] 条件限制在小写0 to 9或a to z范围中一个字符 [0-9[a-z]] 条件限制在小写0 to 9或a to z范围中一个字符(交集) []中加入^后加再次限制条件「[^]」 [^a-z] 条件限制在非小写a to z范围中一个字符 [^A-Z] 条件限制在非大写A to Z范围中一个字符 [^a-zA-Z] 条件限制在非小写a to z或大写A to Z范围中一个字符 [^0-9] 条件限制在非小写0 to 9范围中一个字符 [^0-9a-z] 条件限制在非小写0 to 9或a to z范围中一个字符 [^0-9[a-z]] 条件限制在非小写0 to 9或a to z范围中一个字符(交集) 在限制条件为特定字符出现0次以上时，可以使用「*」 J* 0个以上J .* 0个以上任意字符 J.*D J与D之间0个以上任意字符 在限制条件为特定字符出现1次以上时，可以使用「+」 J+ 1个以上J .+ 1个以上任意字符 J.+D J与D之间1个以上任意字符 Pattern Matcher的例子查找以Java开头,任意结尾的字符串1234Pattern pattern = Pattern.compile(\"^Java.*\"); Matcher matcher = pattern.matcher(\"Java不是人\"); boolean b= matcher.matches(); //当条件满足时，将返回true，否则返回false System.out.println(b); 以多条件分割字符串时12345Pattern pattern = Pattern.compile(\"[, |]+\"); String[] strs = pattern.split(\"Java Hello World Java,Hello,,World|Sun\"); for (int i=0;i&lt;strs.length;i++) &#123; System.out.println(strs[i]); &#125; 文字替换（首次出现字符）12345Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World\"); //替换第一个符合正则的数据 System.out.println(matcher.replaceFirst(\"Java\")); ` 文字替换（全部）12345Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World\"); //替换第一个符合正则的数据 System.out.println(matcher.replaceAll(\"Java\")); ` 文字替换（置换字符）12345678Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World \"); StringBuffer sbr = new StringBuffer(); while (matcher.find()) &#123; matcher.appendReplacement(sbr, \"Java\"); &#125; matcher.appendTail(sbr); System.out.println(sbr.toString()); 验证是否为邮箱地址1234String str=\"ceponline@yahoo.com.cn\"; Pattern pattern = Pattern.compile(\"[//w//.//-]+@([//w//-]+//.)+[//w//-]+\",Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(str); System.out.println(matcher.matches()); 查找html中对应条件字符串12345Pattern pattern = Pattern.compile(\"href=/\"(.+?)/\"\"); Matcher matcher = pattern.matcher(\"&lt;a href=/\"index.html/\"&gt;主页&lt;/a&gt;\"); if(matcher.find()) System.out.println(matcher.group(1)); &#125; 截取http://地址12345678Pattern pattern = Pattern.compile(\"(http://|https://)&#123;1&#125;[//w//.//-/:]+\"); Matcher matcher = pattern.matcher(\"dsdsds&lt;http://dsds//gfgffdfd&gt;fdf\"); StringBuffer buffer = new StringBuffer(); while(matcher.find())&#123; buffer.append(matcher.group()); buffer.append(\"/r/n\"); System.out.println(buffer.toString()); &#125; 替换指定{}中文字12345678910public static String replace(final String sourceString,Object[] object) &#123; String temp=sourceString; for(int i=0;i&lt;object.length;i++)&#123; String[] result=(String[])object[i]; Pattern pattern = Pattern.compile(result[0]); Matcher matcher = pattern.matcher(temp); temp=matcher.replaceAll(result[1]); &#125; return temp; &#125; 以正则条件查询指定目录下文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//用于缓存文件列表 private ArrayList files = new ArrayList(); //用于承载文件路径 private String _path; //用于承载未合并的正则公式 private String _regexp; class MyFileFilter implements FileFilter &#123; /** * 匹配文件名称 */ public boolean accept(File file) &#123; try &#123; Pattern pattern = Pattern.compile(_regexp); Matcher match = pattern.matcher(file.getName()); return match.matches(); &#125; catch (Exception e) &#123; return true; &#125; &#125; &#125; /** * 解析输入流 * @param inputs */ FilesAnalyze (String path,String regexp)&#123; getFileName(path,regexp); &#125; /** * 分析文件名并加入files * @param input */ private void getFileName(String path,String regexp) &#123; //目录 _path=path; _regexp=regexp; File directory = new File(_path); File[] filesFile = directory.listFiles(new MyFileFilter()); if (filesFile == null) return; for (int j = 0; j &lt; filesFile.length; j++) &#123; files.add(filesFile[j]); &#125; return; &#125; /** * 显示输出信息 * @param out */ public void print (PrintStream out) &#123; Iterator elements = files.iterator(); while (elements.hasNext()) &#123; File file=(File) elements.next(); out.println(file.getPath()); &#125; &#125; public static void output(String path,String regexp) &#123; FilesAnalyze fileGroup1 = new FilesAnalyze(path,regexp); fileGroup1.print(System.out); &#125; public static void main (String[] args) &#123; output(\"C://\",\"[A-z|.]*\"); &#125; Java正则的功用还有很多，事实上只要是字符处理，就没有正则做不到的事情存在。（正则解释时较耗时间就是了|||……）","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://feiyang.li/tags/Android/"},{"name":"Pattern","slug":"Pattern","permalink":"http://feiyang.li/tags/Pattern/"}]},{"title":"VelocityTracker滑动屏幕切换Activity","slug":"VelocityTracker_Activity","date":"2016-10-19T09:11:28.000Z","updated":"2016-10-20T07:13:10.520Z","comments":true,"path":"2016/10/19/VelocityTracker_Activity/index.html","link":"","permalink":"http://feiyang.li/2016/10/19/VelocityTracker_Activity/index.html","excerpt":"我现在非常恨自己手贱选了安卓这门课，作业多的令人发指。不过自己选的课，哭着也要上完。本文主要讲解如何实现 滑动屏幕时切换Activity","text":"我现在非常恨自己手贱选了安卓这门课，作业多的令人发指。不过自己选的课，哭着也要上完。本文主要讲解如何实现 滑动屏幕时切换Activity VelocityTracker简介 android.view.VelocityTracker主要用跟踪触摸屏事件（flinging事件和其他gestures手势事件）的速率。 用addMovement(MotionEvent)函数将Motion event加入到VelocityTracker类实例中。 使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。 使用recycleVelocityTracker()释放空间，循环使用。 当你需要跟踪触摸屏事件的速度的时候 使用obtain() 方法来获得 VelocityTracker 类的一个实例对象在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象使用computeCurrentVelocity (int units)函数来计算当前的速度，使用 getXVelocity ()、 getYVelocity ()函数来获得当前的速度。 使用VelocityTracker123456789101112131415161718192021222324252627private void initView()&#123; entryLayout = (RelativeLayout)super.findViewById(R.id.entry); entryLayout.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; createVelocityTracker(event); //获取实例对象 switch(event.getAction())&#123; case MotionEvent.ACTION_DOWN: // xDown=event.getX(); break; case MotionEvent.ACTION_MOVE: int xSpeed = getScrollVelocity(); xMove = event.getRawX(); int distanceX1 = (int) (xMove - xDown); int distanceX2 = (int) (xDown-xMove); if ((distanceX1 &gt; XDISTANCE_MIN||distanceX2&gt;XDISTANCE_MIN )&amp;&amp;(xSpeed&gt;XSPEED_MIN)) &#123; openNew(); &#125; break; case MotionEvent.ACTION_UP: recycleVelocityTracker(); &#125; return true; &#125; &#125;); &#125; 对于 MotionEventACTION_DOWN: 表示用户开始触摸. ACTION_MOVE: 表示用户在移动(手指或者其他) ACTION_UP:表示用户抬起了手指 ACTION_CANCEL:表示手势被取消了 ACTION_OUTSIDE: 表示用户触碰超出了正常的UI边界. ACTION_POINTER_DOWN:有一个非主要的手指按下了. ACTION_POINTER_UP:一个非主要的手指抬起来了 其余部分代码12345678910111213141516171819202122232425private int getScrollVelocity() &#123;//计算移动距离 mVelocityTracker.computeCurrentVelocity(1000); int velocity = (int) mVelocityTracker.getXVelocity(); return Math.abs(velocity); &#125; private void createVelocityTracker(MotionEvent event)&#123; if(mVelocityTracker == null)&#123; mVelocityTracker = VelocityTracker.obtain(); //获得VelocityTracker类实例 &#125; mVelocityTracker.addMovement(event);//将事件加入到VelocityTracker类实例中 &#125; private void recycleVelocityTracker()&#123; mVelocityTracker.recycle(); mVelocityTracker = null; &#125; private void openNew()&#123; Intent intent = new Intent(SCOSEntry.this,MainScreen.class); Bundle bundle = new Bundle(); bundle.putString(\"message\",\"FromEntry\"); intent.putExtras(bundle); startActivity(intent); &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://feiyang.li/tags/Android/"},{"name":"VelocityTracker","slug":"VelocityTracker","permalink":"http://feiyang.li/tags/VelocityTracker/"}]},{"title":"搭建个人SSR帐号及私人分享","slug":"SSR","date":"2016-10-19T06:13:18.000Z","updated":"2017-05-20T01:22:21.517Z","comments":true,"path":"2016/10/19/SSR/index.html","link":"","permalink":"http://feiyang.li/2016/10/19/SSR/index.html","excerpt":"本文转自1024社区，讲了一下SSR的搭建流程，并分享自己的SSR服务器。","text":"本文转自1024社区，讲了一下SSR的搭建流程，并分享自己的SSR服务器。 服务器配置安装SSR1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/shadowsocks_install/master/shadowsocksR.sh &amp;&amp; bash shadowsocksR.sh 锐速一键包1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh finalspeed 一键包1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/finalspeed/master/install_fs.sh &amp;&amp; bash install_fs.sh finalspeed客户端配置假设服务器 IP 为 10.10.10.10,finalspeed 端口为默认 150,ss 端口为 8989. 加速前提 ss 服务端运行正常, ss 客户端也能正常登录,运行FinalSpeed客户端,填写服务器地址 10.10.10.10 . 搭建个人SSR帐号及私人 点击添加,增加加速端口,加速端口为ss端口8989,如果为其他端口,请相应修改,本地端口任意,这里是2000 打开ss客户端,添加服务器,服务器IP为127.0.0.1,服务器端口为加速端口对应的本地端口,这里是2000,然后设置你的ss密码,加密方式 确定保存,选择使用刚添加的服务器,并设置浏览器代理,成功连接后,FinalSpeed状态栏会出现”连接服务器成功”提示.SSR 客户端、Xshell5和finalspeed客户端自己百度下载吧，我就不分享主要是不知用什么网盘分享，度盘不安全，免得被请去喝茶。 安卓版SSR下载地址下载地址：http://cdn.mmmxcc.cn/ssr_3.0.2.2.apk 因为本网站已经备案，所以。。。有什么问题可以留言或发送邮件~","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://feiyang.li/categories/shadowsocks/"}],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"},{"name":"SSR","slug":"SSR","permalink":"http://feiyang.li/tags/SSR/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"},{"name":"教程","slug":"教程","permalink":"http://feiyang.li/tags/教程/"}]},{"title":"无公网IP服务器搭建Web站点","slug":"without_IP_build_Website","date":"2016-10-19T05:25:29.000Z","updated":"2017-02-11T13:28:24.691Z","comments":true,"path":"2016/10/19/without_IP_build_Website/index.html","link":"","permalink":"http://feiyang.li/2016/10/19/without_IP_build_Website/index.html","excerpt":"前言很多时候我们都会碰到 无公网IP ，比如家用电脑，或者在阿里云上贪便宜买的服务器等。对于科大学生，就更容易出现这种情况了，科大学生可以从http://cloud.ustc.edu.cn/ 申请校内云主机，配置高，网速快，免流量，简直就是学生狗的福音啊。唯一的问题就是，提供的地址是校内IP，使用起来很不方便，搭建Web站点的时候就会遇到很多问题。","text":"前言很多时候我们都会碰到 无公网IP ，比如家用电脑，或者在阿里云上贪便宜买的服务器等。对于科大学生，就更容易出现这种情况了，科大学生可以从http://cloud.ustc.edu.cn/ 申请校内云主机，配置高，网速快，免流量，简直就是学生狗的福音啊。唯一的问题就是，提供的地址是校内IP，使用起来很不方便，搭建Web站点的时候就会遇到很多问题。 本文介绍一种免费内网穿透方案，ngrok 。 该方案与花生壳差不多，只不过花生壳变坏了，现在开始要钱，每个月还限制流量1g。对于网站来说，1个g能干什么，卖萌么。 在vps中下载对应版本的客户端 选择对应的客户端 本文以中国科大云的ubuntu系统为例，首先输入命令1sudo -s 本命令的作用是提升权限，否则之后会不停的要求输入密码的，然后下载客户端。1wget http://hls.ctopus.com/sunny/linux_amd64.zip 下载完毕之后，就要安装ngrok了。 注册端口获得隧道ID在安装之后，需要进入网站注册，注册的目的就是告诉服务器，你希望将服务器的哪个端口和自己的系统的哪个端口相映射，比如这个样子。 选择映射端口 本地端口注意，需要填写本机在局域网内的IP地址和服务端口，我这里写的tcp：22，为了SSH连接使用的，当然也可以像下边这个样子。 SSH连接端口 这里可以使用前缀域名，也可以使用自己的域名，如果使用自己域名的话，需要将域名的CNAME指向到 server.ngrok.cc 。提醒一下，自定义域名会比前缀域名速度慢很多。复制一下，自动生成的隧道ID，一会儿有用哦~ 配置服务器参数服务器端配置完毕之后，回到自己的VPS控制台，输入12cd linux_amd64/nohup ./sunny clientid 9328c9d3f12326e9 后边那一串9328c9d3f12326e9 就是隧道ID，用自己的ID进行替换就好。解释一下nohup的作用，因为SSH连接断掉，或者退出该页面的话，会导致该ngrok关闭，使用nohup可以让本命令在后台运行，直接关毕SSH不会影响ngrok的运行。 切记，这可是一个晚上的深刻教训 啊。。。 这个时候应该就可以看到成功页面了，打开自己的网址就可以看到自己Web服务器里边的东西了~~ 这种内网穿透也就是所谓的TCP转发其实一点也不靠谱，速度巨慢。但是很多人为了调试微信小程序不得不使用这种方法，真心建议各位去闲鱼上，找个学生买个腾讯云服务器，一个月1块钱，而且还有公网IP。用起来不知道比这种方法快到哪里去了。","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"}]},{"title":"回到了苏州","slug":"return_suzhou","date":"2016-10-08T12:28:44.000Z","updated":"2017-04-16T06:53:32.220Z","comments":true,"path":"2016/10/08/return_suzhou/index.html","link":"","permalink":"http://feiyang.li/2016/10/08/return_suzhou/index.html","excerpt":"又回到了苏州 今天我回到了苏州，想想昨天还在北京，和臭臭在一起吃KFC，就觉得好梦幻。","text":"又回到了苏州 今天我回到了苏州，想想昨天还在北京，和臭臭在一起吃KFC，就觉得好梦幻。 臭臭，你是我见到过最棒最好的女孩子了。我特别怕我让你失望，我一定会好好努力的。 以前我给你写的那些纸，都跟流水账一样的。因为我的确不会写日记，以前写日记就是早上干了什么晚上干了什么的，一通记录了事。我以后会好好写的，我做了好多事情，都对不起你。 我会努力的 我真觉得自己配不上你，但是我会努力的。我想和你一起留在北京，我想让你离妈妈爸爸近一些，我想看着孩子长大。 臭臭，谢谢你。 我和臭臭","categories":[],"tags":[{"name":"love","slug":"love","permalink":"http://feiyang.li/tags/love/"}]},{"title":"今天我要去北京见臭臭啦","slug":"travel_to_peking","date":"2016-09-29T12:28:44.000Z","updated":"2017-02-11T13:28:20.163Z","comments":true,"path":"2016/09/29/travel_to_peking/index.html","link":"","permalink":"http://feiyang.li/2016/09/29/travel_to_peking/index.html","excerpt":"","text":"又可以见面了 现在是中午12点，我还在收拾东西，下午就要“坐”火车去北京了。 我真的很想臭臭。 chou)","categories":[],"tags":[{"name":"love","slug":"love","permalink":"http://feiyang.li/tags/love/"}]},{"title":"关于","slug":"resume","date":"2016-01-18T12:02:28.000Z","updated":"2017-05-02T03:30:33.790Z","comments":true,"path":"2016/01/18/resume/index.html","link":"","permalink":"http://feiyang.li/2016/01/18/resume/index.html","excerpt":"个人信息 李飞阳/男/1994 本科/华中科技大学 硕士/中国科学技术大学","text":"个人信息 李飞阳/男/1994 本科/华中科技大学 硕士/中国科学技术大学 Github：http://github.com/mmmwhy 工作经历360 产品经理 2016.03-2016.08360好药 需求设计 使用 Mockplus 完成 APP 1.6、1.7、1.8 产品需求分析和原型设计； 推进疾病症状搜索功能上线，提高用户搜索体验； 360电商云 前端原型设计 与运营人员沟通确认需求范围，整理需求优先级并提交技术排期开发； 360全球药 （国内最大赴印丙肝服务机构）前端后端需求 使用Axure设计360全球药前端页面原型； 设计全球药后台系统，完成多次活动策划方案的原型与后台设计； OPPO 产品经理 2014.07-2014.08产品服务质量提升 项目背景：微信客服好评率一直非常高，但在调研中发现该产品口碑却偏低。 项目目标：解释弹窗评价与调研反馈的差异，找出产品改进的方向，扭转差口碑的局面。 OPPO官方论坛改版 项目目标：由满足功能性为主转化为满足娱乐性需求，提高论坛的可玩性； 推广策划：使用 SWOT 和 3W 分析市场状况，根据 OPPO 服务理念设计朋友圈/微博营销方案，进行实施和效果评估。 致谢 hexo-theme-indigo 主题颜色搭配很出色，真的好棒。 360 进入互联网公司 OPPO 跳进产品狗的大坑 HUST 本科母校，一切都那么习惯 USTC 谢谢收留","categories":[],"tags":[{"name":"resume","slug":"resume","permalink":"http://feiyang.li/tags/resume/"}]}]}