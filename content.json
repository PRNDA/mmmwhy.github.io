{"meta":{"title":"李飞阳","subtitle":"PM、Coder、Data mining","description":"Python ,Code,Data mining","author":"Wing Lee","url":"http://feiyang.li"},"pages":[{"title":"诶哟喂，你好像进错地方了","date":"2017-03-23T11:32:53.747Z","updated":"2017-03-23T11:32:53.747Z","comments":true,"path":"404.html","permalink":"http://feiyang.li/404.html","excerpt":"","text":"我也想给你听这首歌，告诉你，你是最完美的女孩。 我对你的爱，从山的这头，到海的那头。 就像风走了八百里，不问归期。 你可能看不到，但我一直都在你身边。 有一美人兮， 见之不忘。 一日不见兮， 思之如狂。 凤飞翱翔兮， 四海求凰。 无奈佳人兮， 不在东墙。 将琴代语兮， 聊写衷肠。 何日见许兮， 慰我彷徨。 愿言配德兮， 携手相将。 不得於飞兮， 使我沦亡。"},{"title":"膜拜大佬","date":"2017-03-23T11:32:29.766Z","updated":"2017-03-13T08:55:05.648Z","comments":true,"path":"link.html","permalink":"http://feiyang.li/link.html","excerpt":"","text":"排名不分先后 &nbsp;&nbsp;Anotherhome https://www.anotherhome.net &nbsp;&nbsp;ilanyu's Blog http://blog.lanyus.com/ &nbsp;&nbsp;科研软件小站 http://www.sciencesoft.cn/ &nbsp;&nbsp;&nbsp;&nbsp;请多指教"},{"title":"标签","date":"2017-03-27T11:28:04.000Z","updated":"2017-03-27T11:47:02.502Z","comments":false,"path":"tags/index.html","permalink":"http://feiyang.li/tags/index.html","excerpt":"","text":""},{"title":"整理","date":"2017-03-27T11:15:33.000Z","updated":"2017-03-27T11:48:25.701Z","comments":false,"path":"categories/index.html","permalink":"http://feiyang.li/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2017-04-15T05:18:52.000Z","updated":"2017-04-15T05:48:01.929Z","comments":true,"path":"2017/04/15/test/index.html","link":"","permalink":"http://feiyang.li/2017/04/15/test/index.html","excerpt":"","text":"165165156","categories":[],"tags":[]},{"title":"Coursera ML(5)-Logistic Regression and Regularization with Python","slug":"Coursera-ML-5-Programming-Exercise-2","date":"2017-03-30T04:46:11.000Z","updated":"2017-04-14T10:48:11.363Z","comments":true,"path":"2017/03/30/Coursera-ML-5-Programming-Exercise-2/index.html","link":"","permalink":"http://feiyang.li/2017/03/30/Coursera-ML-5-Programming-Exercise-2/index.html","excerpt":"线性回归算法，可用于房屋价格的估计及股票市场分析。 Logistic Regression （逻辑回归）是当前业界比较常用的机器学习方法，用于估计某种事物的可能性。比如某用户购买某商品的可能性，某病人患有某种疾病的可能性，以及某广告被用户点击的可能性等。相关公式推导在这里","text":"线性回归算法，可用于房屋价格的估计及股票市场分析。 Logistic Regression （逻辑回归）是当前业界比较常用的机器学习方法，用于估计某种事物的可能性。比如某用户购买某商品的可能性，某病人患有某种疾病的可能性，以及某广告被用户点击的可能性等。相关公式推导在这里 Stanford coursera Andrew Ng 机器学习课程编程作业（Exercise 2），作业下载链接貌似被墙了，下载链接放这。http://home.ustc.edu.cn/~mmmwhy/machine-learning-ex2.zip 预备知识这里应该分为 正常、过拟合和欠拟合，三种情况。 Cost Function $$J(\\theta) = - \\frac{1}{m} \\sum_{i=1}^m \\large[ y^{(i)}\\ \\log (h_\\theta (x^{(i)})) + (1 - y^{(i)})\\ \\log (1 - h_\\theta(x^{(i)}))\\large] + \\frac{\\lambda}{2m}\\sum_{j=1}^n \\theta_j^2$$ Gradient Descent $$\\begin{align*} & \\text{Repeat}\\ \\lbrace \\newline & \\ \\ \\ \\ \\theta_0 := \\theta_0 - \\alpha\\ \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\newline & \\ \\ \\ \\ \\theta_j := \\theta_j - \\alpha\\ \\left[ \\left( \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \\right) + \\frac{\\lambda}{m}\\theta_j \\right] &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j \\in \\lbrace 1,2...n\\rbrace\\newline & \\rbrace \\end{align*}$$ Grad $$Grad = \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)}+ \\frac{\\lambda}{m}\\theta_j$$ 后边有一个$\\frac{\\lambda}{2m}\\sum_{j=1}^n \\theta_j^2$和$\\frac{\\lambda}{m}\\theta_j$小尾巴，作用就是进行 Regularization，防止拟合过度。 Logistic Regression题目介绍 you will build a logistic regression model to predict whether a student gets admitted into a university.（根据各科目分数预测该学生是否能录取） For each training example, you have the applicant’s scores on two exams and the admissions decision. Your task is to build a classi cation model that estimates an applicant’s probability of admission based the scores from those two exams. python code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from numpy import *import matplotlib.pyplot as pltfrom scipy import optimizedef init(path): X,y = load_dataset(path) # 调用底下那个东西 m, n = shape(X) initial_theta = zeros(n + 1) return X,y,m,n,initial_theta def load_dataset(path): data = loadtxt(path, delimiter=',') X = data[:,:2] y = data[:, 2] return X,ydef plotData(X,y): plt.plot(X[y==1][:,0],X[y==1][:,1],'k+',linewidth=2,) plt.plot(X[y==0][:,0],X[y==0][:,1],'ko',color='y',linewidth=2) plt.xlabel('科目一成绩', fontproperties='SimHei') plt.ylabel('科目二成绩', fontproperties='SimHei') plt.title('分数与录取的关系', fontproperties='SimHei') def sigmoid(X, theta): return 1 / (1 + exp(-dot(X, theta)))def get_cost(theta, X, y): J = sum((-y*log(sigmoid(X,theta)) - (1-y)*log(1-sigmoid(X,theta))))/len(X) return Jdef get_grad(theta, X, y): return (sigmoid(X,theta) - mat(y))*X*(1/m)def plotDecisionBoundary(theta, X, y): plotData(X[:, 1:3], y) if X.shape[1] &lt;= 3: plot_x = r_[X[:,2].min()-2, X[:,2].max()+2] plot_y = - (theta[1]*plot_x + theta[0])/theta[2] plt.plot(plot_x, plot_y) plt.axis([30,100,30,100]) plt.legend(['Accepted', 'Not Accepted', 'Decision Boundary']) plt.show() else: pass def predict(theta, X): prob = sigmoid([1,45,85] , result[0]) return prob if __name__==\"__main__\": path = 'C:\\\\Users\\\\wing\\\\Desktop\\\\machine-learning-ex2\\\\ex2\\\\ex2data1.txt' X,y,m,n,initial_theta = init(path) X = column_stack((ones(m), X)) cost = get_cost(initial_theta, X, y) grad = get_grad(initial_theta, X, y) # obtain the optimal theta result = optimize.fmin_tnc(func=get_cost, x0=initial_theta, fprime=get_grad, args=(X, y)) get_cost(result[0], X, y) # result = (array([-25.16131863, 0.20623159, 0.20147149]), 36, 0) # get_cost(result[0], X, y) = 0.20349770158947464 plotDecisionBoundary(result[0], X, y) print('For a student with scores 45 and 85, we predict an admission ' \\ 'probability of %f\\n'%predict(result[0], X))# For a student with scores 45 and 85, we predict an admission probability of 0.776291 运行结果最后进行了一个测试，如果一个学生两门考试成绩，一门45分，另外一门85分，那么他被录取的概率为77%。幸亏是在外国，在中国这分数，连大专都考不上。 Logistic Regression and Regularization题目 Suppose you are the product manager of the factory and you have the test results for some microchips on two di erent tests. 对于一批产品，有两个检测环节，通过检测结果判断产品是否合格。比如，宜家会有三十年床垫保证，那么如果确保床垫合格（用30年），我们只能通过一些检测，来推测产品是否合格。 python code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from numpy import *import matplotlib.pyplot as pltfrom scipy import optimizedef init(path): X,y = load_dataset(path) dataplot(X,y) X = map_feature(X[:,0], X[:,1]) initial_theta = zeros(size(X[1])) lam = 1 return X,y,initial_theta,lamdef load_dataset(path): data = loadtxt(path, delimiter=',') X = data[:,:2] y = data[:, 2] return X,y def dataplot(X,y): plt.plot(X[y==1][:,0],X[y==1][:,1],'k+',linewidth=2) plt.plot(X[y==0][:,0],X[y==0][:,1],'ko',color='y',linewidth=2) plt.legend([ 'y = 1','y = 0'])def sigmoid(X, theta): return 1 / (1 + exp(-dot(X, theta)))def map_feature(x1, x2): #X1, X2, X1 ** 2, X2 ** 2, X1*X2, X1*X2 ** 2, etc... x1.shape = (x1.size, 1) x2.shape = (x2.size, 1) degree = 6 out = ones(shape=(x1[:, 0].size, 1)) m, n = out.shape for i in range(1, degree + 1): for j in range(i + 1): r = (x1 ** (i - j)) * (x2 ** j) out = append(out, r, axis=1) return outdef get_cost(theta, X, y,lam): hx = sigmoid(X,theta) thetaR = theta[1:] J = sum((-y*log(hx) - (1-y)*log(1-hx)))/len(X) \\ + (lam / (2.0 * len(X))) * (thetaR.T.dot(thetaR)) return Jdef get_grad(theta, X, y,lam): reg = (lam/len(y))*theta reg[0] = 0 grad = X.T.dot(sigmoid(X,theta)-y)/len(y)+reg return graddef plotDecisionBoundary(theta,lam): u = linspace(-1, 1.5, 50) v = linspace(-1, 1.5, 50) z = zeros(shape=(len(u), len(v))) for i in range(len(u)): for j in range(len(v)): z[i, j] = (map_feature(array(u[i]), array(v[j])).dot(array(theta))) z = z.T plt.contour(u, v, z) plt.title('lambda = %f' % lam) plt.xlabel('Microchip Test 1') plt.ylabel('Microchip Test 2') plt.axis([-0.85,1.1,-0.85,1.1]) plt.legend(['y = 1', 'y = 0', 'Decision boundary']) plt.show() if __name__==\"__main__\": path = 'C:\\\\Users\\\\wing\\\\Desktop\\\\machine-learning-ex2\\\\ex2\\\\ex2data2.txt' X,y,initial_theta,lam = init(path) result = optimize.fmin_tnc(func=get_cost, x0=initial_theta, fprime=get_grad, args=(X, y,lam)) plotDecisionBoundary(result[0],lam) 运算结果 过拟合lambda=0。不考虑 $\\frac{\\lambda}{2m}\\sum_{j=1}^n \\theta_j^2$和$\\frac{\\lambda}{m}\\theta_j$ ，我们可以看到图像已经被拟合过度。这样的答案没有通用性 欠拟合lambda=10，欠拟合会导致数据的很多细节被抛弃。 拟合较好lambda=1，准确性到91%左右，这个准确率算低的了吧，还有很大上升空间。 Summary熊辉上课的时候，说机器学习需要调参数，参数很不好调，需要使用者对数据有极高的敏感度。 参数lambda就是这种感觉，感觉真的是乱调一通，然后就发现，诶哟，好像还不错。 参考链接：scipy.optimize.minimizeLogistic regressionMachine Learning Exercises In Python, Part 3machine-learning-with-python-logistic 以上","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Coursera ML(4)-Logistic Regression","slug":"Coursera-ML-4-Logistic-Regression","date":"2017-03-27T11:13:38.000Z","updated":"2017-03-28T07:49:36.625Z","comments":true,"path":"2017/03/27/Coursera-ML-4-Logistic-Regression/index.html","link":"","permalink":"http://feiyang.li/2017/03/27/Coursera-ML-4-Logistic-Regression/index.html","excerpt":"本节笔记对应第三周Coursera课程 binary classification problem","text":"本节笔记对应第三周Coursera课程 binary classification problem Classification is not actually a linear function. Classification and RepresentationHypothesis Representation Sigmoid Function(or we called Logistic Function) $$\\begin{align*}& h_\\theta (x) = g ( \\theta^T x ) \\newline \\newline& z = \\theta^T x \\newline& g(z) = \\dfrac{1}{1 + e^{-z}}\\end{align*}$$ Sigmoid Function 可以使输出值范围在$(0,1)$之间。$g(z)$对应的图为： $h_\\theta(x)$ will give us the probability that our output is 1. Some basic knowledge of discrete $$\\begin{align*}& h_\\theta(x) = P(y=1 | x ; \\theta) = 1 - P(y=0 | x ; \\theta) \\newline& P(y = 0 | x;\\theta) + P(y = 1 | x ; \\theta) = 1\\end{align*}$$ Decision Boundary translate the output of the hypothesis function as follows: $$\\begin{align*}& h_\\theta(x) \\geq 0.5 \\rightarrow y = 1 \\newline& h_\\theta(x) < 0.5 \\rightarrow y = 0 \\newline\\end{align*}$$ From these statements we can now say: $$\\begin{align*}& \\theta^T x \\geq 0 \\Rightarrow y = 1 \\newline& \\theta^T x < 0 \\Rightarrow y = 0 \\newline\\end{align*}$$ Logistic Regression ModelCost function for one variable hypothesis To let the cost function be convex for gradient descent, it should be like this: $$J(\\theta) = \\dfrac{1}{m} \\sum_{i=1}^m \\mathrm{Cost}(h_\\theta(x^{(i)}),y^{(i)})$$ $$Cost(h_\\theta (x), y) =\\begin{cases}-log(h_\\theta (x)), (y = 1) \\\\-log(1 - h_\\theta (x)), (y = 0) \\\\\\end{cases}$$ example $$\\begin{align*}& \\mathrm{Cost}(h_\\theta(x),y) = 0 \\text{ if } h_\\theta(x) = y \\newline & \\mathrm{Cost}(h_\\theta(x),y) \\rightarrow \\infty \\text{ if } y = 0 \\; \\mathrm{and} \\; h_\\theta(x) \\rightarrow 1 \\newline & \\mathrm{Cost}(h_\\theta(x),y) \\rightarrow \\infty \\text{ if } y = 1 \\; \\mathrm{and} \\; h_\\theta(x) \\rightarrow 0 \\newline \\end{align*}$$ Simplified Cost Function and Gradient Descent compress our cost function’s two conditional cases into one case: $$\\mathrm{Cost}(h_\\theta(x),y) = - y \\; \\log(h_\\theta(x)) - (1 - y) \\log(1 - h_\\theta(x))$$ entire cost function $$J(\\theta) = - \\frac{1}{m} \\displaystyle \\sum_{i=1}^m [y^{(i)}\\log (h_\\theta (x^{(i)})) + (1 - y^{(i)})\\log (1 - h_\\theta(x^{(i)}))]$$ Gradient Descent the general form of gradient descent ，求偏导的得到$J(\\theta)$的极值 $$\\begin{align*}& Repeat \\; \\lbrace \\newline & \\; \\theta_j := \\theta_j - \\alpha \\dfrac{\\partial}{\\partial \\theta_j}J(\\theta) \\newline & \\rbrace\\end{align*}$$ using calculus $$\\frac{\\partial}{\\partial \\theta_j} J(\\theta) = \\frac{1}{m}\\sum\\limits_{i=1}^{m}[(h_\\theta (x^{(i)}) - y^{(i)})x_j^{(i)}]$$ get $$\\begin{align*} & Repeat \\; \\lbrace \\newline & \\; \\theta_j := \\theta_j - \\frac{\\alpha}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} \\newline & \\rbrace \\end{align*}$$ Multiclass Classification: One-vs-all For more than 2 features of y, do logisitc regression for each feature separately Train a logistic regression classifier $h_\\theta(x)$ for each class￼ to predict the probability that ￼ ￼y = i￼ ￼. To make a prediction on a new x, pick the class ￼that maximizes $ h_\\theta (x) $ Solving the Problem of OverfittingThe Problem of Overfitting address the issue of overfitting Reduce the number of features: Manually select which features to keep. Use a model selection algorithm (studied later in the course). Regularization: Keep all the features, but reduce the magnitude of parameters $θ_j$. Regularization works well when we have a lot of slightly useful features. Cost Function in a single summation $$min_\\theta\\ \\dfrac{1}{2m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})^2 + \\lambda\\ \\sum_{j=1}^n \\theta_j^2$$ The λ, or lambda, is the regularization parameter. It determines how much the costs of our theta parameters are inflated. Regularized Linear Regression Gradient Descent $$\\begin{align*} & \\text{Repeat}\\ \\lbrace \\newline & \\ \\ \\ \\ \\theta_0 := \\theta_0 - \\alpha\\ \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\newline & \\ \\ \\ \\ \\theta_j := \\theta_j - \\alpha\\ \\left[ \\left( \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \\right) + \\frac{\\lambda}{m}\\theta_j \\right] &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j \\in \\lbrace 1,2...n\\rbrace\\newline & \\rbrace \\end{align*}$$ Normal Equation $$\\begin{align*}& \\theta = \\left( X^TX + \\lambda \\cdot L \\right)^{-1} X^Ty \\newline& \\text{where}\\ \\ L = \\begin{bmatrix} 0 & & & & \\newline & 1 & & & \\newline & & 1 & & \\newline & & & \\ddots & \\newline & & & & 1 \\newline\\end{bmatrix}\\end{align*}$$ L is a matrix with 0 at the top left and 1’s down the diagonal, with 0’s everywhere else. It should have dimension (n+1)×(n+1) Recall that if m ≤ n, then $X^TX$ is non-invertible. However, when we add the term λ⋅L, then $X^TX + λ⋅L $becomes invertible. Summary我在这里整理一下上述两个方法，补全课程上的相关推导。 Logistic Regression Model$h_\\theta(x)$是假设函数 $$h_\\theta (x) = g ( \\theta^T x ) = \\dfrac{1}{1 + e^{- \\theta^T x}} $$ 注意假设函数和真实数据之间的区别 Cost Function $$J(\\theta) = - \\frac{1}{m} \\sum_{i=1}^m \\large[ y^{(i)}\\ \\log (h_\\theta (x^{(i)})) + (1 - y^{(i)})\\ \\log (1 - h_\\theta(x^{(i)}))\\large]$$ 回头看看上边的那个$h_\\theta (x)$ ，cost function定义了训练集给出的结果 和 当前计算结果之间的差距。当然，该差距越小越好，那么需要求导一下。 Gradient Descent 原始公式 $$\\theta_j := \\theta_j - \\alpha \\dfrac{\\partial}{\\partial \\theta_j}J(\\theta)$$ 求导计算 $$\\frac{\\partial}{\\partial \\theta_j} J(\\theta) = \\frac{1}{m}\\sum\\limits_{i=1}^{m}[(h_\\theta (x^{(i)}) - y^{(i)})x_j^{(i)}]$$ 计算结果 $$\\theta_j := \\theta_j - \\frac{\\alpha}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} $$ 这里推导一下$\\frac{\\partial}{\\partial \\theta_j} J(\\theta)$： 计算$h_\\theta’(x)$导数 $$\\begin{align*} &h_\\theta'(x) = ( \\frac1{1+e^{- \\theta x}})'\\newline &\\ \\ \\ \\ \\ \\ \\ \\ = \\frac{e^{- \\theta x}x}{1+e^{- \\theta x}}\\newline &\\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1+e^{- \\theta x}-1}{(1+e^{- \\theta x})^2}x\\newline &\\ \\ \\ \\ \\ \\ \\ \\ = \\large[\\frac{1}{1+e^{- \\theta x}}-\\frac{1}{(1+e^{- \\theta x})^2}\\large]x\\newline &\\ \\ \\ \\ \\ \\ \\ \\ = h_\\theta(x)(1-h_\\theta(x))x \\end{align*}$$ 推导$\\frac{\\partial}{\\partial \\theta_j} J(\\theta)$ $$\\begin{align*} &\\frac{\\partial}{\\partial \\theta_j} J(\\theta) = \\frac{\\partial}{\\partial \\theta_j} \\frac{1}{m} \\sum_{i=1}^m \\large[ -y^{(i)}\\ \\log (h_\\theta (x^{(i)})) - (1 - y^{(i)})\\ \\log (1 - h_\\theta(x^{(i)}))\\large] \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1}{m} \\sum_{i=1}^m \\large[ -y^{(i)}\\ \\frac1{h_\\theta(x^{(i)})}h_\\theta'(x^{(i)}) - (1 - y^{(i)}) \\frac{-1}{1-h_\\theta(x^{(i)})}h_\\theta'(x^{(i)})\\large] \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1}{m} \\sum_{i=1}^m \\large[ -y^{(i)}\\ \\frac1{h_\\theta(x^{(i)})}h_\\theta(x^{(i)})(1-h_\\theta(x^{(i)}))x^{(i)} \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ - (1 - y^{(i)}) \\frac{-1}{1-h_\\theta(x^{(i)})}h_\\theta(x^{(i)})(1-h_\\theta(x^{(i)}))x^{(i)}\\large] \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1}{m} \\sum_{i=1}^m \\large[ -y^{(i)}(1-h_\\theta(x^{(i)}) x^{(i)})+(1- y)h_\\theta(x^{(i)}) x^{(i)})\\large] \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1}{m} \\sum_{i=1}^m \\large[ -x^{(i)}y^{(i)}+x^{(i)}y^{(i)}h_\\theta(x^{(i)}) \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ +x^{(i)}h_\\theta(x^{(i)}) - x^{(i)}y^{(i)}h_\\theta(x^{(i)}) \\large] \\newline &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ = \\frac{1}{m}\\sum\\limits_{i=1}^{m}[(h_\\theta (x^{(i)}) - y^{(i)})x_j^{(i)}] \\end{align*}$$ 即： $$\\begin{align*} &\\frac{\\partial}{\\partial \\theta_j} J(\\theta) = \\frac{1}{m}\\sum\\limits_{i=1}^{m}[(h_\\theta (x^{(i)}) - y^{(i)})x_j^{(i)}] \\end{align*}$$ Solving the Problem of Overfitting其他地方都一样，稍作修改 Cost Function $$J(\\theta) = - \\frac{1}{m} \\sum_{i=1}^m \\large[ y^{(i)}\\ \\log (h_\\theta (x^{(i)})) + (1 - y^{(i)})\\ \\log (1 - h_\\theta(x^{(i)}))\\large] + \\frac{\\lambda}{2m}\\sum_{j=1}^n \\theta_j^2$$ Gradient Descent $$\\begin{align*} & \\text{Repeat}\\ \\lbrace \\newline & \\ \\ \\ \\ \\theta_0 := \\theta_0 - \\alpha\\ \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\newline & \\ \\ \\ \\ \\theta_j := \\theta_j - \\alpha\\ \\left[ \\left( \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \\right) + \\frac{\\lambda}{m}\\theta_j \\right] &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j \\in \\lbrace 1,2...n\\rbrace\\newline & \\rbrace \\end{align*}$$ 以上","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Coursera ML(3)-Multivariate Linear Regression python实现","slug":"Coursera-ML-3-Multivariate-Linear-Regression-python","date":"2017-03-26T11:00:29.000Z","updated":"2017-03-27T11:32:14.121Z","comments":true,"path":"2017/03/26/Coursera-ML-3-Multivariate-Linear-Regression-python/index.html","link":"","permalink":"http://feiyang.li/2017/03/26/Coursera-ML-3-Multivariate-Linear-Regression-python/index.html","excerpt":"Multivariate Linear Regression and Programming Exercise 1","text":"Multivariate Linear Regression and Programming Exercise 1 Gradient Descent for Multiple Variables Suppose we have n variables, set hypothesis to be: Cost Function Gradient Descent AlgorithmGet every feature into approximately [-1, 1]. Just normalize all the parameters :) Learning Rate:Not too big(fail to converge), not too small(too slow) Polynormal Regression:Use feature scalling. (Somewhat like normalizing dimension) Programming Exercise 1下载程序及相关数据Stanford coursera Andrew Ng 机器学习课程编程作业（Exercise 1），作业下载链接貌似被墙了，下载链接放这。http://home.ustc.edu.cn/~mmmwhy/machine-learning-ex1.zip 重新推导一下：其实这里一共就两个式子： computeCost $$h_\\theta (x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \\theta_3 x_3 + \\cdots + \\theta_n x_n$$ $$J(\\theta_0,\\theta_1 )=\\frac1{wm} \\sum_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})^w$$ gradientDescent $$\\begin{align*} \\text{repeat until convergence: } \\lbrace & \\newline \\theta_0 := & \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}(h_\\theta(x_{i}) - y_{i}) \\newline \\theta_1 := & \\theta_1 - \\alpha \\frac1m \\sum\\limits_{i=1}^m\\left((h_\\theta(x_i) - y_i) x_i\\right) \\newline \\rbrace& \\end{align*}$$ python拟合实现代码原本用的是matlab代码，我用python实现了一下，结果是一样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import numpy as npimport pandas as pdimport matplotlib.pyplot as pltdef readfile(path): X=[] y=[] with open(path,'r') as f: for line in f: X.append([1,float(line.split(',')[0])]) y.append(float(line.split(',')[1])) return X,ydef dataplot(x,theta,y): plt.plot(x, y, 'rx', markersize=10) plt.ylabel('Profit in $10,000s') plt.xlabel('Population of City in 10,000s') plt.plot(X[:,1],X*theta,'-') plt.show()def computeCost(X,y,theta): m = len(y) J = 0 for i in range(m): J = J + float((X[i]*theta-y[i])**2) return J/(2*m)def gradientDescent(X, y, theta, alpha, num_iters): m = len(y) num_iters = 1500 J_history = np.zeros(num_iters) for i in range(num_iters): S =X.T * (X * theta - np.mat(y).T) / m theta = theta - alpha * S; J_history[i] = computeCost(X,y,theta) return thetaif __name__==\"__main__\": theta = np.mat([[0],[0]]) iterations = 1500 alpha = 0.01 iterations = 1500 path = \"C:\\Users\\wing\\Documents\\MATLAB\\ex1\\ex1data1.txt\" x,y = readfile(path)# 小写的X不是矩阵，是list，大写的X是矩阵。 X = np.mat(x) J = computeCost(X, y, theta) theta = gradientDescent(X, y, theta, alpha, iterations) dataplot(X[:,1],theta,y) 输出的图有点小，就这样吧。","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Coursera ML(2)-Model and Cost Function","slug":"Coursera-ML-2-Model-and-Cost-Function","date":"2017-03-25T10:49:36.000Z","updated":"2017-03-27T11:35:22.375Z","comments":true,"path":"2017/03/25/Coursera-ML-2-Model-and-Cost-Function/index.html","link":"","permalink":"http://feiyang.li/2017/03/25/Coursera-ML-2-Model-and-Cost-Function/index.html","excerpt":"Model and Cost Function / Parameter Learning / Gradient Descent For Linear Regression","text":"Model and Cost Function / Parameter Learning / Gradient Descent For Linear Regression Model and Cost Function Tables Are Hypothesis $$h_{\\theta}={\\theta}_0+{\\theta}_1x$$ Parameter ${\\theta}_0$，${\\theta}_1$ Cost Function $J(\\theta_0,\\theta_1)= \\frac1{2m}\\sum_{i=1}^m(h_{\\theta}(x^i)-y^i)^w$ Goal $minimiseJ(\\theta_0,\\theta_1)$ Model Representation Hypothesis:$$h_{\\theta}={\\theta}_0+{\\theta}_1x$$${\\theta}_0$和${\\theta}_1$称为模型参数 Cost FunctionWe can measure the accuracy of our hypothesis function by using a cost function. his takes an average difference (actually a fancier version of an average) of all the results of the hypothesis with inputs from x’s and the actual output y’s. 如何尽可能的将直线与我们的数据相拟合 Parameter LearningGradient descent idea Turns out, that if you’re standing at that point on the hill, you look all around and you find that the best direction is to take a little step downhill is roughly that direction. Okay, and now you’re at this new point on your hill. You’re gonna, again, look all around and say what direction should I step in order to take a little baby step downhill? And if you do that and take another step, you take a step in that direction. Gradient descent algorithmrepeat until convergence:{ $\\theta_j:=\\theta_j-\\alpha\\frac\\partial{\\partial\\theta_j}J(\\theta_0,\\theta_1)$} use := to denote assignment, so it’s the assignment operator. $\\alpha$ called:learning rate.controls how big a step we take downhill with creating descent. $\\theta_0,\\theta_1 $should be updated simultaneously(using multiple temp var should work!) Gradient Descent For Linear Regression $$\\begin{align*} \\text{repeat until convergence: } \\lbrace & \\newline \\theta_0 := & \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}(h_\\theta(x_{i}) - y_{i}) \\newline \\theta_1 := & \\theta_1 - \\alpha \\frac1m \\sum\\limits_{i=1}^m\\left((h_\\theta(x_i) - y_i) x_i\\right) \\newline \\rbrace& \\end{align*}$$ where m is the size of the training set, $\\theta_0$ a constant that will be changing simultaneously with $\\theta_1$ and $x_i y_i$are values of the given training set (data). The $J(θ_0,θ_1)$ is a convex function, which means it has only one global minimun, which means gradient descent will always hit the best fit “Batch” Gradient Descent: “Batch” means the algo is trained from all the samples every time","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"}]},{"title":"算法导论 第15章 动态规划","slug":"dynamic-programming","date":"2017-03-24T09:05:47.000Z","updated":"2017-03-24T09:26:24.294Z","comments":true,"path":"2017/03/24/dynamic-programming/index.html","link":"","permalink":"http://feiyang.li/2017/03/24/dynamic-programming/index.html","excerpt":"《算法导论》这门课的老师是黄刘生和张曙，两位都是老人家了，代课很慢很没有激情，不过这一章非常有意思。","text":"《算法导论》这门课的老师是黄刘生和张曙，两位都是老人家了，代课很慢很没有激情，不过这一章非常有意思。 前言：书中列举四个常见问题，分析如何采用动态规划方法进行解决。 装配线调度问题 矩阵链乘问题： 最长公共子序列问题： 最优二叉查找树问题： 基本概念动态规划通常应用于最优化问题，此类问题可能包含多个可行解。每个解有一个值，而我们期望找到最大或者最小的解。 动态规划算法的设计可以分为以下4个步骤： 描述最优解的结构。 递归定义最优解的值。 按自底向上的方式计算最优解的值。（其实还应该有自顶向下的求解） 由计算出的结果构造一个最优解。 动态规划算法效率会非常高的原因在于，其特殊的实现方法，也就是第三步。 两种等价的实现方法： 带备忘的自顶向下法，此方法按照正常的递归编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中）。当需要一个子问题的解时，程序首先检查是否已经保存过此解。如果是，直接返回；若不是，递归计算这个子问题。这种递归方式是带备忘的。 自底而上法，这种方法需要恰当的定义子问题的规模，因为任何一个子问题的求解的依赖着更小的子问题。因此需要将问题进行排序，从小的问题开始处理。这样可以确保，在处理到大的问题时，其所依赖的更小的子问题已经求解完毕，结果已经保存。 因此，我们会说 动态规划算法属于典型的用空间换取时间。由于没有频繁的递归函数的开销，自底而上方法的时间复杂度会更好一些。 动态规划与分治法之间的区别： 分治法是指将问题分成一些独立的子问题，递归的求解各子问题。 动态规划适用于这些子问题不是独立的情况，也就是各子问题包含公共子问题。 动态规划基础什么时候可以使用动态规范方法解决问题呢？这个问题需要讨论一下，书中给出了采用动态规范方法的最优化问题中的两个要素：最优子结构和重叠子结构。 最优子结构（自下向上）最优子结构是指问题的一个最优解中包含了其子问题的最优解。在动态规划中，每次采用子问题的最优解来构造问题的一个最优解。 寻找最优子结构，遵循的共同的模式： 问题的一个解可以是做一个选择，得到一个或者多个有待解决的子问题。 假设对一个给定的问题，已知的是一个可以导致最优解的选择，不必关心如何确定这个选择。 在已知这个选择后，要确定哪些子问题会随之发生，如何最好地描述所得到的子问题空间。 利用“剪贴”技术，来证明问题的一个最优解中，使用的子问题的解本身也是最优的。 最优子结构在问题域中以两种方式变化： 有多少个子问题被使用在原问题的一个最优解中。 在决定一个最优解中使用哪些子问题时有多少个选择。 动态规划按照自底向上的策略利用最优子结构，即：首先找到子问题的最优解，解决子问题，然后逐步向上找到问题的一个最优解。 为了描述子问题空间，可以遵循这样一条有效的经验规则，就是尽量保持这个空间简单，然后在需要时再扩充它。 注意：在不能应用最优子结构的时候，就一定不能假设它能够应用。 警惕使用动态规划去解决缺乏最优子结构的问题！ 使用动态规划时，子问题之间必须是相互独立的！可以这样理解，N个子问题域互不相干，属于完全不同的空间。 重叠子问题（自上向下）用来解决原问题的递归算法可以反复地解同样的子问题，而不是总是产生新的子问题。 重叠子问题是指当一个递归算法不断地调用同一个问题。 动态规划算法总是充分利用重叠子问题，通过每个子问题只解一次，把解保存在一个需要时就可以查看的表中，每次查表的时间为常数。 由计算出的结果反向构造一个最优解：把动态规划或者是递归过程中作出的每一次选择（记住：保存的是每次作出的选择）都保存下来，在最后就一定可以通过这些保存的选择来反向构造出最优解。 做备忘录的递归方法：这种方法是动态规划的一个变形，它本质上与动态规划是一样的，但是比动态规划更好理解！ （1） 使用普通的递归结构，自上而下的解决问题。 （2） 当在递归算法的执行中每一次遇到一个子问题时，就计算它的解并填入一个表中。以后每次遇到该子问题时，只要查看并返回表中先前填入的值即可。 钢条切割问题题目 给定一个长度为n的钢条，以及一个价格表p，p中列出了每英寸钢条的价格，将长度为n的钢条切割为若干短钢条出售，求一个钢条的切割方案，使得收益最大，切割工序没有成本。比如价格表p如下： 长度为n的钢条，一共有$2^{n-1}$种不同的切割方案，因为可以再距离钢条左边为i（i=1,2,…,n-1）处，我们总是可以选择切割或者不切割。比如下图表示了n=4的切割情况： 理论依据我们称钢条切割问题满足最优子结构性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。 我们可以这样理解钢条问题：将钢条从左边切下一段长度为i的一段，对剩下的n-i的部分继续进行切割（递归求解），而不对左边长度为i的一段在进行切割。 这样问题的解就转化为最优解了。 自顶向下递归实现1234567CUT-ROD(p,n)if n == 0 return 0q = -∞for i = 1 to n q = max(q, p[i]+CUT-ROD(p, n-i))return q CUT-ROD的效率很差，这是因为CUT-ROD反复的求解一些相同的子问题，下图显示了当n==4时的调用情况： 带备忘的自顶向下12345678910111213141516MEMOIZED-CUT-ROD(p,n)let r[0..n] be a new arrayfor i = 0 to n r[i]= -∞return MEMOIZED-CUT-ROD-AUX(p, n, r) MEMOIZED-CUT-ROD-AUX(p,n, r)if r[n] &gt;= 0 return r[n]if n == 0 q = 0else q = -∞ for i = 1 to n q= max(q, p[i]+MEMOIZED-CUT-ROD-AUX(p, n-i,r))r[n] = qreturn q 该方法与之前的普通递归方法类似，只是会在过程中保存子问题的解，当需要一个子问题的解的时候，先查看是否已经保存过了，如果是，则直接使用即可。否则，按常规的递归方式计算子问题。所以称为带备忘的，因为它记住了之前已经计算出的结果。 自底向上的方法123456789BOTTOM-UP-CUT-ROD(p,n)let r[0..n] be a new arrayr[0]= 0for j = 1 to n q= -∞ for i = 1 to j q = max(q, p[i]+r[j-i]) r[j]= qreturn r[n] 方法采用子问题的自然顺序，因此过程中依次求解规模为$j=0,1,2,3,4…,n$的问题。 这两种算法具有相同的时间复杂度，BOTTOM-UP-CUT-ROD主要是双层嵌套循环，所以时间复杂度$Θ(n^2)$。MEMOIZED-CUT-ROD的时间复杂度也是$Θ(n^2)$。可以使用子问题图进行分析。 python实现切割钢条问题1234567891011121314151617181920def cut_rod(): p = [0,1,5,8,9,10,17,17,20,24,30] n = len(p) r = [0 for i in range(n)] s = [0 for i in range(n)] for j in range(n): q = -10 for i in range(j+1): if q &lt; (p[i]+r[j-i]): q = (p[i]+r[j-i]) s[j] = i #q = max(q,p[i]+r[j-i]) r[j] = q def find_way(n): cut_rod() print(n,'---&gt;',r[n]) while n &gt; 0: print(s[n]) n = n - s[n] 调用find_way(9)输出 矩阵链乘法题目给定n 个矩阵的序列，希望求它们的乘积：$A_1A_2A_3…A_n$ 。因为矩阵的乘法满足结合律，所以可以对n个矩阵序列加括号，来改变乘积顺序。比如对于矩阵链&lt; $A_1$, $A_2$,$A_3$,$A_4$&gt;可以有下面的加括号方案： 不同的加括号的方案，对于乘积运算的代价影响很大. 两个矩阵相乘，A为p q矩阵，B为q r矩阵。所以A 的乘法次数为pqr。 如果A（10,100 ），B（100,5）， C（5,50 ）三个矩阵相乘。 如果按照((AB)C)的顺序，则需要101005 + 10550 = 7500次乘法运算，如果按照(A(BC))的顺序，则需要100550 + 1010050 = 75000次乘法运算。所以，不同的加括号方案，对于矩阵链乘法的代价影响很大。 刻画最优解的结构特征通过寻找最优子结构，利用最优子结构从子问题的最优解中构造出原问题的最优解。假设$AiA{i+1}…A_j$的最优括号花方案的分割点是在$Ak$和$A{K+1}$之间，一个非平凡的矩阵链乘法任何时候都是需要划分链的，任何最优解都是有子问题的最优解构成的。 递归的定义最优解的值令 $m[i,j]$ 表示计算矩阵 $A{i,j}$ 所需标量乘法的最小值，也即原问题的最优解，计算 $A{1..n}$ 的最低代价就是 $m[1,n]$。 对于i == j 的平凡问题，矩阵链只包含唯一的矩阵$A_{i,j}$。 对于$AiA{i+1}…A_j$的最优括号化方案的切割点在$Ak$和$A{k+1}$之间。那么$m[i,j]$的解相当于计算$A{i..k}$和$A{k+1..j}$的代价加上，合并这两个子答案所需要的代价$p_{i-1}p_k p_j$ 因此，我们得到 $$m[i,j] = m[i,k]+m[k,j]+p_{i-1}p_k p_j$$ 计算最优解的值算法应当按照长度递增的顺序求解矩阵链括号化问题，并按照对应的顺序填写表m。对举证连$A_{i,j}$，其规模为链的长度j-i+1 伪代码就不写了，直接写python代码 python实现矩阵链乘法问题1234567891011121314151617181920212223242526272829303132def MATRIX_CHAIN_ORDER(p): n = len(p) s = [[0 for j in range(n)] for i in range(n)] m = [[0 for j in range(n)] for i in range(n)] for l in range(2, n): #l is the chain length for i in range(1, n-l+1): j = i + l - 1 m[i][j] = 1e9 for k in range(i, j): q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j] if q &lt; m[i][j]: m[i][j] = q s[i][j] = k PRINT_OPTIMAL_PARENS(s, 1, n-1) return m def PRINT_OPTIMAL_PARENS(s, i, j): if i == j: print('A', end = '') print(i, end = '') else: print('(', end = '') PRINT_OPTIMAL_PARENS(s, i, s[i][j]) PRINT_OPTIMAL_PARENS(s, s[i][j]+1, j) print(')', end = '') if __name__ == \"__main__\": A = [30, 35, 15, 5, 10, 20,25] m = MATRIX_CHAIN_ORDER(A) print('\\n','共计需要',m[1][n-1],'次相乘') 需要注意的问题是，这个算法的复杂度在O(n∧3)。而且这个算法和算法导论等地方的伪码比有些细微的差异体现在数组从0开始还是1开始上。大体上还是一致的。这里的空间复杂度也到了O(n∧2)。大致的计算顺序就是通过这个函数中的l来控制。l=2的时候，依次计算矩阵A[0]A[1], A[1]A[2], A[2]A[3]…的次数。l=3的时候就开始计算A[0]A[1]A[2], A[1]A[2]*A[3]..的次数。用更形象的话来说就是倒三角的顺序。下面的这个图就是对上面流程的描述： 以上","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://feiyang.li/tags/dynamic-programming/"}]},{"title":"Python读取mnist","slug":"python-mnist","date":"2017-03-17T08:25:27.000Z","updated":"2017-03-26T11:39:21.829Z","comments":true,"path":"2017/03/17/python-mnist/index.html","link":"","permalink":"http://feiyang.li/2017/03/17/python-mnist/index.html","excerpt":"在做 TensorFlow和Python实现神经网络的时候，需要利用到一个MNIST数据集，数据集的格式是以.idx1-ubyte后缀，包含60000个训练图像。将这些图像展示出来，需要利用到struct模块。","text":"在做 TensorFlow和Python实现神经网络的时候，需要利用到一个MNIST数据集，数据集的格式是以.idx1-ubyte后缀，包含60000个训练图像。将这些图像展示出来，需要利用到struct模块。 下载MNIST训练数据集手动下载下载链接为： http://yann.lecun.com/exdb/mnist/ 下载好之后解压就可以了，网站好像被墙了？ 使用tensorflow自带下载可以看到，这个地方是有监督学习 (有label这个东西嘛)12345678from tensorflow.examples.tutorials.mnist import input_data# 下载mnist数据集mnist = input_data.read_data_sets('/tmp/', one_hot=True)# 数字(label)只能是0-9，神经网络使用10个出口节点就可以编码表示0-9；# 1 -&gt; [0,1.0,0,0,0,0,0,0,0] one_hot表示只有一个出口节点是hot# 2 -&gt; [0,0.1,0,0,0,0,0,0,0]# 5 -&gt; [0,0,0,0,0,1.0,0,0,0]# /tmp是macOS的临时目录，重启系统数据丢失; Linux的临时目录也是/tmp 详细步骤读取文件12with open(filename ,'rb') as f1: buf1 = f1.read() 还有另外一种常用的方法，两个方法目前来看没有什么区别。12f1 = open(filename , 'rb')buf = binfile.read() # 先使用二进制方式把文件都读进来 跨过头部区域train-images-idx3-ubyte1234567891011TRAINING SET IMAGE FILE (train-images-idx3-ubyte):[offset] [type] [value] [description] 0000 32 bit integer 0x00000803(2051) magic number 0004 32 bit integer 60000 number of images 0008 32 bit integer 28 number of rows 0012 32 bit integer 28 number of columns 0016 unsigned byte ?? pixel 0017 unsigned byte ?? pixel ........ xxxx unsigned byte ?? pixel 可以看到头部有4个integer 类型，设置image_index += struct.calcsize(&#39;&gt;IIII&#39;)计算4个integer 值的位置，然后image_index 直接跳过去。至于为什么用IIII，愿意的话可以点击了解。 123temp = struct.unpack_from('&gt;784B', buf1, image_index) # '&gt;784B'的意思就是用大端法读取784( 28*28 )个unsigned byteim = np.reshape(temp,(28,28)) 最后那句np.reshape(temp,(28,28))是以下两句的缩写12im = np.array(im)im = im.reshape(28,28) train-labels-idx1-ubyte可以看到头部有2个integer 类型，同理，label_index 直接跳过去。12345678910TRAINING SET LABEL FILE (train-labels-idx1-ubyte):[offset] [type] [value] [description] 0000 32 bit integer 0x00000801(2049) magic number (MSB first) 0004 32 bit integer 60000 number of items 0008 unsigned byte ?? label 0009 unsigned byte ?? label ........ xxxx unsigned byte ?? labelThe labels values are 0 to 9. 显示图片1plt.imshow(im , cmap='gray') 应该就可以看到图片了，是一张5， 当然头部文件还是要有的12345678910111213%matplotlib inlineimport numpy as npimport structimport matplotlib.pyplot as pltpath = 'E:\\\\Machine Learning\\\\train-images.idx3-ubyte'with open(path,'rb') as f1: buf1 = f1.read() image_index = 0image_index += struct.calcsize('&gt;IIII')temp = struct.unpack_from('&gt;784B', buf1, image_index) # '&gt;784B'的意思就是用大端法读取784( 28*28 )个unsigned byteim = np.reshape(temp,(28,28))plt.imshow(im , cmap='gray') 多张图片读取 12345678910111213141516171819202122232425262728293031323334353637383940414243# coding=utf-8import numpy as npimport structimport matplotlib.pyplot as pltdef readfile(): with open('E:\\\\Machine Learning\\\\train-images.idx3-ubyte','rb') as f1: buf1 = f1.read() with open('E:\\\\Machine Learning\\\\train-labels.idx1-ubyte','rb') as f2: buf2 = f2.read() return buf1, buf2def get_image(buf1): image_index = 0 image_index += struct.calcsize('&gt;IIII') im = [] for i in range(9): temp = struct.unpack_from('&gt;784B', buf1, image_index) # '&gt;784B'的意思就是用大端法读取784个unsigned byte im.append(np.reshape(temp,(28,28))) image_index += struct.calcsize('&gt;784B') # 每次增加784B return imdef get_label(buf2): # 得到标签数据 label_index = 0 label_index += struct.calcsize('&gt;II') return struct.unpack_from('&gt;9B', buf2, label_index)if __name__ == \"__main__\": image_data, label_data = readfile() im = get_image(image_data) label = get_label(label_data) for i in range(9): plt.subplot(3, 3, i + 1) title = u\"标签对应为：\"+ str(label[i]) plt.title(title, fontproperties='SimHei') plt.imshow(im[i], cmap='gray') plt.show() 遇到的一些坑： 中文标题乱码的问题 1plt.title(title, fontproperties='SimHei') # 后边这个字体**SimHei**加上就好了 标题内部不能用+在外部加好之后，赋值给新变量，然后放进title即可","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"细究Python struct 模块","slug":"python-struct","date":"2017-03-17T06:08:07.000Z","updated":"2017-03-26T11:39:20.941Z","comments":true,"path":"2017/03/17/python-struct/index.html","link":"","permalink":"http://feiyang.li/2017/03/17/python-struct/index.html","excerpt":"struct — Interpret bytes as packed binary data，将字节与二进制文件相互转化的工具Python struct 模块。","text":"struct — Interpret bytes as packed binary data，将字节与二进制文件相互转化的工具Python struct 模块。 关于格式字符串在Python手册中，给出了C语言中常用类型与Python类型对应的格式符： 格式符 C语言类型 Python类型 x pad byte no value c char string of length 1 b signed char integer B unsigned char integer ? _Bool bool h short integer H unsigned short integer i int integer I unsigned int integer or long l long integer L unsigned long long q long long long Q unsigned long long long f float float d double float s char[] string p char[] string P void * struct.pack(fmt, v1, v2, …) Return a string containing the values v1, v2, … packed according to the given format. The arguments must match the values required by the format exactly. struct.pack用于将Python的值根据格式符，转换为字符串,准确来说是Byte。这个地方我们之前有提过，Python3内的unicode和bytes，在Py3内文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Py2是没有Byte这么个东西的。参数fmt是格式字符串，v1, v2, …表示要转换的python值。下面的例子将两个整数转换为字符串: 12345678910111213141516import struct a = 20 b = 400byte = struct.pack(\"ii\", a, b) #转换后的str相当于其他语言中的字节流（字节数组），可以在网络上传输 big = struct.pack(\"&gt;ii\", a, b) #大端保存small = struct.pack(\"&lt;ii\", a, b) #小端保存print(byte)# &gt;&gt;&gt;:b'\\x14\\x00\\x00\\x00\\x90\\x01\\x00\\x00'print(big)# &gt;&gt;&gt;:b'\\x00\\x00\\x00\\x14\\x00\\x00\\x01\\x90'print(small)# &gt;&gt;&gt;:b'\\x14\\x00\\x00\\x00\\x90\\x01\\x00\\x00'print (byte[0],byte[4]) # &gt;&gt;&gt;:b'\\x14\\x00\\x00\\x00\\x90\\x01\\x00\\x00' 格式符”i”表示转换为int，’ii’表示有两个int变量。进行转换后的结果长度为8个字节（int类型占用4个字节，两个int为8个字节）可以看到输出的结果是乱码，因为结果是二进制数据，所以显示为乱码。可以使用python的内置函数repr来获取可识别的字符串 ，以上问题在Python3中不会出现了其中十六进制的0x00000014, 0x00000190分别表示20和400。 上一段代码最后那个很有意思诶，竟然是默认采用小端。 大端存储和小端存储小端：较高的有效字节存放在较高的存储器地址，较低的有效字节存放在较低的存储器地址。大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。 如果将一个16位的整数0x1234存放到一个短整型变量（short）中。这个短整型变量在内存中的存储在大小端模式由下表所示。 地址偏移 大端模式 小端模式 0x00 12（OP0） 34（OP1） 0x01 34（OP1） 12（OP0） 采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。 struct.unpack(fmt, buffer) Unpack from the buffer buffer (presumably packed by pack(fmt, …)) according to the format string fmt. The result is a tuple even if it contains exactly one item. The buffer’s size in bytes must match the size required by the format, as reflected by calcsize(). struct.unpack做的工作刚好与struct.pack相反，用于将字节流转换成python数据类型。它的函数原型为：struct.unpack(fmt, string)，该函数返回一个tuple。 123a1, a2 = struct.unpack(\"ii\", byte) print(type(struct.unpack(\"ii\", byte)),a1,a2)# &gt;&gt;&gt;:&lt;class 'tuple'&gt; 20 400 struct.calcsize(fmt) Return the size of the struct (and hence of the bytes object produced by pack(fmt, …)) corresponding to the format string fmt. struct.calcsize用于计算格式字符串所对应的结果的长度，如：struct.calcsize(‘ii’)，返回8。因为两个int类型所占用的长度是8个字节。 参考链接：https://docs.python.org/3/library/struct.htmlhttp://blog.csdn.net/occupy8/article/details/11052103","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Ubuntu14.04+CPU+Python的Caffe安装教程","slug":"Ubuntu-caffe","date":"2017-03-16T02:52:28.000Z","updated":"2017-03-25T10:51:10.817Z","comments":true,"path":"2017/03/16/Ubuntu-caffe/index.html","link":"","permalink":"http://feiyang.li/2017/03/16/Ubuntu-caffe/index.html","excerpt":"背景：手头只有一个win主机，虚拟机版本：Ubuntu14.04，目标是安装后CAFFE能作为PYTHON MODULE来使用，只使用CPU模式","text":"背景：手头只有一个win主机，虚拟机版本：Ubuntu14.04，目标是安装后CAFFE能作为PYTHON MODULE来使用，只使用CPU模式 安装开发所依赖的安装包 打开Ubuntu的终端，输入命令。1234sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compilersudo apt-get install --no-install-recommends libboost-all-devsudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-devsudo apt-get install libatlas-base-dev 升级g++1g++ --version&lt;/span&gt; 查看g++版本，由于编译需要至少4.8版本的g++，一般来说，自带版本应该时4.8。如果想要升级g++，这里也提供以下下载方式，并且设置默认编译的g++为最新版本。1234567sudo add-apt-repository ppa:ubuntu-toolchain-r/test #用来添加库信息的帮助脚本。 sudo apt-get update #更新 sudo apt-get install gcc-4.9 sudo apt-get install g++-4.9 #更新g++，gcc sudo ln -sf /usr/bin/gcc-4.9 /usr/bin/gcc #在调用的gcc库上做一个与最新版本的软连接，更改g++的默认版本。 sudo ln -sf /usr/bin/gcc-ar-4.9 /usr/bin/gcc-ar sudo ln -sf /usr/bin/gcc-ranlib-4.9 /usr/bin/gcc-ranlib 安装anaconda，建议安装。12wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-4.3.1-Linux-x86_64.shbash Anaconda3-4.3.1-Linux-x86_64.sh 安装过程中记得一直选择默认的就行，傻瓜式安装。是否在bashrc中添加路径，这里选择“yes”就可以。忘了的话，解决方法很麻烦，自己查查吧。 安装OpenCV2.4(这个经常失败，建议跳过，不影响使用)123git clone https://github.com/bearpaw/Install-OpenCVcd Install-OpenCV/Ubuntu/2.4sh ./opencv2_4_10.sh 编译过程很慢，中间我还报过一次错，不得不重新来了一次。如果觉得难度不够的话，可以选择官网的安装包：http://opencv.org/，我这里是根据大神编译过的版本进行安装的。 安装atlas1sudo apt-get install libatlas-base-dev #安装atlas简单易行。 编译Caffe下载caffe12cd ~ git clone https://github.com/BVLC/caffe.git 修改Makefile配置123cd caffe cp Makefile.config.example Makefile.config gedit Makefile.config #我个人比较喜欢gedit ，用起来方便。 CPU_ONLY := 1 配置一些引用文件（增加部分主要是解决新版本下，HDF5的路径问题） 123INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serialLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu/hdf5/serialBLAS := atlas 编译caffe123make all -j8make test -j8make runtest -j8 另外, 这个make默认是用CPU单核运算,如果想要快一点, 比如我想使用四核, 在make后面加上-j4标签。如果上面4行某一行报错之后想要重试,建议先make clean再重新开始。 更新安装依赖。12cd caffe cat python/requirements.txt | xargs -L 1 sudo pip install 编译Python接口打开新的终端, 用which Python和which pip确定使用的是anaconda提供的python环境，然后进入caffe/python, 执行下列命令， 确保pip已经安装12sudo apt-get install python-pipfor req in $(cat requirements.txt); do pip install $req; done #python运行需要的库。 再次回到caffe根目录我们可以执行：在caffe根目录的python文件夹下，有一个requirements.txt的清单文件，上面列出了需要的依赖库，按照这个清单安装就可以了。在安装scipy库的时候，需要fortran编译器（gfortran)，如果没有这个编译器就会报错，因此，我们可以先安装一下。 回到caffe的根目录，然后执行安装代码： 1234cd ~/caffesudo apt-get install gfortrancd ./pythonfor req in $(cat requirements.txt); do pip install $req; done 安装完成以后，再次回到caffe根目录我们可以执行：1sudo pip install -r python/requirements.txt 就会看到，安装成功的，都会显示Requirement already satisfied, 没有安装成功的，会继续安装。 编译python接口1make pycaffe -j8 运行python进入caffe/python ，运行123456$ python2.7Python 2.7.12 (default, Jul 1 2016, 15:12:24) [GCC 5.4.0 20160609] on linux2Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; import caffe&gt;&gt;&gt; 加入PythonPathgedit ~/.bashrc将export PYTHONPATH=/home/wing/caffe/python:$PYTHONPATH添加到文件最后。source ~/.bashrc 使更改生效。这样，在其他地方打开python，也可以import caffe了。 出现过一个问题：error ：No module named google.protobuf.internal解决方法是：sudo chmod 777 -R anaconda（文件夹） 改变权限 然后conda install protobuf可以很方便的解决的问题","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Win10 Anaconda中安装Tensorflow并配置到jupter kernel","slug":"win10-conda-tensorflow","date":"2017-03-15T05:22:44.000Z","updated":"2017-03-16T02:57:34.710Z","comments":true,"path":"2017/03/15/win10-conda-tensorflow/index.html","link":"","permalink":"http://feiyang.li/2017/03/15/win10-conda-tensorflow/index.html","excerpt":"Windows环境下 Anaconda中安装Tensorflow，并且将Tensorflow配置到jupyter notebook中去。","text":"Windows环境下 Anaconda中安装Tensorflow，并且将Tensorflow配置到jupyter notebook中去。 安装Anaconda下载：https://www.continuum.io/downloads ，我用的是Python 3.5下载完以后，安装。 输入清华的仓库镜像，更新包更快：12conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes 推荐第一行命令输入两次，以便把这个镜像地址放在首位。 安装TensorFlow一般来说，我们推荐新建一个新的virtualenv，这样可以预防同一个环境中的包太多，相互发生冲突。1conda create -n tensorflow python=3.5 既然是建议，那么忽视上边这一句话，也是可以的。 1activate tensorflow 激活后，我选择安装的是CPU版本，输入： pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-0.12.0-cp35-cp35m-win_amd64.whl 安装失败的话多试几次 加入jupyter notebook的ipykernel内核123source activate tensorflow# On Windows, remove the word &apos;source&apos;install ipykernelpython -m ipykernel install --user --name tensorflow--display-name &quot;Python (myenv)&quot; 在激活状态下，安装ipykernel，后边那个展示名称，自己可以随便填。进入jupyter notebook ，运行一下测试文件，看是否可以使用。 如果不行，输入jupyter --paths 检查一下kernal是不是设置的有问题，比如我的就是C:\\Users\\wing\\AppData\\Roaming\\jupyter\\kernels\\tensorflow一般来说是环境所在的地址有问题，修改一下就可以啦。 通过这个方法，可以把自己手贱多加上去的kernel删掉。jupyter kernal 删除更多建议阅读官方文档 我记得这个地方蛮复杂的，我当时往kernel里边加入R内核，费了大力气。当时还没写博客的习惯，现在又忘记怎么加的，真是日了狗。 测试：12345678910import tensorflow as tftf.__version__&gt;&gt;&gt;:'1.0.1'sess = tf.InteractiveSession()x = tf.Variable([1.0, 2.0])a = tf.constant([3.0, 3.0])x.initializer.run()# 使用初始化器 initializer op 的 run() 方法初始化 ‘x‘ sub = tf.sub(x, a)# 增加一个减法 sub op, 从 ‘x‘ 减去 ‘a‘. 运行减法 op, 输出结果 sub.eval()&gt;&gt;&gt;:array([-2., -1.], dtype=float32) 我碰到了一个module &#39;tensorflow&#39; has no attribute &#39;sub&#39;，原因是tensorflow升级了之后，这个sub函数被改成了subtract，代码改成sub = tf.subtract(x, a)即可。","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://feiyang.li/tags/Jupyter/"}]},{"title":"《小萝莉的猴神大叔》","slug":"indian-movie","date":"2017-03-11T07:06:14.000Z","updated":"2017-03-13T10:45:25.356Z","comments":true,"path":"2017/03/11/indian-movie/index.html","link":"","permalink":"http://feiyang.li/2017/03/11/indian-movie/index.html","excerpt":"但行好事，莫问前程。真正能做到的能有几个呢？","text":"但行好事，莫问前程。真正能做到的能有几个呢？ 没看过几部印度电影，算上三傻，这也仅仅是第二部而已。什么小萝莉的猴神大叔，印度电影命名水平还是一如既往的差。 刚开始看的时候呀，我一边哈哈哈一边和室友猜下边将发生啥，猜了好几次，竟然都猜对了。 后来不知道怎么了，就不想说话了，戴着耳机投入到猴神大叔的世界了。就算猜到了结尾，也丝毫不影响我看的时候哭的稀里哗啦的。 我其实不太懂印度巴基斯坦那边的渊源，也不太懂宗教信仰之类的，所以我觉得我应该错过了好多值得玩味的小细节。 印度电影中的人物好像总是一言不合就唱歌跳舞，开心也跳，难过也跳，想跳就跳，一跳还跳很长时间，但我还挺喜欢看的。 国家和国家之间，宗教和宗教之间也许有很多矛盾，但是爱和信仰是相通的。 善良朴实虔诚的猴神大叔因为对小女孩的一个承诺，毅然决然的走上了送小女孩回家的路。这一路，太凶险，却也不乏各种各样善良的人的帮助。 小女孩从小无法说话，后来又和家人走丢，这本是一件不幸的事，却因为遇到了猴神大叔，遇到正义的摄影师，遇到善良的伊斯兰教父，还有很多很多充满善意的人，才如此幸运的回到妈妈身边。 感觉这个世界上，像猴神大叔这样的好人还是太少了。 因为爱，扛起对一个陌生小姑娘的全部责任，从一个平庸的别人眼中的失败者，到无所不能面对重重困难都充满力量的人。 但行好事，莫问前程。真正能做到的能有几个呢？ 主题歌是这样唱的： 你是我的道路，你与我为伴 我找寻着你，也找到了自己 我是你的声音，而你是我的语言 我们相遇之后，我感觉充满了力量 我们相遇之后，我变得无所不能 尽管终点困难重重，但前方的路不再迷茫 我是你的小路，你是我的小棉袄 找到你的足迹，我也找到了自己 因为你是我心脏跳动的力量。 最后一幕永远定格在我的内心深处，人至善、水至柔、景至美、情至真！再铁骨铮铮的汉子也会为之动容。 记得有人说过，好人会受伤，会流泪，会不知所措，但好人永远是这个世界的魂，向好人致敬！","categories":[],"tags":[{"name":"臭臭","slug":"臭臭","permalink":"http://feiyang.li/tags/臭臭/"},{"name":"Movie","slug":"Movie","permalink":"http://feiyang.li/tags/Movie/"}]},{"title":"细究Python键盘输入","slug":"python-input","date":"2017-03-10T05:52:53.000Z","updated":"2017-03-27T11:44:05.567Z","comments":true,"path":"2017/03/10/python-input/index.html","link":"","permalink":"http://feiyang.li/2017/03/10/python-input/index.html","excerpt":"本文介绍了raw_input 和 input在python2和python3上的区别，以及如何利用正则表达式和input键盘输入一维数组和二维数组。","text":"本文介绍了raw_input 和 input在python2和python3上的区别，以及如何利用正则表达式和input键盘输入一维数组和二维数组。 raw_input 和 inputpython2中12raw_input_A = raw_input(\"raw_input: \")type(raw_input_A) 可以看到输出的是 str 12input_A = input(\"Input: \") #不能输入字母type(raw_input_A) 可以看到输出的是 int，并且我们发现，input根本不能输入字母，会直接报NameError: name &#39;abc&#39; is not defined，提示没有定义。 查看 Built-in Functions ，得知：input([prompt]) Equivalent to eval(raw_input(prompt)) input() 本质上还是使用 raw_input() 来实现的，只是调用完 raw_input() 之后再调用 eval() 函数，所以，你甚至可以将表达式作为 input() 的参数，并且它会计算表达式的值并返回它。不过在 Built-in Functions 里有一句话是这样写的：Consider using the raw_input() function for general input from users.除非对 input() 有特别需要，否则一般情况下我们都是推荐使用 raw_input() 来与用户交互。 python3中因为刚才说的那个原因，input其实没有什么必要，所以就被改进了。 简单来说，raw_input没有了，只剩下input。现在这个input就是之前那个raw_input。 查看 Python官方文档input([prompt]) ，得知： If the prompt argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, EOFError is raised. 简单说，返回的内容都是str，括号里边的prompt写什么，就会当做提示内容输出。比如底下的那个 --&gt;1234&gt;&gt;&gt; s = input('--&gt; ') --&gt; Monty Python's Flying Circus&gt;&gt;&gt; s \"Monty Python's Flying Circus\" 因为我一般都是用python3，接下来的内容都是以3为准。 Python输入数组一维数组 使用int()进行强制类型转型 当输入内容不为数字时，不能转型，发生except跳出循环。 先声明data是一个list，将input_A一个个+进去。123456789data = []while True: try: input_A = int(input(\"Input: \")) data +=[input_A] except: breakdatatype(data) 在以上的基础上，我们可以用python输入二维数组 python输入二维数组正则表达式会利用非数字的字符，进行切割，因此数字之间插入什么都无所谓。 12345678910111213import redata2D = []while True: userInput = input('Input:') # 输入数组，用空格隔开即可 info = re.split(r'[\\D]',userInput)#正则表达式分割 data = []# 定义一维数组 try: for number in info: data+=[int(number)] # 一维数组加入数字 data2D+=[data] #一维数组加入到二维中去 except: break;data2D","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"算法导论 第7章 快速排序","slug":"Python-quick-order","date":"2017-03-09T14:22:16.000Z","updated":"2017-03-25T05:10:12.327Z","comments":true,"path":"2017/03/09/Python-quick-order/index.html","link":"","permalink":"http://feiyang.li/2017/03/09/Python-quick-order/index.html","excerpt":"快速排序是一种非常优秀的排序方法","text":"快速排序是一种非常优秀的排序方法 对于包含n个数的输入数组来说，快速排序是一种最坏情况是$$\\theta(n^{2})$$ 的算法，虽然表现出的状态和堆排序是相似的。但实际上，快速排序的复杂度绝大部分情况的都可以做到$$\\theta(nlgn)$$) 快排算法的描述快排算法分为两部分： 分解：数组A[p..r]被分解为A[p...q-1]和A[q+1...r]，其中A[p...q-1]内的元素都比A[q]小，A[q+1...r]中的元素都比A[q]大。 解决：通过调用快速排序，解决A[p...q-1]和A[q+1...r]。 合并：因为元素都是原址排序，因此不需要合并操作。 伪代码对整个数组进行递归排序：12345QUICKSORT(A,p,r)if p &lt; r: q = PARTITION(A,p,r); QUICKSORT(A,p,q-1); QUICKSORT(A,q+1,r); 快速排序算法的关键是PARTITION过程，它对A[p..r]进行就地重排：123456789PARTITION(A,p,r)x = A[r]i = p-1for j = p to r-1// A[j]是待比较的元素 if A[j] ≤ r// 若A[j]比主元小 i = i + 1 // i往后一位（符合，不用替换；不符合i就停在这个地方，等着j过来叫唤） exchange A[i] with A[j]//倘若A[j]比主元小，其实是不发生交换的。exchange A[i+1] with A[r]return i + 1 借用一张《算法导论》的图 参考代码C++代码基本和伪代码是一样的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;void swap(int *a, int *b) &#123; int temp = *b; *b = *a; *a = temp;&#125;void print(int *A, int len) &#123; for (int i = 0; i &lt; len; i++) &#123; printf(\"%4d\", A[i]); &#125; printf(\"\\n\");&#125;int PARTITION(int *A, int p, int r) &#123; int i = p - 1; int x = A[r]; for (int j = p; j &lt; r; j++) &#123; if (A[j] &lt;= x) &#123; i++; swap(&amp;A[i], &amp;A[j]); &#125; &#125; swap(&amp;A[i + 1], &amp;A[r]); return i + 1;&#125;void QUICKSORT(int A[], int p, int r) &#123; if (p &lt; r) &#123; int q = PARTITION(A, p, r); QUICKSORT(A, p, q - 1); QUICKSORT(A, q + 1, r); &#125; return;&#125;int main() &#123; int A[] = &#123; 9,10,11,7,1,2,3,6,5,8,4 &#125;; print(A, 11); QUICKSORT(A, 0, 10); print(A,11); return 0;&#125; 期间出了一个错误，error C3861: 找不到标识符。后发现是因为把PARTITION放在了QUICKSORT后边，导致QUICKSORT找不到PARTITION。 python代码123456789101112131415161718192021222324252627# coding=utf-8def PARTITION(A,p,r): x = A[r] i = p - 1 for j in range(p,r): if A[j]&lt;=x: i = i + 1 temp = A[i] A[i] = A[j] A[j] = temp #python没有指针，这个地方稍微不一样 temp = A[i+1] A[i+1] = A[r] A[r] = temp return i+1def QUICKSORT(A,p,r): if p &gt;= r: return q = PARTITION(A,p,r) QUICKSORT(A,p,q-1) QUICKSORT(A,q+1,r) if __name__ == '__main__': l = [9,10,11,7,1,2,3,6,5,8,4] ; QUICKSORT(l,0,len(l)-1) print(l) 这里使用的数组是list，声明方式是l = [9,10,11,7,1,2,3,6,5,8,4]，注意那个[]。如果使用元组tuple，会导致元素不能修改。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"sort","slug":"sort","permalink":"http://feiyang.li/tags/sort/"},{"name":"cpp","slug":"cpp","permalink":"http://feiyang.li/tags/cpp/"}]},{"title":"Digitalocean一键搭建vpn","slug":"do-vpn","date":"2017-03-03T06:17:00.000Z","updated":"2017-03-06T14:07:04.569Z","comments":true,"path":"2017/03/03/do-vpn/index.html","link":"","permalink":"http://feiyang.li/2017/03/03/do-vpn/index.html","excerpt":"使用github学生优惠内的digitalocean，一键搭建vpn。获得60刀，免费用一年~","text":"使用github学生优惠内的digitalocean，一键搭建vpn。获得60刀，免费用一年~ 准备工作为什么选择DigitalOcean 可以不用信用卡，通过Paypal即可绑定。 有512MB内存、单核处理器可选，每月5美元。 每月1000GB的流量 申请github学生优惠包 前往 https://education.github.com/pack/ 申请学生优惠包 有账号就直接登录，没有账号选择注册账号： 申请的时候，会问你是不是学生，那我肯定说是学生啦，我又不是撒 然后会要求提供学校名称，所以那么骗人的edu邮箱基本是没有办法使用的。最后那句How do you plan to use GitHub? 你就说I&#39;ll public my program at github.或者什么I love github，开心就好，说什么无所谓。 很快就会审核通过，会邮件通知。 领取 DigitalOcean 优惠包 看到这个码，50刀就到你手了。 注册DO账号，用我的邀请链接注册，多送10刀。https://m.do.co/c/990a117f5061 ，注册之后需要付款5刀，这个时候不要用paypel的汇率，用本地的汇率。 使用DigitalOcean邀请注册之后就不能使用github学生包50刀的处理方法我看到很多人提到领取了这个10刀之后，那个50刀的github优惠包里边的码就不能用了。简直一派胡言，I’m angry。可以通过提交ticket然后告诉他，我不知道github学生优惠包里边的码怎么用，让他给你处理。一般来说分分钟就会回复邮件，帮你加上50刀。如果使用我的推荐链接的话，我可以把我的回复内容复制给你。 安装vpn这里使用一键安装脚本，基于centos。 新建vps选择顶栏第一个 Droplets，点击create droplet选择5刀，centos的这一款，地点选择San Francisco，这个新加坡，虽然离中国近，但是速度慢，旧金山还是比较合适的。选择确定之后，会发邮件告诉你IP地址以及账号密码。 一键安装vpn 使用putty 连接vps，我在打马赛克那个地方输入ip地址。然后点open 第一次进行会有个提示，点击确定就好。之后会要求输入当前密码账号，按照邮箱里边给的密码写就可以了。 成功登陆后，还会要求输入当前密码，然后自己设置新密码 一键安装vpn代码 12345wget https://raw.githubusercontent.com/mmmwhy/centos-setup-simple-pptp-vpn/master/setup.shchmod +x ./setup.sh./setup.sh 全部复制，点两下确定，然后坐等片刻，vpn就搭好了。 搭建的是最常见的pptp协议类型的vpn，使用win自带拨号程序即可连接。 修改账户密码sudo vi /etc/ppp/chap-secrets都有提示，按i之后修改就可以了。 小结之前一直懒得写这样一篇教程，但是发现好多人对这方面都不了解，我稍微解释了一下。 邀请得到的10刀和github50刀可以共存的问题 申请github学生优惠包的时候怎样描述自己的plan paypel付款时，不要用paypel的汇率，用本地的汇率 一键安装包用的是linuxeye的脚本，我略微修改，还请多多指教。","categories":[],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"},{"name":"github","slug":"github","permalink":"http://feiyang.li/tags/github/"},{"name":"vpn","slug":"vpn","permalink":"http://feiyang.li/tags/vpn/"}]},{"title":"IntelliJ 、Pycharm激活码及激活服务器","slug":"jetbrains","date":"2017-02-26T13:28:39.000Z","updated":"2017-02-28T03:22:11.178Z","comments":true,"path":"2017/02/26/jetbrains/index.html","link":"","permalink":"http://feiyang.li/2017/02/26/jetbrains/index.html","excerpt":"jetbrains 家的东西都非常好看，但是价格贵的令人发指，所以我搭建了一个 Pycharm激活服务器，可以用来激活 Pycharm，IntelliJ IDEA，WebStorm。避免频繁更换激活码的问题。","text":"jetbrains 家的东西都非常好看，但是价格贵的令人发指，所以我搭建了一个 Pycharm激活服务器，可以用来激活 Pycharm，IntelliJ IDEA，WebStorm。避免频繁更换激活码的问题。 jetbrains 激活服务器搭建一台VPS连vps都没有，小拳头你怕不怕(ง •̀_•́)ง 。 那你用我的吧，╮(╯▽╰)╭ 。 一键脚本建议在特权模式下运行，即sudo -s一下1wget http://home.ustc.edu.cn/~mmmwhy/jetbrain.sh &amp;&amp; sh ./jetbrain.sh 会出现两个空，用于输入端口号和默认用户名，建议直接回车，否则可能会出现莫名其妙的错误。 将最后那个License sever地址记下，之后激活用。 激活选择License sever激活方式，输入激活地址 分分钟应该就会弹出提示，一劳永逸解决激活问题。 激活服务器分享我搭建了一个激活服务器，直接公布会很容易被封，需要的请关注：回复“激活”即可获得地址。 Pycharm激活码 / IntelliJ IDEA激活码双击复制全部1CNEKJPQZEX-eyJsaWNlbnNlSWQiOiJDTkVLSlBRWkVYIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTgtMDEtMzAifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOC0wMS0zMCJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE4LTAxLTMwIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE4LTAxLTMwIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTgtMDEtMzAifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTgtMDEtMzAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxOC0wMS0zMCJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE4LTAxLTMwIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTgtMDEtMzAifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxOC0wMS0zMCJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE4LTAxLTMwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTgtMDEtMzAifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxOC0wMS0zMCJ9XSwiaGFzaCI6IjUxOTU1OTMvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-QOxwjWvRwJz6vo6J6adC3CJ4ukQHosbPYZ94URUVFna/Rbew8xK/M5gP3kAaPh6ZDveFdtMR1UBoumq3eCwXtXM3U3ls5noB4LIr+QplVlCj2pK5uNq7g/feyNyQcHpSXtvhIOnXDBLOecB05DOsxzm0p7ulGGJoAInmHeb9mc0eYjqc4RPpUQfh6HSYBnvEnKMlLF5bz4KEtzmsvvgA55CwzwQ3gRitm5Q/wUT7AQCBdjmBfNUjKVQL6TSjSDPp56FUdEs4Aab8LqstA2DIMbxocO64rvytmcUeIwu8Mi5uq87KQP5AQMSMYb59Inbd+dmVfx5cJo3fRS4/5s3/Hg==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 在Activate code处粘贴进去即可 衷心感谢博主：ilanyu， http://blog.lanyus.com/","categories":[],"tags":[{"name":"Pycharm激活","slug":"Pycharm激活","permalink":"http://feiyang.li/tags/Pycharm激活/"}]},{"title":"Hexo博客中插入音乐/视频","slug":"Hexo-music-video","date":"2017-02-24T12:57:01.000Z","updated":"2017-02-25T05:59:28.975Z","comments":true,"path":"2017/02/24/Hexo-music-video/index.html","link":"","permalink":"http://feiyang.li/2017/02/24/Hexo-music-video/index.html","excerpt":"Hexo插入音乐/视频/网易云音乐/bilibili视频，会让博客看起来很洋气 (ง •̀_•́)ง","text":"Hexo插入音乐/视频/网易云音乐/bilibili视频，会让博客看起来很洋气 (ง •̀_•́)ง Markdown 通用的音乐视频插入方法iframe标签代码从网易云音乐获得 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=430 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=114389&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt; 效果如下： embed标签1&lt;embed height=&quot;415&quot; width=&quot;544&quot; quality=&quot;high&quot; allowfullscreen=&quot;true&quot; type=&quot;application/x-shockwave-flash&quot; src=&quot;//static.hdslb.com/miniloader.swf&quot; flashvars=&quot;aid=8506694&amp;page=1&quot; pluginspage=&quot;//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&quot;&gt;&lt;/embed&gt; 效果如下： javascript标签举例1&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xiami.com/widget/player-single?uid=32329501&amp;sid=1776238762&amp;mode=js&quot;&gt;&lt;/script&gt; 使用 Hexo 插件插入音乐/视频两个好用的hexo插件： hexo-tag-aplayer：https://github.com/grzhan/hexo-tag-aplayer hexo-tag-dplayer： https://github.com/NextMoe/hexo-tag-dplayer 播放音乐的aplayer在cmd页面内，使用npm安装：npm install hexo-tag-aplayer 在markdown内添加以下代码： 1&#123;% aplayer &quot;她的睫毛&quot; &quot;周杰伦&quot; &quot;http://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3&quot; &quot;http://home.ustc.edu.cn/~mmmwhy/jay.jpg&quot; &quot;autoplay=false&quot; %&#125; 效果如下所示： new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: false, showlrc: 0, music: { title: \"她的睫毛\", author: \"周杰伦\", url: \"http://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", } }); 播放视频的dplayer在cmd页面内，使用npm安装：npm install hexo-tag-dplayer 在markdown内添加以下代码： 1&#123;% dplayer &quot;url=http://home.ustc.edu.cn/~mmmwhy/GEM.mp4&quot; &quot;pic=http://home.ustc.edu.cn/~mmmwhy/GEM.jpg&quot; &quot;loop=yes&quot; &quot;theme=#FADFA3&quot; &quot;autoplay=false&quot; &quot;token=tokendemo&quot; %&#125; 效果如下所示： var dplayer0 = new DPlayer({\"element\":document.getElementById(\"dplayer0\"),\"autoplay\":false,\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://home.ustc.edu.cn/~mmmwhy/GEM.mp4\",\"pic\":\"http://home.ustc.edu.cn/~mmmwhy/GEM.jpg\"}}); 以上","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://feiyang.li/tags/hexo/"},{"name":"plugins","slug":"plugins","permalink":"http://feiyang.li/tags/plugins/"}]},{"title":"Django 创建第一个项目","slug":"django-hello-world","date":"2017-02-18T11:37:59.000Z","updated":"2017-02-18T12:41:10.174Z","comments":true,"path":"2017/02/18/django-hello-world/index.html","link":"","permalink":"http://feiyang.li/2017/02/18/django-hello-world/index.html","excerpt":"上手使用Python的Web框架– Django","text":"上手使用Python的Web框架– Django 网上教程安装环境多是linux环境，所以我写一下windows系统下创建Django项目。基于Django 1.10 和Python3.5，作为学生狗的好处之一，就是有很多时间，慢慢琢磨新技术。 windows上virtualenv 安装及使用一开始我不太懂virtualenv 到底有什么意思，后来慢慢各种package装的多了后，发现还是很有必要的。举个例子：如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？ 这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。 正常安装过程 安装virtualenv 1pip install virtualenv 为项目安装虚拟环境为该虚拟环境起个名字，新建文件夹，cd进入。 1virtualenv env 激活环境 1your_env_dir\\Scripts\\activate Pycharm使用虚拟环境上边说的那种方法，完全没有实用性，太扯淡了。切换环境难于上青天，用Pycharm会简便很多。 新建项目 用Pycharm建立虚拟环境 新建之后，在第一个图片那个地方进行选择就可以了，建议新建conda-env，自动新建在envs环境下，方便管理 至此，django环境搭建完毕，接下来学习django工程的创建，以及简单的在网页中显示出”Hello World”。 初识Django工程点击Create创建工程见创建后的工程截图： 文件如下: my_site: 项目的容器。 manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。 my_site/init.py: 一个空文件，告诉 Python 该目录是一个 Python 包。 my_site/settings.py: 该 Django 项目的设置/配置。 my_site/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。 my_site/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。 直接启动Django项目来看执行的结果，启动的方式是：1python manage.py runserver 0.0.0.0:8000 0.0.0.0让其它电脑可连接到开发服务器，8000为端口号。如果不说明，那么端口号默认为8000。 Pycharm启动Django项目 打开manage.py文件 在菜单栏中Run中选择Edit Configurations，见截图：修改Script parameters: runserver ctrl + shift+ F10 运行 Hello world 新建 view.py在先前创建的 my_site 目录下的 my_site 目录新建一个 view.py 文件，并输入代码： 123from django.http import HttpResponsedef hello(request): return HttpResponse(\"Hello world ! \") 我们从 django.http 中导入了 HttpResponse 这个类。我们会在接下来用到这个类。 我们定义了一个叫做 hello 的视图函数(view function)。每个view function至少要有一个参数，通常被叫做 request 。这是一个对象，包含了触发这个 view function的Web请求的信息， 它是 django.http.HttpRequest 的一个实例(instance)。 在这个例子中，虽然我们不对这个 request 做任何处理，但是我们还必须要把它作为视图的第一个参数。 这个函数只有一行简单的代码：它仅仅返回一个 HttpResponse 对象，这个对象包含了文本“Hello world”。 记住，一个视图本身就是一个Python的函数，这个函数接受一个 HttpRequest 作为它的第一个参数，并返回 一个 HttpResponse 的实例。要想让一个Python函数成为一个Django的视图，你需要让它满足这两个条件。 修改urls.py1234567from django.conf.urls import include, urlfrom django.contrib import adminfrom my_site.view import hellourlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^hello/$', hello)] 代码分析 URLconf在Django里，要关联view function到一个URL，需要用到 URLconf。URLconf 就像是你的Django站点的目录。本质上，它是一个URL和这个URL将调用的view function之间的映射关系。 通过这种方式，你就可以告诉Django：“对于这个URL，调用这段代码，对于那个URL，调用那段代码。”例如，当用户访问 /hello/ 时，调用view function hello() ， 这个view function在 views.py 中。因此需要在使用function前，进行声明：from my_site.view import hello。 URLpattern首先，我们从模块mysite/views.py中导入了 hello 这个view function。Python的导入语法用mysite.views表示 mysite/views.py 。(这段代码假设了mysite/views.py在Python的搜索路径中) 接着，我们添加了url(r’^hello/$’, hello), 到 urlpatterns 中。这一行被叫做一个URLpattern。 url() 函数会告诉Django如何处理你配置的url。 url() 的第一个参数是一个模式匹配字符串( 正则表达式)，第二个参数处理这个URLpattern的view function。 补充 正则表达式我们在正则表达式字符串前面加了一个 r 。在Python中，这表示一个原始字符串(raw string)，Python不会去转义那些反斜杠()。在普通的Python字符串中，反斜杠会被用来转义特殊字符，比如字符串 ‘\\n’ 会被解释成换行符。当你加上 r 之后，Python就不会转义那些字符了， r’\\n’ 就是一个包括了一个反斜杠和一个小写字母“n”的字符串。正则表达式中反斜杠的用法和Python字符串中反斜杠的用法刚好冲突了。所以在Python中使用正则表达式的时候最好都加上 r 。本书中所有的URLpattern都会用这种形式。 URLpattern的语法 Django在检查URL模式之前，会移除每个URL最开始的斜杠。这意味着URLpattern并不包括 /hello 开头那个斜杠。(一开始，这可能不太直观，但是这样做简化了很多事情。) 匹配模式里面包括了一个脱字符( ^ )和一个美元符( \\$ )。这两个符号在正则表达式里面的有特别的意义： ^ 要求从字符串开头开始匹配， \\$ 则是要求对字符串尾部进行匹配。 这个URLconf中我们是把 hello 这个view function直接作为一个对象传递的，而不是去调用它。 这是Pyhton(作为动态语言)的一个重要特征，函数是一级对象(first-class objects)，你可以像 传递其它变量一样传递一个函数。很洋气吧？ 以上","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://feiyang.li/tags/Django/"}]},{"title":"第2.1题：Python统计日记最重要的词","slug":"python-camp2-1","date":"2017-02-17T09:04:55.000Z","updated":"2017-03-27T11:44:11.367Z","comments":true,"path":"2017/02/17/python-camp2-1/index.html","link":"","permalink":"http://feiyang.li/2017/02/17/python-camp2-1/index.html","excerpt":"题目来自：Python 练习册。题目2.1： 你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。","text":"题目来自：Python 练习册。题目2.1： 你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。 参考代码123456789101112131415161718192021222324252627282930#coding: utf-8import re, osfrom collections import Counter# 目标文件所在目录PATH = 'D:'def getCounter(source): #输入一个英文的纯文本文件，统计其中的单词出现的个数 with open(source) as f: data = f.read() data = data.lower()#字母全部小写 datalist = re.split(r'[\\s]+', data)#根据空白字符，将data进行划分 return Counter(datalist)def run(PATH): # 切换到目标文件所在目录 os.chdir(PATH) # 遍历该目录下的txt文件 total_counter = Counter() # 生成Counter()对象 for i in os.listdir(os.getcwd()): if os.path.splitext(i)[1] == '.txt':#分离扩展名 total_counter += getCounter(i)# 多个Counter()叠加 return total_counter.most_common()#Counter对象转化为list格式if __name__ == '__main__': dic = run(PATH) for i in range(len(dic)): print('%15s ----&gt; %3s' % (dic[i][0],dic[i][1])) 出现的错误编码问题UnicodeDecodeError: ‘gbk’ codec can’t decode byte…两种解决方法： decode(‘utf-8’)重新编码一下 123fp = open(filename,'rb')content = fp.read().decode('utf-8') open方法指定参数encoding=’UTF-8’: 1content= open('filename', mode='rb', encoding='UTF-8') 但是得注意一下，原文到底是不是UTF-8编码。反正Python编码这里是个大坑，多加小心。 文件名、目录名或卷标语法不正确Path里边的斜杠是 / 不是 \\PATH = &#39;E:/Python/pydata-book-master/ch02&#39; AttributeError: ‘list’ object has no attribute ‘…看看那个object到底是什么，print(type(name)) ，然后再查查其对应的函数。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://feiyang.li/tags/自然语言处理/"}]},{"title":"第1.9题：Python对密码加密","slug":"python-camp9","date":"2017-02-16T13:59:43.000Z","updated":"2017-03-27T11:44:14.250Z","comments":true,"path":"2017/02/16/python-camp9/index.html","link":"","permalink":"http://feiyang.li/2017/02/16/python-camp9/index.html","excerpt":"题目来自：Python 练习册。题目1.9： 通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。","text":"题目来自：Python 练习册。题目1.9： 通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。 思路：salt 加 hash 来单向转换密码明文 参考代码以下给出Py2和Py3两段代码，输出的内容是一样的。因为加密之后的内容不是unicode代码，所以存储可能不方便，可以使用base64.b64encode(hashed)转化为base64编码格式。 Python2代码123456789101112131415161718192021222324252627282930313233import os,base64from hashlib import sha256from hmac import HMACdef encrypt_password(password, salt=None): \"\"\"Hash password on the fly.\"\"\" if salt is None: salt = os.urandom(8) # 64 bits. assert 8 == len(salt) assert isinstance(salt, str) if isinstance(password, unicode): password = password.encode('UTF-8') assert isinstance(password, str) result = password for i in xrange(10): result = HMAC(result, salt, sha256).digest() return salt + resultdef validate_password(hashed, input_password): return hashed == encrypt_password(input_password, salt=hashed[:8]) if __name__==\"__main__\": hashed = encrypt_password('secret password') assert validate_password(hashed, 'secret password') print (hashed) print (base64.b64encode(hashed)) print (base64.b64decode(base64.b64encode(hashed))) Python3代码123456789101112131415161718192021222324252627282930313233343536import os, base64from hashlib import sha256from hmac import HMACdef encrypt_password(password, salt=None): \"\"\"Hash password on the fly.\"\"\" if salt is None: salt = os.urandom(8) # 64 bits. assert 8 == len(salt) assert isinstance(salt, bytes) assert isinstance(password, str) if isinstance(password, str): password = password.encode('UTF-8') assert isinstance(password, bytes) result = password for i in range(10): result = HMAC(result, salt, sha256).digest() return salt + resultdef validate_password(hashed, input_password): return hashed == encrypt_password(input_password, salt=hashed[:8])if __name__ == \"__main__\": hashed = encrypt_password('secret password') assert validate_password(hashed, 'secret password') print (hashed) print (base64.b64encode(hashed)) print (base64.b64decode(base64.b64encode(hashed))) Python编码问题一开始直接在Python3环境运行第一段代码的时候，总会报错NameError: global name &#39;unicode&#39; is not defined，百思不得其解。 查了资料，才发现是因为Python更新的时候，Python 3 renamed the unicode type to str, the old str type has been replaced by bytes。在Python升级文档内可以查到相关内容，也就是unicode直接改名str，str改名成bytes。Python2和Python3，在编码方面挖下太多的坑举个简单的例子：12isinstance(u'中文', unicode) #python2内是正确的isinstance(u'中文', str) #python3内是正确的 Python3内的unicode和bytesPython 3最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。 在将字符串存入磁盘和从磁盘读取字符串的过程中，Python 自动地帮你完成了编码和解码的工作，你不需要关心它的过程，例如你能把一个中文赋值给字符串。而使用 bytes 类型，实质上是告诉 Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式。 参考链接：http://zhuoqiang.me/password-storage-and-python-example.htmlhttp://www.ituring.com.cn/article/61192","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"密码处理","slug":"密码处理","permalink":"http://feiyang.li/tags/密码处理/"}]},{"title":"第1.8题：文本读取转化","slug":"python-camp8","date":"2017-02-15T14:07:40.000Z","updated":"2017-03-27T11:44:20.470Z","comments":true,"path":"2017/02/15/python-camp8/index.html","link":"","permalink":"http://feiyang.li/2017/02/15/python-camp8/index.html","excerpt":"题目来自：Python 练习册。题目1.8： 将纯文本文件 student.txt为学生信息,，写到 student.xls 文件内。","text":"题目来自：Python 练习册。题目1.8： 将纯文本文件 student.txt为学生信息,，写到 student.xls 文件内。 题目描述题目1.8： 纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示： { &quot;1&quot;:[&quot;张三&quot;,150,120,100], &quot;2&quot;:[&quot;李四&quot;,90,99,95], &quot;3&quot;:[&quot;王五&quot;,60,66,68] } 请将上述内容写到 student.xls 文件中，如下图所示： 这个题使用到文件读取，数据读取，Xls文件输出三部分内容。 文件读取使用open()函数12with open('student.txt') as f: content = f.read() 数据读取1d = json.loads(content) xls文件输出12345678file = xlwt.Workbook()# 添加sheettable = file.add_sheet('test')for row, i in enumerate(list(d)): table.write(row, 0, i) for col, j in enumerate(d[i]): table.write(row, col + 1, j)file.save('student.xls') 参考代码student.txt 可以在这里下载~ http://cdn.mmmxcc.cn/blog/student.txt 1234567891011121314151617181920212223#coding: utf-8import osimport jsonimport xlwt# 存放文件的目录filepath = 'D:'os.chdir(filepath)# 读取文件内容with open('student.txt') as f: content = f.read()# 转为jsond = json.loads(content)file = xlwt.Workbook()# 添加sheettable = file.add_sheet('test')for row, i in enumerate(list(d)): table.write(row, 0, i) for col, j in enumerate(d[i]): table.write(row, col + 1, j)file.save('student.xls')","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://feiyang.li/tags/自然语言处理/"}]},{"title":"第1.7题：Python敏感词检测","slug":"python-camp7","date":"2017-02-15T11:28:20.000Z","updated":"2017-03-27T11:44:17.551Z","comments":true,"path":"2017/02/15/python-camp7/index.html","link":"","permalink":"http://feiyang.li/2017/02/15/python-camp7/index.html","excerpt":"题目来自：Python 练习册。题目1.7：敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。","text":"题目来自：Python 练习册。题目1.7：敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。 Python find()方法描述Python find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。 语法find()方法语法：str.find(str, beg=0, end=len(string)) 参数str – 指定检索的字符串beg – 开始索引，默认为0。end – 结束索引，默认为字符串的长度。 返回值如果包含子字符串返回开始的索引值，否则返回-1。 实例以下实例展示了find()方法的实例：12345678info = 'abca'print info.find('a')##从下标0开始，查找在字符串里第一个出现的子串，返回结果：0info = 'abca'print info.find('a',1)##从下标1开始，查找在字符串里第一个出现的子串：返回结果3info = 'abca'print info.find('333')##返回-1,查找不到返回-1 Python strip()方法描述Python strip() 方法用于移除字符串头尾指定的字符（默认为空格）。 语法strip()方法语法：str.strip([chars]); 参数chars – 移除字符串头尾指定的字符。 返回值返回移除字符串头尾指定的字符生成的新字符串。 实例以下实例展示了strip()函数的使用方法：12str = \"0000000this is string example....wow!!!0000000\";print str.strip( '0' ); 以上实例输出结果如下：this is string example….wow!!! Python map()方法描述很简单，第一个参数接收一个函数名，第二个参数接收一个可迭代对象。 语法map(f, iterable)基本上等于：[f(x) for x in iterable] 实例123456&gt;&gt;&gt; def add100(x):... return x+100... &gt;&gt;&gt; hh = [11,22,33]&gt;&gt;&gt; map(add100,hh)[111, 122, 133] 参考代码filtered_words.txt将文件下载到D盘内即可1234567891011121314151617181920212223242526#coding: utf-8import cmd# 存放敏感词文件的路径filtered_words_filepath = 'd:/filtered_words.txt'class CLI(cmd.Cmd): def __init__(self): #初始基础类方法 cmd.Cmd.__init__(self) # 初始化，提取敏感词列表 self.intro = 'Python敏感词检测:' #输出欢迎信息 f = open(filtered_words_filepath) self.words = list(map(lambda i: i.strip('\\n'), f.readlines())) self.prompt = \"&gt;&gt;&gt; \" # 定义提示符 def default(self, line): if any([i in line for i in self.words]): print ('Freedom') else: print ('Human Rights') def do_quit(self, arg): exit() return Trueif __name__ ==\"__main__\": cli = CLI() cli.cmdloop() 其实这个地方出现过一个错误，map()形成的iterable是一次性的。 也就是如果不保存，直接迭代之后，self.words =map(lambda i: i.strip(&#39;\\n&#39;), f.readlines())self.words 里边的数据会丢失，因此这个地方加了一个list()函数，将iterable到处保存。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://feiyang.li/tags/自然语言处理/"}]},{"title":"Coursera ML(1)-机器学习基础概念","slug":"Coursera-ML","date":"2017-02-14T11:19:17.000Z","updated":"2017-03-27T11:41:09.516Z","comments":true,"path":"2017/02/14/Coursera-ML/index.html","link":"","permalink":"http://feiyang.li/2017/02/14/Coursera-ML/index.html","excerpt":"在学习的过程中，抓住基本概念是非常重要的，这样可以防止自己陷入某些细节中无法自拔，可以让自己站在比较宏观的层面上看待问题。 更多见：李飞阳","text":"在学习的过程中，抓住基本概念是非常重要的，这样可以防止自己陷入某些细节中无法自拔，可以让自己站在比较宏观的层面上看待问题。 更多见：李飞阳 机器学习（Machine Learning） Coursera上机器学习课程的介绍中，第一句话是： Machine learning is the science of getting computers to act without being explicitly programmed. 机器学习是让电脑自己学会如何处理问题，而不需要人们刻意的编程。 Andrew Ng老师的讲义中（Coursera）给出的定义：Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”Example: playing checkers. · E = the experience of playing many games of checkers · T = the task of playing checkers. · P = the probability that the program will win the next game. 周志华的《机器学习》中定义：机器学习正是这样一门学科，它致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。在计算机系统中，“经验”通常以“数据”的形式存在，因此，机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”（model）的算法，即“学习算法”（learning algorithm）。有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时，模型会给我们提供相应的判断。 有监督学习（Supervised Learning） 维基百科Supervised learning is the machine learningtask of inferring a function from labeled training data.The training data consist of a set of training examples. In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a “reasonable” way. Example: Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem. We could turn this example into a classification problem by instead making our output about whether the house “sells for more or less than the asking price.” Here we are classifying the houses based on price into two discrete categories 无监督学习（Unsupervised Learning）维基百科： Unsupervised learning is the machine learning task of inferring a function to describe hidden structure from unlabeled data. Since the examples given to the learner are unlabeled, there is no error or reward signal to evaluate a potential solution. This distinguishes unsupervised learning from supervised learning and reinforcement learning. Unsupervised learning is closely related to the problem of density estimation in statistics.[1] However unsupervised learning also encompasses many other techniques that seek to summarize and explain key features of the data. Many methods employed in unsupervised learning are based on data mining methods used to preprocess data. Example: Clustering: Take a collection of 1000 essays written on the US Economy, and find a way to automatically group these essays into a small number that are somehow similar or related by different variables, such as word frequency, sentence length, page count, and so on. Associative: Suppose a doctor over years of experience forms associations in his mind between patient characteristics and illnesses that they have. If a new patient shows up then based on this patient’s characteristics such as symptoms, family medical history, physical attributes, mental outlook, etc the doctor associates possible illness or illnesses based on what the doctor has seen before with similar patients. This is not the same as rule based reasoning as in expert systems. In this case we would like to estimate a mapping function from patient characteristics into illnesses. 解释一下： 首先看什么是学习（learning）？一个成语就可概括：举一反三。此处以高考为例，高考的题目在上考场前我们未必做过，但在高中三年我们做过很多很多题目，懂解题方法，因此考场上面对陌生问题也可以算出答案。机器学习的思路也类似：我们能不能利用一些训练数据（已经做过的题），使机器能够利用它们（解题方法）分析未知数据（高考的题目）？ 最简单也最普遍的一类机器学习算法就是分类（classification）。对于分类，输入的训练数据有特征（feature），有标签（label）。所谓的学习，其本质就是找到特征和标签间的关系（mapping）。这样当有特征而无标签的未知数据输入时，我们就可以通过已有的关系得到未知数据标签。 在上述的分类过程中，如果所有训练数据都有标签，则为有监督学习（supervised learning）。如果数据没有标签，显然就是无监督学习（unsupervised learning）了，也即聚类（clustering）。 目前分类算法的效果还是不错的，但相对来讲，聚类算法就有些惨不忍睹了。确实，无监督学习本身的特点使其难以得到如分类一样近乎完美的结果。这也正如我们在高中做题，答案（标签）是非常重要的，假设两个完全相同的人进入高中，一个正常学习，另一人做的所有题目都没有答案，那么想必第一个人高考会发挥更好，第二个人会发疯。 这时各位可能要问，既然分类如此之好，聚类如此之不靠谱，那为何我们还可以容忍聚类的存在？因为在实际应用中，标签的获取常常需要极大的人工工作量，有时甚至非常困难。例如在自然语言处理（NLP）中，Penn Chinese Treebank在2年里只完成了4000句话的标签…… 这时有人可能会想，难道有监督学习和无监督学习就是非黑即白的关系吗？有没有灰呢？Good idea。灰是存在的。二者的中间带就是半监督学习（semi-supervised learning）。对于半监督学习，其训练数据的一部分是有标签的，另一部分没有标签，而没标签数据的数量常常极大于有标签数据数量（这也是符合现实情况的）。隐藏在半监督学习下的基本规律在于：数据的分布必然不是完全随机的，通过一些有标签数据的局部特征，以及更多没标签数据的整体分布，就可以得到可以接受甚至是非常好的分类结果。（此处大量忽略细节） 因此，learning家族的整体构造是这样的：有监督学习（分类，回归）↕半监督学习（分类，回归），transductive learning（分类，回归）↕半监督聚类（有标签数据的标签不是确定的，类似于：肯定不是xxx，很可能是yyy）↕无监督学习（聚类） 总结在Coursera上Andrew Ng的课程中，主要涉及： Supervised Learning，包括Linear Regression、Logistic Regression、Neural Networks、Support Vector Machines； Unsupervised Learning，包括Clustering、Dimensionality Reduction、Anomaly Detection、Recommender Systems。 参考资料Coursera - Machine learning( Andrew Ng) https://www.coursera.org/learn/machine-learning什么是无监督学习？ https://www.zhihu.com/question/23194489","categories":[{"name":"Coursera ML","slug":"Coursera-ML","permalink":"http://feiyang.li/categories/Coursera-ML/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://feiyang.li/tags/Machine-Learning/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"}]},{"title":"《结网》","slug":"jiewang","date":"2017-02-13T13:39:16.000Z","updated":"2017-03-11T07:07:30.991Z","comments":true,"path":"2017/02/13/jiewang/index.html","link":"","permalink":"http://feiyang.li/2017/02/13/jiewang/index.html","excerpt":"对于产品经理来说，自己所负责的产品的表现就是自己的履历。","text":"对于产品经理来说，自己所负责的产品的表现就是自己的履历。 入坑说来惭愧，最初进入产品经理这个职位，是因为大二在OPPO的实习。当时实习的时候，认识了许和高，许 瘦瘦高高的风格很让人喜欢。当时应该算产品助理，但是不知道自己具体该做什么。 最开始只是单纯的觉得HR纪姐姐真的好漂亮，如果不能进去实习，岂不后悔莫及。 进入OPPO，很多时间是跟费费和飞哥玩，认识了女神。我们玩得时候，女神总默默的拿出自己的小Iphone用百词斩背单词。 有一次做展示的时候，和高 有吵，记得争论是OPPO论坛的改版问题。 我第一次对产品岗心生退意 更深大三暑假，走上了考研路，想想这一辈子应该也没有这样一次机会，这么长时间的去做一件事情。可以与喜欢的女孩，朝夕相处。 那时最大的梦想就是一起去吃 老五烧烤 去年的这个时间，知道自己成绩后一脸懵逼。没有多想，立刻动身找工作。 当时有很多互联网公司在春招，因为 高 的推荐，拿到了搜狐的offer。之后又拿到了360的offer，都是做产品经理。选择了数字公司，做线上商城业务。 期间发现自己可以调剂，碾转奔波的面试，终于可以继续在象牙塔读书。 在360的时候，跟卢老师系统的学习了一些产品方面的知识，后来又和涛哥共事了很久。慢慢的掌握了一些产品经理的技能，比如不要重复发明轮子。现有的组件可以用上的，就尽量不要重复开发，提高共用性，需求的快速化迭代。如何将已有的功能，逻辑性的展示出来。 之后，自己接手360全球好药的产品工作。看着薛姐、静姐、俊哥哥、欣欣，他们付出那么多心血，真心希望这个项目可以成功。页面还是我画的那个样子，好熟悉，时间过得真快。 一开始，这个项目跟我对接业务的是金，金 是武大生物学硕士。真是条条大道通CS，后来金跳槽去了杭州。之后跟我对接的是超哥，超哥又跳槽去了拼少少。我都有点怀疑自己了…… 上次跟超超聊，又升值加薪了，就差一个白富美。 期间发生了一些事，再加上我本身不喜与人当面争执，又一次对产品岗位心生退意 后记现在虽然已经远离产品经理这个角色，但是给我留下很多习惯。比如对一些细节会较真，会对一些人或事看的比较淡。 当初计划大四面试前看，但是那时图书馆没这本书。 谁知今天正好遇见它，也许是缘分吧。读了一些，做此感想。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"PM","slug":"PM","permalink":"http://feiyang.li/tags/PM/"}]},{"title":"第1.6题：使用Python生成字母验证码图片","slug":"python-camp6","date":"2017-02-13T05:36:02.000Z","updated":"2017-03-27T11:44:24.442Z","comments":true,"path":"2017/02/13/python-camp6/index.html","link":"","permalink":"http://feiyang.li/2017/02/13/python-camp6/index.html","excerpt":"题目来自：Python 练习册。题目1.6：使用 Python 生成类似于下图中的字母验证码图片查看更多于本人博客：李飞阳","text":"题目来自：Python 练习册。题目1.6：使用 Python 生成类似于下图中的字母验证码图片查看更多于本人博客：李飞阳 参考代码我们用随机颜色填充背景，再画上文字，最后对图像进行模糊，得到验证码图片如下：12345678910111213141516171819202122232425262728293031323334353637383940from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random# 随机字母:def rndChar(): return chr(random.randint(65, 90))# 随机颜色1:def rndColor(): return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))# 随机颜色2:def rndColor2(): return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))def compose(): # 240 x 60: width = 240 height = 60 image = Image.new('RGB', (width, height), (255, 255, 255)) # 创建Font对象: font = ImageFont.truetype('C:/windows/fonts/Arial.ttf', 36) # 创建Draw对象: draw = ImageDraw.Draw(image) # 填充每个像素: for x in range(width): for y in range(height): draw.point((x, y), fill=rndColor()) # 输出文字: letter = [] for t in range(4): letter.append(rndChar()) draw.text((60 * t + 10, 10), letter[t], font=font, fill=rndColor2()) # 模糊: image.save('code.jpg', 'jpeg') image = image.filter(ImageFilter.BLUR) image.save('filter.jpg', 'jpeg') print (letter)compose() 输出验证码原本数字：模糊前： image = image.filter(ImageFilter.BLUR) # 模糊:模糊后： 如果运行的时候报错：IOError: cannot open resource 这是因为PIL无法定位到字体文件的位置，可以根据操作系统提供绝对路径，比如：&#39;/Library/Fonts/Arial.ttf&#39; 要详细了解PIL的强大功能，请请参考Pillow官方文档：https://pillow.readthedocs.io/en/4.0.x/ 小结PIL提供了操作图像的强大功能，可以通过简单的代码完成复杂的图像处理。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"图片处理","slug":"图片处理","permalink":"http://feiyang.li/tags/图片处理/"}]},{"title":"第1.5题：使用Python处理图片","slug":"python-camp5","date":"2017-02-13T02:33:53.000Z","updated":"2017-03-27T11:44:28.359Z","comments":true,"path":"2017/02/13/python-camp5/index.html","link":"","permalink":"http://feiyang.li/2017/02/13/python-camp5/index.html","excerpt":"题目来自：Python 练习册。题目1.5：你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。查看更多于本人博客：李飞阳","text":"题目来自：Python 练习册。题目1.5：你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。查看更多于本人博客：李飞阳 使用python来处理图片是非常方便的，下面提供一小段python处理图片的代码，需要安装图像处理工具包PIL(Python Image Library)。 安装PIL我用的是anaconda(一个开源的Python发行版本，包含了常用的数据科学库。)，其中自带了PIL和Pillow，但是不能用，真是(ಥ _ ಥ) 。检查自己电脑是否支持PIL，可以在Python shell 页面输入：1from PIL import Image 如果没有报错的话，就可以代表正常。如果报错说[importError: No module named images]，使用pip卸载pillow，重新安装应该就可以了. 参考代码稍微注意一下，图片的宽高是两个数字，不能理所当然的认为图片都是宽大于高的。12345678910111213141516171819202122232425262728import os from PIL import Image pathDir='F:\\CloudMusic' os.chdir(pathDir) def get_imglist(): #获取照片名称list img_list=[] list_dir=os.listdir(pathDir) for x in list_dir: if '.jpg' in x: img_list.append(x) else: print(\"This is not a picture: \"+x) return img_list def modify_imgsize(): for filename in get_imglist(): img=Image.open(filename) if max(img.size)&gt;1136: value=max(img.size)/1136.0 newsize =(int(img.size[0]/value),int(img.size[1]/value)) newimg = img.resize(newsize,Image.ANTIALIAS) #修改大小 newimg.save('new_'+filename) else: print(\"This picture is availabe:\"+filename) if __name__ == '__main__': modify_imgsize()","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"},{"name":"图片处理","slug":"图片处理","permalink":"http://feiyang.li/tags/图片处理/"}]},{"title":"第1.4题：统计文件中单词出现个数","slug":"python_camp4","date":"2017-02-11T12:16:52.000Z","updated":"2017-03-27T11:43:09.407Z","comments":true,"path":"2017/02/11/python_camp4/index.html","link":"","permalink":"http://feiyang.li/2017/02/11/python_camp4/index.html","excerpt":"题目来自：Python 练习册。今天做第四题：任一英文的纯文本文件，统计其中的单词出现个数。","text":"题目来自：Python 练习册。今天做第四题：任一英文的纯文本文件，统计其中的单词出现个数。 铺垫工作这一期的铺垫工作比较多，所以单独写了一篇文章，详见 Python正则表达式 正文部分题目内容任一个英文的纯文本文件，统计其中的单词出现的个数。参考英文：12345678910111213141516171819202122232425262728If you are looking for someone you can pour out your love to, let me suggest the empowered woman. The empowered woman knows what she wants, knows how to get it, knows how to live fully, and she knows how to love you back without needing anyone’s approval or recognition. An empowered woman is unarguably one of the most magnificent beings you will ever come in contact with. Read on and find 10 reason why you should absolutely love and embrace the empowered women in your life! . 1. She knows how to love you in returnIt is difficult to give what you don’t have. It is impossible to love someone and feel fulfilled when they can’t love you in return because they don’t love themselves. This will never happen to you when you love an empowered woman. She loves herself (not in a narcissistic manner). In turn, she appreciates who you are and loves you in return. She will love you just like you deserve to be loved. 2. She will inspire youWhen life puts you down and you are at the end of your rope, the empowered woman will be there to see you through. Her drive, enthusiasm and (at times) hopeless optimism will inspire you to carry on despite the obstacles you face. 3. She is not afraid of failureWhile many out there are thoroughly terrified of failure, the empowered woman understands that failures are simply stepping stones in life. How can you not love someone that is thoroughly unafraid to try, fail, and give it a shot all over again?! 4. She is all about the legacyWhile most people are focused on the car, the house, the job, and corner office; the empowered woman is focused on leaving a legacy that will inspire others and change the world. The empowered woman is focused on empowering others to maximize their potential and fulfill their purpose. She is all about inspiring others to look beyond themselves and live a life of service to others. 5. She can laugh at her mistakes……and learn from them as well! She understands mistakes are part of the journey. The empowered woman can laugh and learn from her mistakes to ensure they never happen again. 6. She can be vulnerableThe empowered woman understands there is no debt in relationships without vulnerability. Although she is emotionally strong, she is willing to laugh and cry with you because all of these emotions are an essential part of life. 7. She can speak her mindWhile everyone else is too concerned with what others may think or say, the empowered woman is not afraid to speak her mind. She understands that her value comes from within, not from what others say or think about her. 8. She knows when to remain quietShe lives by Abe Lincoln’s words, “Better to remain silent and be thought a fool, than to speak out and remove all doubt.” 9. She knows how to have funWhether it is at the symphony or at a ball game, the empowered woman understands life is made up of experiences with people – not the places you go. She is able to live in the moment and enjoy it fully without being concerned for the future. After all, who’s got a guaranteed future? 10. She is not afraid of changeWhile most people rather continue on living unfulfilled lives as long as their comfort zone remains intact, the empowered woman is all about embracing change. She understands growth cannot happen without change. She understands that change is the gift life offers you to choose your destiny. Therefore, she is not afraid of change because it is her stepping stone towards success. 下载链接将文件下载到python的工作路径里去，如果不知道哪里是工作路径，输入123456import os#获取当前工作目录os.getcwd()#更改当前工作目录os.chdir('d:\\')os.getcwd() 参考代码每一步我都尽量附带上了解释123456789101112131415161718192021222324252627# coding=utf-8from collections import defaultdictimport re# 替换除了n't这类连字符外的所有非单词字符和数字字符def replace(s): if s.group(1) == 'n\\'t': return s.group(1) return ' 'def cal(filename='203305485.txt'): # 使用lambda来定义简单的函数 dic = defaultdict(lambda: 0)#dic = defaultdict(int)也可以 with open(filename, 'r') as f: data = f.read() # 全部变为小写字母 data = data.lower() # 替换除了n't这类连字符外的所有非单词字符和数字字符 data = re.sub(r'(n[\\']t)|([\\W\\d])', replace, data) datalist = re.split(r'[\\s\\n]+', data) for item in datalist: dic[item] += 1 del dic[''] return dicif __name__ == '__main__': dic = cal() for key, val in dic.items(): print('%15s ----&gt; %3s' % (key,val)) 运行结果如下： 增加排序函数代码有参考 《利用python进行数据分析》12345def top_counts(dic, n=10): value_key_pairs = [(count, tz) for tz, count in dic.items()] value_key_pairs.sort() return value_key_pairs[-n:]top_counts(dic) 运行结果如下：可以看出，人们最喜欢用的词是定冠词the，下来是介词to……. 补充最近发现collections模块的Counter类 ，导入语句是：from collections import Counter，作用是：定义一个list数组，求数组中每个元素出现的次数修改之后代码量要少很多，而且可以直接排列好顺序~12345678910111213141516# coding=utf-8import refrom collections import Counterdef cal(filename='203305485.txt'): with open(filename, 'r') as f: data = f.read() data = data.lower() # 替换除了n't这类连字符外的所有非单词字符和数字字符 datalist = re.split(r'[\\s\\n]+', data) return Counter(datalist).most_common() if __name__ == '__main__': dic = cal() for i in range(len(dic)): print('%15s ----&gt; %3s' % (dic[i][0],dic[i][1])) 代码看起来行云流水，舒服多了。当然结论是一样的，人们还是比较喜欢说 the , you~ 以上~","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"Python正则表达式","slug":"Python_lambda","date":"2017-02-10T14:18:55.000Z","updated":"2017-03-27T11:44:32.213Z","comments":true,"path":"2017/02/10/Python_lambda/index.html","link":"","permalink":"http://feiyang.li/2017/02/10/Python_lambda/index.html","excerpt":"使用正则表达式，会使得字符串的处理很方便。","text":"使用正则表达式，会使得字符串的处理很方便。 正则表达式基础常用语法Python中经常要对字符串进行处理，处理用户的输入，对文本的编辑等等。使用正则表达式，会使得字符串的处理很方便。 数量词的贪婪模式与非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。 Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。 例如：正则表达式”ab“如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab?”，将找到”a”。 re模块开始使用rePython通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。 12345678910111213# encoding: UTF-8import redef test(): # 将正则表达式编译成Pattern对象 pattern1 = re.compile(r'hello') # 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None return pattern1.match('hello world!') if test(): # 使用Match获得分组信息 print (\"match\")else: print (\"not match\") re.compile(strPattern[, flag]):这个方法用于将字符串形式的正则表达式编译为Pattern对象， 第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。可选值有： re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同） M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图） S(DOTALL): 点任意匹配模式，改变’.’的行为 L(LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 U(UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：1234a = re.compile(r\"\"\"\\d + # the integral part \\. # the decimal point \\d * # some fractional digits\"\"\", re.X)b = re.compile(r\"\\d+\\.\\d*\") re提供了众多模块方法用于完成正则表达式的功能。这些方法可以使用Pattern实例的相应方法替代，唯一的好处是少写一行re.compile()代码，但同时也无法复用编译后的Pattern对象。12m = re.match(r'hello', 'hello world!')print m.group() re模块还提供了一个方法escape(string)，用于将string中的正则表达式元字符如*/+/?等之前加上转义符再返回，在需要大量匹配元字符时有那么一点用。 MatchMatch对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。 属性： string: 匹配时使用的文本。 re: 匹配时使用的Pattern对象。 pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。 lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。 方法： group([group1, …]):获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 groups([default]): 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 groupdict([default]): 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。 start([group]): 返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。 end([group]): 返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。 span([group]): 返回(start(group), end(group))。 expand(template): 将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。 1234567891011121314151617import rem = re.match(r'(\\w+) (\\w+)(?P&lt;sign&gt;.*)', 'hello world!') print (\"m.string:\", m.string)print (\"m.re:\", m.re)print (\"m.pos:\", m.pos)print (\"m.endpos:\", m.endpos)print (\"m.lastindex:\", m.lastindex)print (\"m.lastgroup:\", m.lastgroup) print (\"m.group(1,2):\", m.group(1, 2))print (\"m.groups():\", m.groups())print (\"m.groupdict():\", m.groupdict())print (\"m.start(2):\", m.start(2))print (\"m.end(2):\", m.end(2))print (\"m.span(2):\", m.span(2))print (r\"m.expand(r'\\2 \\1\\3'):\", m.expand(r'\\2 \\1\\3')) 输出内容如下：12345678910111213m.string: hello world!m.re: re.compile(&apos;(\\\\w+) (\\\\w+)(?P&lt;sign&gt;.*)&apos;)m.pos: 0m.endpos: 12m.lastindex: 3m.lastgroup: signm.group(1,2): (&apos;hello&apos;, &apos;world&apos;)m.groups(): (&apos;hello&apos;, &apos;world&apos;, &apos;!&apos;)m.groupdict(): &#123;&apos;sign&apos;: &apos;!&apos;&#125;m.start(2): 6m.end(2): 11m.span(2): (6, 11)m.expand(r&apos;\\2 \\1\\3&apos;): world hello! PatternPattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。 Pattern不能直接实例化，必须使用re.compile()进行构造。 Pattern提供了几个可读属性用于获取表达式的相关信息： pattern: 编译时用的表达式字符串。 flags: 编译时用的匹配模式。数字形式。 groups: 表达式中分组的数量。 groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。 12345678910111213import rep = re.compile(r'(\\w+) (\\w+)(?P&lt;sign&gt;.*)', re.DOTALL) print (\"p.pattern:\", p.pattern)print (\"p.flags:\", p.flags)print (\"p.groups:\", p.groups)print (\"p.groupindex:\", p.groupindex) ### output #### p.pattern: (\\w+) (\\w+)(?P&lt;sign&gt;.*)# p.flags: 16# p.groups: 3# p.groupindex: &#123;'sign': 3&#125; 实例方法[ | re模块方法]： match(string[, pos[, endpos]]) | re.match(pattern, string[, flags]): 这个方法将从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’。 search(string[, pos[, endpos]]) | re.search(pattern, string[, flags]): 这个方法用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。 12345678910111213141516# encoding: UTF-8 import re # 将正则表达式编译成Pattern对象 pattern = re.compile(r'world') # 使用search()查找匹配的子串，不存在能匹配的子串时将返回None # 这个例子中使用match()无法成功匹配 match = pattern.search('hello world!') if match: # 使用Match获得分组信息 print (match.group() ) ### 输出 ### # world split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]): 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 1234567import re p = re.compile(r'\\d+')print (p.split('one1two2three3four4')) ### output #### ['one', 'two', 'three', 'four', ''] findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags]): 搜索string，以列表形式返回全部能匹配的子串。 1234567import re p = re.compile(r'\\d+')print (p.findall('one1two2three3four4')) ### output #### ['1', '2', '3', '4'] finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags]): 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。 12345678import re p = re.compile(r'\\d+')for m in p.finditer('one1two2three3four4'): print m.group(), ### output #### 1 2 3 4 sub(repl, string[, count]) | re.sub(pattern, repl, string[, count]): 使用repl替换string中每一个匹配的子串后返回替换后的字符串。当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。 123456789101112131415import re p = re.compile(r'(\\w+) (\\w+)')s = 'i say, hello world!' print p.sub(r'\\2 \\1', s) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print p.sub(func, s) ### output #### say i, world hello!# I Say, Hello World! subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]): 返回 (sub(repl, string[, count]), 替换次数)。 123456789101112131415import re p = re.compile(r'(\\w+) (\\w+)')s = 'i say, hello world!' print p.subn(r'\\2 \\1', s) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print p.subn(func, s) ### output #### ('say i, world hello!', 2)# ('I Say, Hello World!', 2) 以上就是Python对于正则表达式的支持。熟练掌握正则表达式是每一个程序员必须具备的技能。笔者也是看的迷迷糊糊，文章来自cnblog，原版博客基于Python2.4完成，年代有点久，我稍微修改了一下代码。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python-camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"第1.3题：将  200 个激活码保存到 MySQL","slug":"python_camp3","date":"2017-02-10T07:16:52.000Z","updated":"2017-03-27T11:43:22.581Z","comments":true,"path":"2017/02/10/python_camp3/index.html","link":"","permalink":"http://feiyang.li/2017/02/10/python_camp3/index.html","excerpt":"题目来自：Python 练习册，今天做的是第三题，使用 Python 将激活码保存到 MySQL。","text":"题目来自：Python 练习册，今天做的是第三题，使用 Python 将激活码保存到 MySQL。 准备姿势安装Mysql如果是windows 用户，mysql 的安装非常简单，直接下载安装文件，双击安装文件一步一步进行操作即可。 Linux 下的安装可能会更加简单，除了下载安装包进行安装外，一般的linux 仓库中都会有mysql ，我们只需要通过一个命令就可以下载安装： Ubuntu\\deepin12sudo apt-get install mysql-server sudo apt-get install mysql-client centOS/redhat1yum install mysql 安装MySQL-python要想使python可以操作mysql 就需要MySQL-python驱动，它是python 操作mysql必不可少的模块。 下载地址：https://pypi.python.org/pypi/MySQL-python/ 下载MySQL-python-1.2.5.zip 文件之后直接解压。进入MySQL-python-1.2.5目录: 1python setup.py install 可能会提示缺少“error: Microsoft Visual C++ 9.0 is required (Unable to find vcvarsall.bat). Get it from http://aka.ms/vcpython27”这个地方查找了很多资料，有的说要修改注册表，有的说要改VS2015的配置。简直一派胡言，I am angry。直接按照要求，在这个http://aka.ms/vcpython27下载安装就可以了。 测试输入1import MySQLdb 或者1import mysql 如果不报错，那么就安装成功了。 mysql 的基本操作 启动mysql 1mysql -u root -p 查看当前所有的数据库 1show databases; 新建数据库表 1create database if not exists test; 使用某表 1use test; 添加数据 1insert into user values(&apos;Alen&apos;,&apos;7875&apos;); 查看数据 1select * from student 删除数据 1delete from user where name = &apos;Jack&apos;; 删除table 1drop table if exists student 删除database 1drop database if exists test mysql卡死怎么办查看目前连接情况： 1show processlist; 发现多个线程数据处理间出现了死锁，也没什么好的办法，kill掉就可以了。1kill 65; 然后就可以继续使用了。python 操作mysql基本语法 建立数据库连接注意，这个地方的test表要存在，否则无法连接123456789import MySQLdbconn=MySQLdb.connect( host='localhost', port = 3306, #默认3306端口，不写也可以 user='root', passwd='123456', db ='test',)cur = conn.cursor() cursor 是游标, 通过获取到的数据库连接conn下的cursor()方法来创建游标。其中，第二行代码可以缩写为：1connect(&apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;test&apos;) 创建数据表 12cur.execute(&quot;create table student(id int ,name varchar(20),class varchar(30),age varchar(10))&quot;) #通过游标cur 操作execute()方法可以写入纯sql语句。通过execute()方法中写如sql语句来对数据进行操作。 插入一条数据 1cur.execute(&quot;insert into student values(&apos;2&apos;,&apos;Tom&apos;,&apos;3 year 2 class&apos;,&apos;9&apos;)&quot;) 修改查询条件的数据 1cur.execute(&quot;update student set class=&apos;3 year 1 class&apos; where name = &apos;Tom&apos;&quot;) 删除查询条件的数据 1cur.execute(&quot;delete from student where age=&apos;9&apos;&quot;) 关闭游标 1cur.close() 提交数据向数据库插入一条数据时必须要有这个方法，否则数据不会被真正的插入。 1conn.commit() 关闭数据库连接 1conn.close() 打印表中所有数据1234567891011121314151617181920212223#coding=utf-8import MySQLdbconn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='123456', db ='test', )cur = conn.cursor()#获得表中有多少条数据aa=cur.execute(\"select * from student\")print aa#打印表中的多少数据info = cur.fetchmany(aa)for ii in info: print iicur.close()conn.commit()conn.close() 插入数据1234567891011121314151617181920212223#coding=utf-8import MySQLdbconn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='123456', db ='test', )cur = conn.cursor()#一次插入多条记录sqli=\"insert into student values(%s,%s,%s,%s)\"cur.executemany(sqli,[ ('3','Tom','1 year 1 class','6'), ('3','Jack','2 year 1 class','7'), ('3','Yaheng','2 year 2 class','7'), ])cur.close()conn.commit()conn.close() 以上两段代码参考 虫师的博客 正式代码经过以上铺垫之后，就可以写出满足要求的代码了。 12345678910111213141516171819202122232425262728293031323334353637from uuid import uuid4import MySQLdb,random, stringchars = string.digits + string.lettersdef uuidkey(num):# 使用uuid方法得到随机值 id_list = [str(uuid4()) for i in range(num)] return id_listdef randomkey(num):# 使用random随机取数据值 id_list = [\"\".join(random.sample(chars, 20)) for i in range(num)] return id_list def create_table_put_keys(id_list,table):#将获得的随机值存入mysql conn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='lyyc12345', db ='test', ) cur = conn.cursor() cur.execute(\"drop table if exists %s\" % table) #若存在table表则删除 cur.execute(\"create table %s(id int, coupon char(40))\" % table) #创建数据表 temp = 1 for i in id_list: #将id_list里边的数据插入到mysql中 cur.execute(\"insert into %s values('%d','%s')\" %(table,temp,i)) temp=temp+1 cur.close() #关闭游标 conn.commit() #提交数据 conn.close() #关闭数据库连接def main(): create_table_put_keys(uuidkey(200),'uuidtable') create_table_put_keys(randomkey(200),'randomtable')if __name__ == '__main__': main() 总结 python 中 % 的使用：cur.execute(&quot;insert into %s values(&#39;%d&#39;,&#39;%s&#39;)&quot; %(table,temp,i))，前后两部分用%相隔 提交数据conn.commit()，否则数据将不会保存。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"frp内网穿透","slug":"frp","date":"2017-02-09T02:56:15.000Z","updated":"2017-02-11T13:20:27.500Z","comments":true,"path":"2017/02/09/frp/index.html","link":"","permalink":"http://feiyang.li/2017/02/09/frp/index.html","excerpt":"我之前写过一篇文章是用Ngrok方式进行内网穿透，该方法需要借助到别人的服务器，非常麻烦。后来发现了Frp这个神器，只需要有一台公网的主机，就可以进行端口穿透，同时还可以转发tcp，udp，dns查询。","text":"我之前写过一篇文章是用Ngrok方式进行内网穿透，该方法需要借助到别人的服务器，非常麻烦。后来发现了Frp这个神器，只需要有一台公网的主机，就可以进行端口穿透，同时还可以转发tcp，udp，dns查询。 这里仅使用的到最简单的端口映射，需要一台有公网的vps，以及一台本地主机。 ssh登录公网vps下载frp安装包这里下载的是64位安装包wget http://home.ustc.edu.cn/~mmmwhy/frp/frp_0.9.3_linux_amd64.tar.gz如果你的系统版本是32位，那么建议使用如下命令：(如果不知道自己系统版本的，也用这个)wget http://home.ustc.edu.cn/~mmmwhy/frp/frp_0.9.3_linux_386.tar.gz 解压安装包tar -xzvf frp_0.9.3_linux_386.tar.gz 修改 frps.ini 文件，配置一个名为 ssh 的反向代理：cd frp_0.9.3_linux_386/ &amp;&amp; vi frps.ini1234567# frps.ini[common]bind_port = 7000[ssh]listen_port = 6000auth_token = 123 [ssh]后边写vps自己的端口。 启动 frps：./frps -c ./frps.ini 登录无公网主机下载frp安装包与 解压安装包，与上部相同，在此不赘述。 修改 frpc.ini 文件，配置一个名为 ssh 的反向代理：cd frp_0.9.3_linux_386/ &amp;&amp; vi frpc.ini如果希望转发到本地8888端口12345678[common]server_addr = 115.159.102.118server_port = 7000auth_token = 123[ssh]local_ip = 127.0.0.1local_port = 8888 启动 frpc：./frpc -c ./frpc.ini","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"},{"name":"frp","slug":"frp","permalink":"http://feiyang.li/tags/frp/"}]},{"title":"第1.2题：使用 Python 如何生成 200 个激活码","slug":"python_camp2","date":"2017-02-07T11:50:11.000Z","updated":"2017-03-27T11:43:20.920Z","comments":true,"path":"2017/02/07/python_camp2/index.html","link":"","permalink":"http://feiyang.li/2017/02/07/python_camp2/index.html","excerpt":"题目来自：Python 练习册，今天做的是第二题，使用 Python 如何生成 200 个激活码。","text":"题目来自：Python 练习册，今天做的是第二题，使用 Python 如何生成 200 个激活码。 random模块介绍我们可以使用python中的random模块，用于生成随机浮点数、整数、字符串，甚至帮助你随机选择列表序列中的一个元素，打乱一组数据等。 random模块五个函数 random() 返回0&lt;=n&lt;1之间的随机实数n； choice(seq) 从序列seq中返回随机的元素； getrandbits(n) 以长整型形式返回n个随机位； shuffle(seq[, random]) 原地指定seq序列； sample(seq, n) 从序列seq中选择n个随机且独立的元素； random模块方法说明 random.random()函数是这个模块中最常用的方法了，它会生成一个随机的浮点数，范围是在0.0~1.0之间。 random.uniform()正好弥补了上面函数的不足，它可以设定浮点数的范围，一个是上限，一个是下限。 random.randint()随机生一个整数int类型，可以指定这个整数的范围，同样有上限和下限值，python random.randint。 random.choice()可以从任何序列，比如list列表中，选取一个随机的元素返回，可以用于字符串、列表、元组等。 random.shuffle()如果你想将一个序列中的元素，随机打乱的话可以用这个函数方法。 random.sample()可以从指定的序列中，随机的截取指定长度的片断，不作原地修改。 使用random直接随机抽取从26个大小字母+10个数字，随机选取10个数字，组成一组激活码。重复此过程200次即可。 设定字符串内容123import random, stringchars = string.letters + string.digitsprint chars 输出内容为：abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 从给定内容中随机选取使用random.choice()和random.sample()两个函数123s= \"\".join(random.choice(chars) for i in range(10))gene = \"\".join(random.sample(chars, 10))print s +\" /////// \" + gene 其中s与gene分别可以获得两个随机序列，从这里我们可以看出两个函数使用上的差异，相对来说，random.sample()简单一些。 使用UUIDUUID是128位的全局唯一标识符，通常由32字节的字符串表示。 它可以保证时间和空间的唯一性，也称为GUID，全称为：Universally Unique IDentifie。 UUID的五种实现方法 uuid1()——基于时间戳由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。 uuid2()——基于分布式计算环境DCE（Python中没有这个函数）算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID，实际中很少用到该方法。 uuid3()——基于名字的MD5散列值通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。 uuid4()——基于随机数由伪随机数得到，有一定的重复概率，该概率可以计算出来。 uuid5()——基于名字的SHA-1散列值算法与uuid3相同，不同的是使用 Secure Hash Algorithm 1 算法使用UUID生成激活码123import uuidfor i in range(20): print uuid.uuid1() 输出：ebb4911e-ed1e-11e6-82ec-708bcda57790 ebb4b82e-ed1e-11e6-9f24-708bcda57790 ebb4b82f-ed1e-11e6-9d5c-708bcda57790 ebb4b830-ed1e-11e6-9f8b-708bcda57790 ebb4b831-ed1e-11e6-89d4-708bcda57790 ebb4b832-ed1e-11e6-903a-708bcda57790 ebb4b833-ed1e-11e6-9038-708bcda57790 ebb4b834-ed1e-11e6-b1dc-708bcda57790 ebb4b835-ed1e-11e6-8fb8-708bcda57790 ebb4b836-ed1e-11e6-a399-708bcda57790 ebb4b837-ed1e-11e6-a9a0-708bcda57790 ebb4b838-ed1e-11e6-8f85-708bcda57790 ebb4b839-ed1e-11e6-9ac2-708bcda57790 ebb4b83a-ed1e-11e6-8f48-708bcda57790 ebb4b83b-ed1e-11e6-b6d8-708bcda57790 ebb4b83c-ed1e-11e6-9bde-708bcda57790 ebb4b83d-ed1e-11e6-b03f-708bcda57790 ebb4b83e-ed1e-11e6-ac70-708bcda57790 ebb4b83f-ed1e-11e6-baf1-708bcda57790 ebb4b840-ed1e-11e6-a694-708bcda57790 写入文件代码示例12345678910111213141516import randomimport stringFIELD = string.digits + string.lettersdef generate(n, many=1, where=None): def getCode(n): return \"\".join(random.sample(FIELD, n)) gene = [getCode(n) for i in range(many)] return genedef writeIn(n, many, where): count = 1 for i in generate(n, many): with open(where, \"a\") as boom: boom.write(str(count).rjust(3)+\" \"+i+\"\\n\") count += 1if __name__ == '__main__': writeIn(20, 200, \"coupon.txt\") 以上","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"Github Pages + CDN全站加速","slug":"Github-Pages-CDN","date":"2017-02-07T05:38:38.000Z","updated":"2017-02-11T13:20:33.275Z","comments":true,"path":"2017/02/07/Github-Pages-CDN/index.html","link":"","permalink":"http://feiyang.li/2017/02/07/Github-Pages-CDN/index.html","excerpt":"常见的Pages服务有 Coding Pages和Github Pages，因为众所周知的原因，此类服务仅能放在国外，通过国内CDN加速Pages访问速度是一种不错的选择。以Coding Pages和腾讯CDN为例。 本方法同样可以对虚拟主机进行CDN加速。","text":"常见的Pages服务有 Coding Pages和Github Pages，因为众所周知的原因，此类服务仅能放在国外，通过国内CDN加速Pages访问速度是一种不错的选择。以Coding Pages和腾讯CDN为例。 本方法同样可以对虚拟主机进行CDN加速。 本方法可解决以下问题： 提高Pages的访问速度； 利用 CDN 解决百度爬虫被 Github Pages 拒绝的问题； 加速效果展示不使用CDN加速平均响应时间130ms，比我想象中要好。可能因为现在是上午11点上网的人少（?），之前我在学校测得时候动辄200ms。 使用CDN加速可以看到平均响应时间大约24.2ms，祖国山河一片绿。多环保~ 利用Pages搭建个人网站这一步在网上搜一下，有很多教程，在此不赘述。 使用CDN为Pages加速推荐腾讯云CDN，https://www.qcloud.com/product/cdn 目前可以免费送300G流量。根据服务商的要求，如Coding要求为： 在您的域名管理面板中添加 CNAME 记录指向到 pages.coding.me。 获得CNAME的IP地址ping 一下 pages.coding.me，获得IP地址： 23.248.162.138，源站设置为该IP。 接下来，加速服务配置，默认时长都是30天。明显这个时间忒长了，我们可以设置为1天或者几个小时。 点击提交 ，过约5分钟会返回提示成功。点击管理进一步设置； 配置回源host我们可以把回源host理解为，访问23.248.162.138这个IP地址的服务器时，向服务器发出的url访问请求，服务器根据host头部里边的url地址，映射到内部相应访问空间去。回源host是用于CDN回源到源站时的访问域名，即http请求包包头的host字段内容。 配置域名CNAME为域名配置相应的CNAME，常见的是@和www 检查ping 一下自己的域名，如果PING到后缀为cdntip.com或后缀为tcdn.qq.com表示域名CNAME已生效。使用CDN为Pages加速，到这一步已经算结束了。但是由于使用国内CDN，使得网站在国外加载速度会慢的令人发指。 分地区DNS国内国外设置不同CANME，国外指向 mmmwhy.github.io或者pages.coding.me（设置自己的），国内的指向刚才CDN给出的地址。 以上 通过此方法可以将pages或者国外的免费空间，速度快到令人发指的地步~祝新年快乐~","categories":[],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://feiyang.li/tags/CDN/"},{"name":"Pages","slug":"Pages","permalink":"http://feiyang.li/tags/Pages/"}]},{"title":"jupyter notebook使用帮助","slug":"jupyter-notebook","date":"2017-01-12T12:50:52.000Z","updated":"2017-03-16T12:26:02.941Z","comments":true,"path":"2017/01/12/jupyter-notebook/index.html","link":"","permalink":"http://feiyang.li/2017/01/12/jupyter-notebook/index.html","excerpt":"jupyer notebook 使用的时候常见换主题，以及换工作空间的问题。","text":"jupyer notebook 使用的时候常见换主题，以及换工作空间的问题。 jupyter notebook 换字体换颜色换主题jupyter notebook自带的默认颜色实在是阳春白雪，看的多了眼睛有点累。页面的相关定义都是在CSS内完成的，我们可以通过修改CSS来达到目标。但是这样实在是太累了，在Github有一个jupyter-themes工具，真的很好用，通过pip进行安装，分分钟更换成自己喜欢的主题。 安装 jupyterthemespip install jupyterthemes通过pip安装省时省力，如果你当前pip安装速度很慢，可以考虑使用清华源，代码如下：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jupyterthemes 命令行格式1234usage: jt [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT] [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-alt] [-vim] [-T] [-N] [-r] options arg default Usage help -h – List Themes -l – Theme Name to Install -t – Code Font -f droidmono Code Font-Size -fs 11 Notebook Font -nf exosans Notebook Font Size -nfs 13 Text/MD Cell Font -tf loraserif Text/MD Cell Fontsize -tfs 13 Intro Page Margins -m auto Cell Width -cellw 980 Line Height -lineh 170 Cursor Width -cursw 2 Cursor Color -cursc – Alt Text/MD Layout -alt – Alt Prompt Layout -altp – Style Vim NBExt* -vim – Toolbar Visible -T – Name &amp; Logo Visible -N – Restore Default -r – 举个例子jt -t oceans16 -f roboto -fs 15意味着选择oceans16主题，roboto字体，大小为15，效果如下。恢复原始主题，重新启动Jupyter notebook，如果主题没有改变，Ctrl+F5刷新即可。jt -r 目前我自己用的是jt -t onedork -cellw 1600 -lineh 170 -tf georgiaserif -nf droidsans -fs 15效果如下：主要修改了宽度，因为我电脑分辨率是1920*1080，使用默认的900宽度有点小了。 jupyter notebook换工作空间 打开 cmd 输入命令jupyter notebook --generate-config 进入自己工作目录，.jupyter，打开jupyter_notebook_config.py ctrl+f查到c.NotebookApp.notebook_dir，将这一行改为c.NotebookApp.notebook_dir = ‘自己的位置’ 启动 jupyter notebook","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://feiyang.li/tags/Jupyter/"}]},{"title":"部署在线IPyhton notebook(在线python编译器)","slug":"IPyhton-notebook","date":"2016-12-31T14:52:39.000Z","updated":"2017-02-15T12:08:27.233Z","comments":true,"path":"2016/12/31/IPyhton-notebook/index.html","link":"","permalink":"http://feiyang.li/2016/12/31/IPyhton-notebook/index.html","excerpt":"jupyter notebook在数据分析时使用非常的方便，特别那优美的页面，简直让我着迷。","text":"jupyter notebook在数据分析时使用非常的方便，特别那优美的页面，简直让我着迷。 优点： 支持的格式很多，Markdown，Latex等都支持，还有很方便的快捷键。 可以将代码可视化分享给其他人，From notebook to slides 像一张草稿纸，可以一边通过它来进行你的思考探索过程，交互式的进行，每一步都能看到结果，也很方便查看之前的结果。可以到IPython Notebook看一下，密码是Jupyter，我把《利用Python进行数据挖掘》的所有数据集和代码都放到了服务器里边2333333 本地安装Jupyter推荐先安装python科学计算包ANACONDA点击进入官网下载，按要求下载安装完成之后。期间会有一步提示是否加入Path，勾选加入环境变量。如果但是没有勾选，对于win事后可以手动添加环境变量。对于linux，使用export PATH=~/anaconda2/bin:$PATH进行添加。anaconda安装完后，对于win10用户，可以看到已经成功安装Jupyter Notebook，点击即可打开食用~点击之后，默认直接打开浏览器localhost:8888用命令行也可以打开此页面，并且在打开的页面会形成.ipynb文件 线上部署 Jupyter Notebook在本地部署好了之后，其实给了我一些灵感，既然可以在浏览器运行。那么其实部署在服务器上也是可以的，大家如果看过我看过我之前的文章，就知道我对vps很感兴趣。其实在本地看到的那个localhost:8888，在外网也可以访问，只需要稍微加以设置即可。 首先要申请虚拟机这里推荐腾讯云或者DO，通过本链接注册送$10。然后再加上github的学生优惠包，可以很便宜哦。设置好之后，使用SSH连接上服务器。 服务器下载Anaconda 如果选择国内服务器，推荐清华Anaconda 镜像，点击进入，选择与自己服务器相符的版本。wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda-2.3.0-Linux-x86_64.sh 如果选择国外服务器，使用代码wget https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh本来想推荐科大源的，但是科大源实在是烂泥扶不上墙，目前清华源是国内比较好的了。 安装Anacondasudo bash Miniconda-latest-Linux-x86_64.shMiniconda-latest-Linux-x86_64.sh这个地方，输入自己下载的文件名称，其实只要写前几个字母，然后敲Tab，就可以自动补全了。安装好时候输入conda --v检查一下，如果输出为conda的版本则正常。如果输出conda: command not found，出现这种情况的原因是conda没有在path添加，使用export PATH=~/anaconda2/bin:$PATH 添加即可。 打开Ipython ,设置密码设置过程中要设置用于远程登录的密码，把生成的密文‘sha:ce…’复制下来12345In [1]: from IPython.lib import passwdIn [2]: passwd()Enter password:Verify password: Out[2]: &apos;sha1:7467b73*************************3003b****&apos; 生成配置文件终端输入：jupyter notebook --generate-config这个时候在当前目录会生成一个.jupyter的隐藏文件夹，修改文件内的jupyter_notebook_config.pyvim ~/.jupyter/jupyter_notebook_config.py 关于vim的常用功能：按a在光标所在位置插入内容（进入编辑模式），Esc退出编辑模式，连续按两下z，保存并退出。 jupyter_notebook_config.py内包含以下内容，稍作修改即可1234c.NotebookApp.ip=&apos;*&apos; # 就是设置所有ip皆可访问c.NotebookApp.password = u&apos;sha:ce...刚才复制的那个密文&apos;c.NotebookApp.open_browser = False # 禁止自动打开浏览器c.NotebookApp.port =8888 #随便指定一个端口 启动jupyter notebookjupyter notebook 此时应该可以直接从本地浏览器直接访问http://address_of_remote:8888就可以看到jupyter的登陆界面。 如果希望不要在退出SSH命令行的时候，同时也停止jupyter notebook服务，推荐nohup ，之前写过篇博客解释过nohup的作用在线python编译器就搭建好了，是不是很洋气~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://feiyang.li/tags/Jupyter/"},{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"}]},{"title":"第1.1题：Python图片添加水印","slug":"python_camp1","date":"2016-12-31T04:16:16.000Z","updated":"2017-03-27T11:43:18.800Z","comments":true,"path":"2016/12/31/python_camp1/index.html","link":"","permalink":"http://feiyang.li/2016/12/31/python_camp1/index.html","excerpt":"题目来自：Python 练习册，今天做的是第一题，将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。","text":"题目来自：Python 练习册，今天做的是第一题，将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 添加文字水印初始图像 Python代码123456789101112131415from PIL import Image, ImageDraw, ImageFontdef add_num(img): draw = ImageDraw.Draw(img) myfont = ImageFont.truetype('C:/windows/fonts/Arial.ttf', size=40) fillcolor = \"#ff0000\" width, height = img.size draw.text((width-50, 5), '99', font=myfont, fill=fillcolor) img.save('result.jpg','jpeg') return 0if __name__ == '__main__': image = Image.open('F:/Picture/touxiang.jpg') add_num(image) image.show() 代码解释 from PIL import Image, ImageDraw, ImageFont 导入PIL图像处理库 draw = ImageDraw.Draw(img)，查了一下ImageDraw作用： 创建绘画对象 ImageDraw module creates drawing surface for image123import Image, ImageDrawim = Image.open(“vacation.jpeg\") drawSurface = ImageDraw.Draw(im) draw.text((width-50, 5), &#39;99&#39;, font=myfont, fill=fillcolor) 第一个括号填写的是位置，表示在x轴在width-50，y轴在5的位置加入文字，也就是右上角的意思。 效果展示 添加图片水印Python代码1234567891011121314from PIL import Image, ImageDraw, ImageFontdef add_num(im,mark): layer = Image.new('RGBA', im.size, (0, 0, 0, 0)) layer.paste(mark, (im.size[0] - 150, im.size[1] - 150)) out = Image.composite(layer, im, layer) out.save('result.jpg','jpeg') out.show() return 0if __name__ == '__main__': image = Image.open('F:/Picture/touxiang.jpg') mark = Image.open('F:/Picture/1022.png') add_num(image,mark) 代码解释 Image.composite(layer, im, layer) 解释一下Image.composite()的意思使用案例Image.composite(image1, image2, mask) =&gt; image使用遮罩（mask）作为alpha，通过在两个图像之间进行插值来创建一个新图像。遮罩图像的模式可以是“1”，“L”，或者“RGBA”。所有的图像的大小必须有相同。 out.save(&#39;result.jpg&#39;,&#39;jpeg&#39;)，对图片进行保存，设置文件名和文件格式。 效果展示参考文章Python图像处理库：PIL中Image,ImageDraw等基本模块介绍","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"Python练习册","slug":"python_camp","date":"2016-12-31T03:35:04.000Z","updated":"2017-03-27T11:43:25.960Z","comments":true,"path":"2016/12/31/python_camp/index.html","link":"","permalink":"http://feiyang.li/2016/12/31/python_camp/index.html","excerpt":"参考代码一同附上，分析过程见李飞阳，请多指教。","text":"参考代码一同附上，分析过程见李飞阳，请多指教。 一、基础问题题目1.1：图片加水印，类似于微信未读信息数量那种提示效果 题目1.2：使用 Python 如何生成 200 个激活码（或者优惠券） 题目1.3：将 0002 题生成的 200 个激活码（或者优惠券）保存到 MySQL 关系型数据库中。 题目1.4：任一个英文的纯文本文件，统计其中的单词出现的个数。 题目1.5：你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。 题目1.6：使用 Python 生成类似于下图中的字母验证码图片 阅读资料 题目1.7： 敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。 北京 程序员 公务员 领导 牛比 牛逼 你娘 你妈 love sex jiangge 题目1.8： 纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示： { &quot;1&quot;:[&quot;张三&quot;,150,120,100], &quot;2&quot;:[&quot;李四&quot;,90,99,95], &quot;3&quot;:[&quot;王五&quot;,60,66,68] } 请将上述内容写到 student.xls 文件中，如下图所示： 阅读资料 腾讯游戏开发 XML 和 Excel 内容相互转换 题目1.9： 通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。 阅读资料 用户密码的存储与 Python 示例 阅读资料 Hashing Strings with Python 阅读资料 Python’s safest method to store and retrieve passwords from a database 题目1.10： python输入二维数组 二、数据分析题目2.1：你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。 题目2.2：有个目录，里面是你自己写过的程序，统计一下你写过多少行代码。包括空行和注释，但是要分别列出来。 题目2.3： 登陆中国联通网上营业厅 后选择「自助服务」 –&gt; 「详单查询」，然后选择你要查询的时间段，点击「查询」按钮，查询结果页面的最下方，点击「导出」，就会生成类似于 2014年10月01日～2014年10月31日通话详单.xls 文件。写代码，对每月通话时间做个统计。 三、爬虫方面题目3.1：一个HTML文件，找出里面的正文。 题目3.2：一个HTML文件，找出里面的链接。 题目3.3： 用 Python 写一个爬图片的程序，可以参考Python爬取图片（使用urllib2），如果出现问题，可以尝试selenium自动化测试工具 四、Web问题题目4.1： 使用 Python 的 Web 框架，做一个 Web 版本 留言簿 应用。 阅读资料：Python 有哪些 Web 框架 题目4.2： 使用 Python 的 Web 框架，做一个 Web 版本 TodoList 应用。 题目来自 易枭寒的Github","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/tags/Python-camp/"}]},{"title":"使用Python selenium处理页面延迟加载问题","slug":"Python-selenium","date":"2016-12-29T08:06:43.000Z","updated":"2017-03-27T11:44:39.069Z","comments":true,"path":"2016/12/29/Python-selenium/index.html","link":"","permalink":"http://feiyang.li/2016/12/29/Python-selenium/index.html","excerpt":"使用python爬取数据的时候，碰到了一个非常无语的问题。有个网站，在输入url进入页面之后，会强制加载一段动画，之后才显示正确内容。后来发现了selenium这个神器，不过还是折腾了我好久。","text":"使用python爬取数据的时候，碰到了一个非常无语的问题。有个网站，在输入url进入页面之后，会强制加载一段动画，之后才显示正确内容。后来发现了selenium这个神器，不过还是折腾了我好久。 用selenium 设置浏览器等待时间很多人问，这个下拉框定位不到、那个弹出框定位不到…各种定位不到，其实大多数情况下就是两种问题：1 有frame，2 没有加等待。殊不知，你的代码运行速度是什么量级的，而浏览器加载渲染速度又是什么量级的，就好比闪电侠和奥特曼约好去打怪兽，然后闪电侠打完回来之后问奥特曼你为啥还在穿鞋没出门？奥特曼分分中内心一万只羊驼飞过，欺负哥速度慢，哥不跟运行需要两个前提，每个都不好搞。。 首先需要安装selenium ，推荐使用pip安装,pip install selenium或者直接下载selenium包:https://pypi.python.org/pypi/selenium 解压，cmd进入目录:python setup.py install 接下来安装 ChromeDriver推荐在这里 https://sites.google.com/a/chromium.org/chromedriver/downloads 下载，然后放在Chrome浏览器目录内，配置Path环境变量为形如 XXGoogle\\Chrome\\Application的形式你玩了，抛个异常撂挑子了。 最简单粗暴的一种办法就是强制等待sleep(xx)，强制让闪电侠等xx时间，不管凹凸曼能不能跟上速度，还是已经提前到了，都必须等xx时间。 12345678# coding: utf-8from selenium import webdriverfrom time import sleepdriver = webdriver.Chrome()driver.get('https://feiyang.li')sleep(3) # 强制等待3秒再执行下一步print driver.titledriver.quit() 结合selenium使用Xpath获得所需信息 需要注意的是，selenium内find_elements的方法有很多种，xpath表达式的要求很严格，所以可以试试find_elements_id等方法。 Xpath表达式可以检测文字中是否包含某文字，以此为标准过滤。 Xpath表达式支持and 和 or。 1234def extract_from(browser): links = browser.find_elements_by_xpath(\"//p[contains(text(), '出处') or contains(text(), '组成') or contains(text(), '组成') or contains(text(), '主治') or contains(text(), '用法')] \") print(browser.title) return [link.text for link in links] 中文输入输出问题 send_keys() 不能正确的输入关键字，在中文前边加一个u即可，比如elem.send_keys(u&#39;你好哇&#39;) 不能正确的输出中文，print (&#39;\\n&#39;.join(extract_from(browser)))以上两个问题都跟python2的特性有关，升级至3之后应当不会出现此类问题。 写了一个小demo，解释中文输入输出问题12345678910111213141516171819# coding=utf-8import timefrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdef search(key): elem = browser.find_element_by_xpath(\"//input[@id='kw']\") elem.send_keys(key) elem.send_keys(Keys.RETURN) time.sleep(1)def extract_from(browser): links = browser.find_elements_by_xpath(\"//div[contains(text(),'李银河')]\") return [link.text for link in links]key = u\"你好哇\"browser = webdriver.Chrome()browser.get('http://www.baidu.com')search(key)print ('\\n'.join(extract_from(browser)))browser.close() 运行结果见下，可以抽取出对应文字。 Code1234567891011121314151617181920212223242526272829303132# coding=utf-8import timeimport requestsfrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysdef search(key): elem = browser.find_element_by_xpath(\"//input[@id='simple_search_filed']\") elem.send_keys(key) elem.send_keys(Keys.RETURN) time.sleep(3)def extract_from(browser): links = browser.find_elements_by_xpath(\"//p[contains(text(), '出处') or contains(text(), '组成') or contains(text(), '组成') or contains(text(), '主治') or contains(text(), '用法')] \") print(browser.title) return [link.text for link in links]from lxml import etreehtml = requests.get(\"http://www.zk120.com/fang/\")html.encoding = 'utf-8'selector = etree.HTML(html.text)content = selector.xpath(\"//ul/li/a/span[@class='free_icon_r']/../@href\")for imgurl in content: imgurl = \"http://www.zk120.com\" +imgurl browser = webdriver.Chrome() browser.get(imgurl) time.sleep(2) print ('\\n'.join(extract_from(browser))) print(\"------------\") browser.close() 参考代码在搜索资料的时候，同时发现了一个非常好的示例代码 1234567891011121314151617181920212223242526272829303132import refrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdef extract_data(browser): links = browser.find_elements_by_xpath('//i[@class=\"RecordStats\"]/a') return [link.get_attribute('href') for link in links]browser = webdriver.Firefox()browser.get(\"http://www.scba.gov.ar/jurisprudencia/Navbar.asp?Busca=Fallos+Completos&amp;SearchString=Inconstitucionalidad\")# get max pageselement = WebDriverWait(browser, 10).until(EC.presence_of_element_located((By.XPATH, \"//p[@class='c'][last()]\")))max_pages = int(re.search(r'\\d+ de (\\d+)', element.text).group(1), re.UNICODE)# extract from the current (1) pageprint \"Page 1\"print extract_data(browser)# loop over the rest of the pagesfor page in xrange(2, max_pages + 1): print \"Page %d\" % page next_page = browser.find_element_by_xpath(\"//table[last()]//td[last()]/a\").click() print extract_data(browser) print \"-----\" 这个地方真的花费了我好大的精力啊，让人头疼。","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://feiyang.li/tags/爬虫/"},{"name":"Xpath","slug":"Xpath","permalink":"http://feiyang.li/tags/Xpath/"},{"name":"selenium","slug":"selenium","permalink":"http://feiyang.li/tags/selenium/"}]},{"title":"牛顿迭代法计算平方根(Java,Python实现)","slug":"Newton-Raphson_method-Java-Python","date":"2016-12-28T08:33:55.000Z","updated":"2017-03-27T11:44:42.774Z","comments":true,"path":"2016/12/28/Newton-Raphson_method-Java-Python/index.html","link":"","permalink":"http://feiyang.li/2016/12/28/Newton-Raphson_method-Java-Python/index.html","excerpt":"牛顿法的作用是使用迭代的方法来求解函数方程的根。简单地说，牛顿法就是不断求取切线的过程。","text":"牛顿法的作用是使用迭代的方法来求解函数方程的根。简单地说，牛顿法就是不断求取切线的过程。 数学推导假设c为原数，t为c的根数。 $$ t^2 \\quad = \\quad c$$$$2t^2 \\quad = \\quad c + \\quad t^2$$$$2t \\quad = \\quad \\frac{c}{t}+ \\quad t$$$$t \\quad = \\quad \\frac{\\frac{c}{t} + t}{2.0}$$ Java代码实现123456789101112131415161718192021package test;import java.io.IOException;import java.util.Scanner;public class QuickFindUF &#123; public static double sqrt (double c)&#123; if(c&lt;0) return Double.NaN; double err = 1e-15; double t = c; while(Math.abs(t-c/t)&gt;err) t = (c/t+t)/2.0; return t; &#125; public static void main(String args[]) throws IOException&#123; Scanner sc = new Scanner(System.in); double a = sqrt(sc.nextDouble()); System.out.println(a); &#125;&#125; Python代码实现123456c = input()err = 1e-15t = cwhile abs(t - c/t)&gt;err: t = (c/t+t)/2.0print(t) Python代码真心简洁啊","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"Java","slug":"Java","permalink":"http://feiyang.li/tags/Java/"}]},{"title":"LaTex 编辑公式","slug":"LaTex","date":"2016-12-28T07:21:21.000Z","updated":"2017-02-11T13:23:33.245Z","comments":true,"path":"2016/12/28/LaTex/index.html","link":"","permalink":"http://feiyang.li/2016/12/28/LaTex/index.html","excerpt":"在计算机直接输入数学公式是一件棘手的事情，我一般是用一个专业的数学工具MathType，但最近在使用Markdown写作，遂产生念头用LaTex输入公式。发现目前网上的语法介绍往往不够全面，于是自己写了一份。","text":"在计算机直接输入数学公式是一件棘手的事情，我一般是用一个专业的数学工具MathType，但最近在使用Markdown写作，遂产生念头用LaTex输入公式。发现目前网上的语法介绍往往不够全面，于是自己写了一份。 LaTex 公式通用语法 使用单 $ 围住表达式，居左展示。 使用双 $$ 围住表达式，可以居中显示。 空格当前环境标准字体宽度为 M 两个quad空格 a \\qquad b 两个m的宽度$$ C_1 \\qquad C_2 $$$$ C_1 \\qquad C_2 $$ quad空格 a \\quad b 一个m的宽度$$ C_1 \\quad C_2 $$$$ C_1 \\quad C_2 $$ 大空格 a\\ b 1/3m宽度$$ C_1 \\ C_2 $$$$ C_1 \\ C_2 $$ 中等空格 C_1\\;C_2 2/7m宽度$$C_1\\;C_2$$$$C_1\\;C_2$$ 小空格 C_1\\,C_2 1/6m宽度$$C_1\\,C_2$$$$C_1\\,C_2$$ 没有空格 C_1C_2$$C_1C_2$$$$C_1C_2$$ 紧贴 C_1!C_2 缩进1/6m宽度$$C_1\\!C_2$$ 上下标 上标符号 ^$$ c_{1}^{2}=a^{2}+b^{2} $$$$ c_{1}^{2}=a^{2}+b^{2} $$ 下标符号_$$C_{m,n}$$$$C_{m,n}$$ 希腊字母$$\\lambda,\\xi,\\pi,\\mu,\\Phi,\\Omega,\\alpha, \\beta, \\gamma,\\Gamma, \\Delta $$$$\\lambda,\\xi,\\pi,\\mu,\\Phi,\\Omega,\\alpha, \\beta, \\gamma,\\Gamma, \\Delta $$ 值比较符 大于等于小于，使用正常&gt;,&lt;,=即可 大于等于使用 \\geq$$e^{x^2} \\geq {e^x}^2$$$$e^{x^2} \\geq {e^x}^2$$ 小于等于使用\\leq$$e^{x^2} \\leq {e^x}^2$$$$e^{x^2} \\leq {e^x}^2$$ 不等于使用neq$$e^{x^2} \\neq {e^x}^2$$$$e^{x^2} \\neq {e^x}^2$$ 平方根使用\\sqrt或 \\surd$$\\sqrt{x+y}$$$$\\sqrt{x+y}$$ 水平线使用 \\overline,\\underline$$\\overline{m+n} \\quad \\underline{m+n}$$$$\\overline{m+n} \\quad \\underline{m+n}$$ 水平括号使用\\overbrace 和 \\underbrace$$ \\underbrace{a+b+\\cdots+z}_{26}$$$$ \\underbrace{a+b+\\cdots+z}_{26}$$ 重音号使用\\widetilde 和 \\widehat$$y’=3\\widetilde a+4\\widehat b$$ 向量使用\\overrightarrow 和 \\overleftarrow$$\\overrightarrow {AC} = \\overrightarrow {AB} +\\overrightarrow {BC} $$$$\\overrightarrow {AC} = \\overleftarrow {AB} +\\overrightarrow {BC} $$ 圆点使用\\cdot, \\cdots,\\vdots,\\ddot$$ a \\vdots =b \\cdot c \\cdots d \\ddot e$$$$ a \\vdots =b \\cdot c \\cdots d \\ddot e$$ 函数名\\arccos \\cos \\csc \\arcsin \\cosh \\deg \\arctan \\cot \\det \\arg \\coth \\dim \\sinh \\sup \\tan [\\lim_{x \\rightarrow 0} \\frac{\\sin x}{x}=1] \\exp \\ker \\limsup \\min \\gcd \\lg \\ln \\Pr \\hom \\lim \\log \\sec \\inf \\liminf \\max \\sin \\tanh $$lim_{x \\rightarrow 0} \\frac{\\sin x}{x}=1$$$$lim_{x \\rightarrow 0} \\frac{\\sin x}{x}=1$$ 数学符\\mathbf$$ x^{2} \\geq 0\\qquad \\textrm{for all }x\\in\\mathbf{R} $$$$ x^{2} \\geq 0\\qquad \\textrm{for all }x\\in\\mathbf{R} $$ 分数直接输入或者\\frac{}{} $$\\sin \\alpha = \\frac{a}{c} $$$$\\sin \\alpha = \\frac{a}{c} $$ $$x^{1/2} $$$$x^{1/2} $$ 二项系数{… \\choose …} 或 {… \\atop …}。第二个命令与第一个命令的输出相同,只是没有括号。$${n\\choose m} \\qquad {x\\atop y+2}$$$${n\\choose m} \\qquad {x\\atop y+2}$$ 前缀符号\\int,\\sum,\\prod $$ {\\int_{0}^{\\frac{\\pi}{2}}} $$$$ {\\int_{0}^{\\frac{\\pi}{2}}} $$ $$ \\sum_{i=1}^{n}$$$$ \\sum_{i=1}^{n}$$ $$\\prod_\\epsilon$$$$\\prod_\\epsilon$$ 转义符号有时保留字需要加入\\来进行转义$${a,b,c}\\neq\\{a,b,c\\}$$$${a,b,c}\\neq{a,b,c}$$ 括号层次 正确的括号大小\\left和\\right。如果将命令 \\left 放在开分隔符前,TEX会自动决定分隔符的正确大 小。注意必须用对应的右分隔符 \\right 来关闭每一个左分隔符 \\left,并 且只有当这两个分隔符排在同一行时大小才会被正确确定。我们可以看到右式没有采用\\left形式，不能正确确定括号大小$$ 1+\\left(\\frac {1}{1-x^2}\\right) ^3 \\qquad 1+(\\frac {1}{1-x^2}) ^3$$$$ 1+\\left(\\frac {1}{1-x^2}\\right) ^3 \\qquad 1+(\\frac {1}{1-x^2}) ^3$$ 另外也可以手工指出括号大小，使用\\big,\\Big,\\bigg,\\Bigg。 $$ \\Big( (x+y) (x-y) \\Big)^{2} $$$$ \\Big( (x+y) (x-y) \\Big)^{2} $$ $$\\big(\\Big(\\bigg(\\Bigg($$$$\\big(\\Big(\\bigg(\\Bigg($$ $$\\big\\}\\Big\\}\\bigg\\}\\Bigg\\} $$$$\\big}\\Big}\\bigg}\\Bigg} $$ $$\\big\\|\\Big\\|\\bigg\\|\\Bigg\\| $$$$\\big|\\Big|\\bigg|\\Bigg| $$ 垂直对齐使用array命令，并\\命令来分行。注意转义 123456$$\\mathbf&#123;X&#125; = \\left( \\begin&#123;array&#125;&#123;ccc&#125; x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \\ldots \\\\\\ x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \\ldots \\\\\\ \\vdots &amp; \\vdots &amp; \\ddots \\end&#123;array&#125; \\right) $$","categories":[],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://feiyang.li/tags/LaTex/"}]},{"title":"Nginx环境下配置HTTPS","slug":"Nginx_HTTPS","date":"2016-12-18T08:47:29.000Z","updated":"2017-02-11T13:21:04.182Z","comments":true,"path":"2016/12/18/Nginx_HTTPS/index.html","link":"","permalink":"http://feiyang.li/2016/12/18/Nginx_HTTPS/index.html","excerpt":"现在，你应该能在访问https://feiyang.li 的时候，在地址栏里看到一个漂亮的小绿锁作为肤浅的人，为了这么洋气的小绿锁也要上HTTPS~","text":"现在，你应该能在访问https://feiyang.li 的时候，在地址栏里看到一个漂亮的小绿锁作为肤浅的人，为了这么洋气的小绿锁也要上HTTPS~ 申请免费SSL证书普通的SSL证书动辄好几千，简直令人发指。不过别担心，我找到了3个免费申请HTTPS证书的方式。 StartSSL也免费提供了一个证书（纯英文）申请地址：https://www.startssl.com/Account?r=L1ZhbGlkYXRl 阿里云免费提供的证书https://common-buy.aliyun.com/?spm=5176.7968328.231195.3.Vh92u7&amp;commodityCode=cas#/buy 腾讯云免费申请https://console.qcloud.com/ssl 获得证书之后，下载至本地。 VPS上安装SSL证书以Nginx 为例 获取证书Nginx文件夹内获得SSL证书文件 1_www.domain.com_bundle.crt 和私钥文件 2_www.domain.com.key, 1_www.domain.com_bundle.crt 文件包括两段证书代码 “—–BEGIN CERTIFICATE—–”和“—–END CERTIFICATE—–”,2_www.domain.com.key 文件包括一段私钥代码“—–BEGIN RSA PRIVATE KEY—–”和“—–END RSA PRIVATE KEY—–”。 上传和部署SSL证书将域名 www.domain.com 的证书文件1_www.domain.com_bundle.crt 、私钥文件2_www.domain.com.key保存到同一个目录，例如/usr/local/nginx/conf目录下。更新Nginx根目录下 conf/nginx.conf 文件如下：123456789101112131415server &#123; listen 443; server_name www.domain.com; #填写绑定证书的域名 ssl on; ssl_certificate 1_www.domain.com_bundle.crt; ssl_certificate_key 2_www.domain.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; root html; #站点目录 index index.html index.htm; &#125; &#125; 配置文件参数 说明 listen 443 SSL访问端口号为443 ssl on 启用SSL功能 ssl_certificate 证书文件 ssl_certificate_key 私钥文件 ssl_protocols 使用的协议 ssl_ciphers 配置加密套件，写法遵循openssl标准 重启Nginx输入 nginx -s reload ：修改配置后重新加载生效可以看到SSL证书生效，且HTTPS可以访问站点。","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"},{"name":"Nginx","slug":"Nginx","permalink":"http://feiyang.li/tags/Nginx/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://feiyang.li/tags/HTTPS/"}]},{"title":"使用Python插入排序","slug":"Python_get_order","date":"2016-12-15T13:44:51.000Z","updated":"2017-03-09T14:37:28.515Z","comments":true,"path":"2016/12/15/Python_get_order/index.html","link":"","permalink":"http://feiyang.li/2016/12/15/Python_get_order/index.html","excerpt":"使用Python进行数据结构操作比较少见，但为了更深入的理解Python的操作原理，提升自己的算法能力。我决定认真过一遍 普林斯顿大学教授Robert Sedgewick主讲的《Algorithms》","text":"使用Python进行数据结构操作比较少见，但为了更深入的理解Python的操作原理，提升自己的算法能力。我决定认真过一遍 普林斯顿大学教授Robert Sedgewick主讲的《Algorithms》 【普林斯顿算法下载链接】普林斯顿大学教授Robert Sedgewick主讲的《Algorithms》 使用C++插入排序12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; int a[] = &#123; 4,3,9,0,1,2,5,6,7,8 &#125;; for(int i = 1; i &lt; 10; i++) &#123; int key = a[i]; int j = i - 1; while (j &gt;= 0&amp;&amp;a[j] &gt; key) &#123; a[j + 1] = a[j]; j--; &#125; a[j + 1] = key; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 这一段比较简单，我也就不多说了。 使用Python进行排序123456789data = [4,3,9,0,1]for i in range(1,len(data)): key = data[i] j = i - 1 while j &gt;= 0 and data[j] &gt; key: data[j+1]=data[j] j = j - 1 data[j+1] = keyprint(data) 总结： Python的确比CPP简洁得多； while循环体中条件部分可以使用 and ，不能用&amp;&amp; python没有{}，需要对齐，输入Tab或者敲空格。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://feiyang.li/tags/Algorithms/"},{"name":"sort","slug":"sort","permalink":"http://feiyang.li/tags/sort/"}]},{"title":"Python爬取图片（使用urllib2）","slug":"Python_use_urllib2","date":"2016-12-15T11:14:24.000Z","updated":"2017-03-27T11:43:58.909Z","comments":true,"path":"2016/12/15/Python_use_urllib2/index.html","link":"","permalink":"http://feiyang.li/2016/12/15/Python_use_urllib2/index.html","excerpt":"上篇文章 使用 XPath 提取网页信息 之后，将链接中的内容下载至本地，需要使用到 urllib2 。","text":"上篇文章 使用 XPath 提取网页信息 之后，将链接中的内容下载至本地，需要使用到 urllib2 。 urllib2 简介urllib2提供一个基础函数urlopen，通过向指定的URL发出请求来获取数据。最简单的形式就是： 123import urllib2 response = urllib2.urlopen('http://feiyang.li/') html = response.read() 可以将上述代码看作两个步骤，我们指定一个域名并发送请求1request=urllib2.request(&apos;http://feiyang.li/&apos;) 接着服务端响应来自客户端的请求 1response=urllib2.urlopen(request) 我们可以发现title这个地方本来应该是中文的，但因为编码的原因，导致出现乱码。通过将html页面重新用”utf-8”编码，可以解决这个问题。 将获得的response保存至本地使用Xpath表达式提取图片链接详见上一文章 http://feiyang.li/2016/12/13/get_html/ ，关于XPath和beautifulsoup，可以参考python中的beautifulsoup和xpath有什么异同点？ 这里需要导入lxml，代码格式如下。 123456import requestsfrom lxml import etreehtml = requests.get(\"http://jandan.net/ooxx\")html.encoding = 'utf-8'selector = etree.HTML(html.text)content = selector.xpath('//ol[@class = \"commentlist\"]//@src') 单独运行 以上代码可以获得 设置保存的位置需要使用到os库中的 os.chdir(r””)函数，””中间插入地址。注意这个位置必须是存在的，如果位置不存在，函数会报错。因为该函数的意义是：将工作空间从python代码所在位置，改为指定的这个位置。 模拟正常浏览器下载图片（如果Python下载的图片不显示 ）有时你会碰到，程序也对，但是服务器拒绝你的访问。这是为什么呢? 问题出在请求中的头信息(header)。 有的服务端有洁癖，不喜欢程序来触摸它。 这个时候你需要将你的程序伪装成浏览器来发出请求。请求的方式就包含在header中。 123456header = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.114 Safari/537.36', 'Cookie': 'AspxAutoDetectCookieSupport=1', &#125; request = urllib2.Request(imgurl, None, header) response = urllib2.urlopen(request) 可以看到urllib2.Request()里边加入了一个header，用于模拟浏览器访问，第二个位置None表示data，用Python官方文档的说法：Sometimes you want to send data to a URL (often the URL will refer to a CGI (Common Gateway Interface) script [1] or other web application). With HTTP, this is often done using what’s known as a POST request. 暂时我们用不着，所以不深究，等我碰到这个问题了再说。 为图片命名（下载图片只有一张）在获得response之后，将图片直接保存为某个特定名字的话。会导致之后抓取到的图片顶替掉之前的图片，导致图片看起来只有一张。 1234with open(\"%s.jpg\" %name, \"wb\") as f: f.write(response.read()) print(imgurl) name += 1 使用with as语句，将文件名保存为%s.jpg，类似于C语言的输出。循环结束的时候name++，保证文件名不重复。 使用with as 函数Python’s with statement provides a very convenient way of dealing with the situation where you have to do a setup and teardown to make something happen. A very good example for this is the situation where you want to gain a handler to a file, read data from the file and the close the file handler.有一些任务，可能事先需要设置，事后做清理工作。对于这种场景，Python的with语句提供了一种非常方便的处理方式。一个很好的例子是文件处理，你需要获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。 Without the with statement, one would write something along the lines of:如果不用with语句，代码如下：123file = open(\"/tmp/foo.txt\")data = file.read()file.close() 使用with as之后代码为：12with open(\"%s.jpg\" %name, \"wb\") as f: f.write(response.read()) 总结本文通过XPath表达式提取页面图片链接，使用urllib2下载，其中使用header模仿浏览器访问。解决了以下问题： Python下载的图片不显示 下载图片只有一张 设置保存的位置 使用with f函数 效果如下： 完整代码 # coding=utf-8 import requests import urllib2 import os from lxml import etree html = requests.get(\"http://cl.d5j.biz/htm_mob/7/1612/2172569.html\") html.encoding = 'utf-8' selector = etree.HTML(html.text) content = selector.xpath('//table//img/@src') for imgurl in content: name = imgurl[-9:]; os.chdir(r\"D:\") header = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.114 Safari/537.36', 'Cookie': 'AspxAutoDetectCookieSupport=1', } request = urllib2.Request(imgurl, None, header) #刻意增加头部header，否则本行与下一行可以写为：response = urllib2.urlopen(imgurl) response = urllib2.urlopen(request) f = open(name , 'wb') f.write(response.read()) f.close() print(imgurl) 代码重新修改了一下，上手运行会发现D盘有惊喜哦~加入print(imgurl)，运行起来更洋气~","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://feiyang.li/tags/爬虫/"},{"name":"urllib2","slug":"urllib2","permalink":"http://feiyang.li/tags/urllib2/"}]},{"title":"使用 XPath 提取网页信息","slug":"get_html","date":"2016-12-13T08:24:34.000Z","updated":"2017-02-11T13:27:18.463Z","comments":true,"path":"2016/12/13/get_html/index.html","link":"","permalink":"http://feiyang.li/2016/12/13/get_html/index.html","excerpt":"以1024举例，使用XPath提取图片链接以及磁力链接地址。","text":"以1024举例，使用XPath提取图片链接以及磁力链接地址。 学习XPath的基本知识推荐 Xpath教程 很容易理解。推荐可以将常用的语法记下来，不常用的可以等用的时候再查。 推荐使用Chrome浏览器中的XPath Helper，良心之作. 左边输入XPath表达式，右侧会自动展示结果。 选择元素之后按下ctral + shift + x，可以自动提取该元素的XPath表达式。 常用语法 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 @ 选取属性，常见使用方法为[@class = “title”] 举例，比如在双面胶-淘宝搜索 页面 输入: //*[@class=”m-itemlist”]//a[@trace-price&lt;20]/@href，用来提取出class为itemlist内a标签里所有price 小于20的产品，并将其href(即超链接)输出 需要结合Chrome浏览器的F12一起使用，先选定大致的框架，比如itemlist这个class，然后逐渐加上更多的要求，具体见文首给出的链接学习。 知道这些就可以抓取1024上的图片和磁力链接了，目测是不是很简单 挑选网页实验一下 作为一名1024资深游客，首先在技术讨论区选择一篇好文，这里用的是[榴民资讯]11月精品主题推荐（49期） 使用F12查看网页的结构有两个主要标签 header 和 main ，鼠标移动到main上，可以看到内容页面都被包含起来，所以第一个节点应该选main。 使用XPath表达式筛选图片链接我们看到图片前边都有一个属性src，这个src后边就是我们所需的图片链接。 综上，使用XPath表达式: //*[@id=”main”]//@src输入XPath代码，获得图片链接。 使用XPath表达式筛选磁力链接同理，我们可以发现，磁力链接前边都有一个blockquote，与上一条处理方式类似，使用XPath表达式: //*[@id=”main”]//blockquote 以上","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://feiyang.li/tags/爬虫/"},{"name":"Xpath","slug":"Xpath","permalink":"http://feiyang.li/tags/Xpath/"}]},{"title":"永远的7012","slug":"forever_7012","date":"2016-10-28T13:33:08.000Z","updated":"2017-02-07T05:47:51.001Z","comments":true,"path":"2016/10/28/forever_7012/index.html","link":"","permalink":"http://feiyang.li/2016/10/28/forever_7012/index.html","excerpt":"Gary要从Running man下车了，这真是10月以来最悲伤的一件事了。","text":"Gary要从Running man下车了，这真是10月以来最悲伤的一件事了。 慌张在这件事情还没有成为热搜之前，室友私下给我发了这个消息。 当时我第一反应就觉得是假的，“怎么可能嘛，Gary之前说过七个人要永远在一起的啊。” 就算我信誓旦旦的否认了，可还是忍不住又把这个消息多看了好几遍，想找到这是个假消息的依据。 可到后来我越看越慌，直到过了两个小时以后，热搜出现Gary的名字，我才被迫相信，但还是不愿接受。 缘起其实我并没有认识他们太长时间，但却在最短的时间内被他们所吸引。 因为他们七个人，让我爱上了一个国家。 我觉得这就是韩国跑男的魅力吧，他们永远谦逊，努力，敬业，总是希望把最好的一面呈献给观众。他们七个人的感情好到让我嫉妒，多少不经意间的小动作让我们觉得这就是一家人的感觉，这种感情，绝对不是靠”We are family“就能喊出来的。 七年Running man在一起跑了七年了，每个周一都准时准点的出现在我们面前，风雨无阻，真的不是所有的综艺都可以坚持那么久的。 王鼻子大叔已经50岁了，体力明显跟不上了。 金钟国浑身是伤，根本无法再扮演能力者的角色。 其他的成员也是或多或少身体状况都不佳，不可能再回到大规模撕名牌的环节中。 我们看得出来现在的running man确实不如以前好看了，可是看到他们七个人在一起，就是最开心的事。 我知道我们总有一天要和Runningman告别，我也曾想过很多次他们会以怎样的方式跟我们说再见。可这种方式是我最不愿意见到的。 与其Gary一人离开，不如节目就到此为止吧。 因为在我心里，他们就是一个整体，谁也不能替代，谁也无法分割。 不知道RM以后会怎么发展下去，但我知道所有深爱过这个节目的人，都不会责怪他们。 就算不舍，也会把最真的祝福送给每一位成员。并且要告诉他们：谢谢他们七年的陪伴，谢谢他们为我们所做的努力，谢谢他们给我们带来那么多的快乐。 综艺人姜Gary，我们有缘再见！音乐人姜Gary，我们敬请期待！","categories":[],"tags":[{"name":"臭臭","slug":"臭臭","permalink":"http://feiyang.li/tags/臭臭/"},{"name":"Running man","slug":"Running-man","permalink":"http://feiyang.li/tags/Running-man/"}]},{"title":"C / C++ 文件读取写入、文件夹的打开","slug":"C_read","date":"2016-10-28T11:09:24.000Z","updated":"2017-02-11T13:27:15.125Z","comments":true,"path":"2016/10/28/C_read/index.html","link":"","permalink":"http://feiyang.li/2016/10/28/C_read/index.html","excerpt":"使用C++做文件处理时常用的几个函数","text":"使用C++做文件处理时常用的几个函数 文件的打开与关闭 (open和close函数)文件读取之前，使用open函数进行打开。文件使用完毕后，使用close命令关闭。 12infile.open(\"E:\\\\hello.txt\");infile.close(); 文件读取与写入(infile &gt;&gt; income,outfile &lt;&lt; “income:”)C++中可以调用库 #include&lt;fstream&gt; 之后可以使用，”&gt;&gt;”和”&lt;&lt;”输入输出流的形式进行文件的读取 12345678while (infile &gt;&gt; income) &#123; if (income &lt; cutoff) tax = rate1*income; else tax = rate2*income; outfile &lt;&lt; \"income:\"&lt;&lt;left&lt;&lt;setw(6) &lt;&lt; income &lt;&lt; right&lt;&lt;setw(8) &lt;&lt; \"Tax:\" &lt;&lt;tax&lt;&lt; endl; &#125; 文件夹/文件的打开在程序运行完之后，你可能会希望自动将输出的结果文件打开。调 Windows Exploler 打开一个文件夹， 1system(\"start E:\\\\tax.out\"); E:\\tax.out 就是你文件的地址 运行程序demo读取hello.txt文件内的收入数据，计算税金，并输出到tax.txt中 hello.txt，直接 Ctrl+S 保存到E盘即可 C++代码如下1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;iomanip&gt;using namespace std;const int cutoff = 6000;const float rate1 = 0.3;const float rate2 = 0.6;void main() &#123; ifstream infile; ofstream outfile; int income, tax; infile.open(\"E:\\\\hello.txt\"); outfile.open(\"E:\\\\tax.txt\"); while (infile &gt;&gt; income) &#123; if (income &lt; cutoff) tax = rate1*income; else tax = rate2*income; outfile &lt;&lt; \"income:\"&lt;&lt;left&lt;&lt;setw(6) &lt;&lt; income &lt;&lt; right&lt;&lt;setw(8) &lt;&lt; \"Tax:\" &lt;&lt;tax&lt;&lt; endl; &#125; infile.close(); outfile.close(); cout &lt;&lt; \"done\"&lt;&lt;endl; system(\"start E:\\\\tax.txt\");&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://feiyang.li/tags/C/"}]},{"title":"《解忧杂货店》","slug":"book","date":"2016-10-28T04:30:59.000Z","updated":"2017-02-13T08:36:38.289Z","comments":true,"path":"2016/10/28/book/index.html","link":"","permalink":"http://feiyang.li/2016/10/28/book/index.html","excerpt":"我一直很努力去当一个善良的人，却总是在现实中受到各种打击。","text":"我一直很努力去当一个善良的人，却总是在现实中受到各种打击。 以至于让我觉得根本不需要总是对别人那么好，或者说其实我希望可以一直对别人保持一颗有爱的心，只不过我需要力量支撑而已。 而解忧杂货店就给了我这种力量。 浪矢爷爷说，人的心声是最不能被忽视的。所以不管是什么内容的信，玩笑的或是严肃的，甚至是一张白纸，他都会认认真真的回复。 因为人与人之间本来就是相互影响的，你的一举一动，一句在你看来是无所谓的话，却可能对别人造成很大的影响。 不要总想着设身处地，我们永远不是别人，总是很难站在别人角度考虑问题，稍不留神就以己度人了。 所以，子所不欲勿施于人，己所欲也勿施于人。 收到那么多封烦恼咨询信后，我慢慢发现其实很多人在写信的时候心里就已经有自己的答案了，他们写信的目的就是为了让别人可以支持他们的想法。 但他们读过回信之后会再写信过来，就说明双方观点不太一样。所以才会反反复复进行那么多次通信，就为了说服别人同意自己的想法。 我就想到每次我想买啥东西又不好意思买的时候，就会假装向阳询问，而阳就会 二话不说 立马给我买了。他竟然那么早就懂了这个道理，真是好棒呀！ 我不知道别人判断一本好书的标准是什么，我不认识东野圭吾，不知道kindle里边他的排名，就只是很喜欢这种故事，有爱情，有亲情，有事业，有梦想。 很平凡，平凡到感觉里边的人物就是生活中的你和我。但文学总是高于生活的，时空的交错，奇妙的构思让我觉得善良的人在冥冥之中总会受到保佑。 文章中的最后一段话好像是这样的，敦也从信纸上抬起头，正好对上了另两个人的视线，他发现他俩的眼里闪着光芒，他想他的眼里也一定是这样的。而我想说，读完这本书以后，我也是这样的感觉。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://feiyang.li/tags/读书笔记/"},{"name":"臭臭","slug":"臭臭","permalink":"http://feiyang.li/tags/臭臭/"}]},{"title":"Python基础","slug":"Python_basic","date":"2016-10-27T03:38:32.000Z","updated":"2017-03-27T11:44:35.727Z","comments":true,"path":"2016/10/27/Python_basic/index.html","link":"","permalink":"http://feiyang.li/2016/10/27/Python_basic/index.html","excerpt":"脚本运行 Windows 下需将python加入的系统变量中； Linux 下需添加头部","text":"脚本运行 Windows 下需将python加入的系统变量中； Linux 下需添加头部 12#! /usr/bin/enc python print('Hello World!') 循环 for 循环for 元素 in 序列: statement while 循环while 条件: statement 函数函数的定义123def square_sum(a,b): c = a**2 + b**2 return c def，这个关键字通知python：我在定义一个函数。square_sum是函数名。括号中的a, b是函数的参数，是对函数的输入。 函数调用和参数传递12345678910111213141516171819a = 1def change_integer(a): a = a + 1 return aprint (change_integer(a)) #注意观察结果print (a) #注意观察结果#===(Python中 \"#\" 后面跟的内容是注释，不执行 )b = [1,2,3]def change_list(b): b[0] = b[0] + 1 return bprint (change_list(b)) #注意观察结果print (b) #注意观察结果 第一个例子，我们将一个整数变量传递给函数，函数对它进行操作，但原整数变量a不发生变化。第二个例子，我们将一个表传递给函数，函数进行操作，原来的表b发生变化。对于基本数据类型的变量，变量传递给函数后，函数会在内存中复制一个新的变量，从而不影响原来的变量。（我们称此为值传递）但是对于表来说，表传递给函数的是一个指针，指针指向序列在内存中的位置，在函数中对表的操作将在原有内存中进行，从而影响原有变量。 （我们称此为指针传递）。 类我们定义一个类“鸟”，鸟有羽毛，鸟的方法是下蛋，定义一个函数fly()。123456789101112class Bird(object): feather = True way = 'egg' def fly(self, dx, dy): position = [0,0] position[0] = position[0] + dx position[1] = position[1] + dy return positionsummer = Bird()print (after move:',summer.fly(5,8)) 方法的第一个参数必须是self，无论是否用到。 我的summer可以飞了。 常见python os 命令 os.getcwd() 函数得到当前工作目录，即当前Python脚本工作的目录路径。 os.listdir() 返回指定目录下的所有文件和目录名。 os.remove() 删除一个文件。 os.chdir(dirname) 改变工作目录到dirname","categories":[{"name":"Python_camp","slug":"Python-camp","permalink":"http://feiyang.li/categories/Python-camp/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://feiyang.li/tags/Python/"}]},{"title":"Android正则表达式及Pattern Matcher使用","slug":"Android_Pattern Matcher","date":"2016-10-19T13:25:57.000Z","updated":"2016-10-20T07:14:18.936Z","comments":true,"path":"2016/10/19/Android_Pattern Matcher/index.html","link":"","permalink":"http://feiyang.li/2016/10/19/Android_Pattern Matcher/index.html","excerpt":"Pattern Matcher使用众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生","text":"Pattern Matcher使用众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生 而这些情况有时又比较复杂，如果用纯编码方式解决，往往会浪费程序员的时间及精力。因此，学习及使用正则表达式，便成了解决这一矛盾的主要手段。 一个正则表达式就是由普通的字符（例如字符a到z）以及特殊字符（元字符）组成的文字模式，它用以描述在查找文字主体时待匹配的一个或多个字符串。 加入特定限制条件「[]」 [a-z] 条件限制在小写a to z范围中一个字符 [A-Z] 条件限制在大写A to Z范围中一个字符 [a-zA-Z] 条件限制在小写a to z或大写A to Z范围中一个字符 [0-9] 条件限制在小写0 to 9范围中一个字符 [0-9a-z] 条件限制在小写0 to 9或a to z范围中一个字符 [0-9[a-z]] 条件限制在小写0 to 9或a to z范围中一个字符(交集) []中加入^后加再次限制条件「[^]」 [^a-z] 条件限制在非小写a to z范围中一个字符 [^A-Z] 条件限制在非大写A to Z范围中一个字符 [^a-zA-Z] 条件限制在非小写a to z或大写A to Z范围中一个字符 [^0-9] 条件限制在非小写0 to 9范围中一个字符 [^0-9a-z] 条件限制在非小写0 to 9或a to z范围中一个字符 [^0-9[a-z]] 条件限制在非小写0 to 9或a to z范围中一个字符(交集) 在限制条件为特定字符出现0次以上时，可以使用「*」 J* 0个以上J .* 0个以上任意字符 J.*D J与D之间0个以上任意字符 在限制条件为特定字符出现1次以上时，可以使用「+」 J+ 1个以上J .+ 1个以上任意字符 J.+D J与D之间1个以上任意字符 Pattern Matcher的例子查找以Java开头,任意结尾的字符串1234Pattern pattern = Pattern.compile(\"^Java.*\"); Matcher matcher = pattern.matcher(\"Java不是人\"); boolean b= matcher.matches(); //当条件满足时，将返回true，否则返回false System.out.println(b); 以多条件分割字符串时12345Pattern pattern = Pattern.compile(\"[, |]+\"); String[] strs = pattern.split(\"Java Hello World Java,Hello,,World|Sun\"); for (int i=0;i&lt;strs.length;i++) &#123; System.out.println(strs[i]); &#125; 文字替换（首次出现字符）12345Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World\"); //替换第一个符合正则的数据 System.out.println(matcher.replaceFirst(\"Java\")); ` 文字替换（全部）12345Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World\"); //替换第一个符合正则的数据 System.out.println(matcher.replaceAll(\"Java\")); ` 文字替换（置换字符）12345678Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World \"); StringBuffer sbr = new StringBuffer(); while (matcher.find()) &#123; matcher.appendReplacement(sbr, \"Java\"); &#125; matcher.appendTail(sbr); System.out.println(sbr.toString()); 验证是否为邮箱地址1234String str=\"ceponline@yahoo.com.cn\"; Pattern pattern = Pattern.compile(\"[//w//.//-]+@([//w//-]+//.)+[//w//-]+\",Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(str); System.out.println(matcher.matches()); 查找html中对应条件字符串12345Pattern pattern = Pattern.compile(\"href=/\"(.+?)/\"\"); Matcher matcher = pattern.matcher(\"&lt;a href=/\"index.html/\"&gt;主页&lt;/a&gt;\"); if(matcher.find()) System.out.println(matcher.group(1)); &#125; 截取http://地址12345678Pattern pattern = Pattern.compile(\"(http://|https://)&#123;1&#125;[//w//.//-/:]+\"); Matcher matcher = pattern.matcher(\"dsdsds&lt;http://dsds//gfgffdfd&gt;fdf\"); StringBuffer buffer = new StringBuffer(); while(matcher.find())&#123; buffer.append(matcher.group()); buffer.append(\"/r/n\"); System.out.println(buffer.toString()); &#125; 替换指定{}中文字12345678910public static String replace(final String sourceString,Object[] object) &#123; String temp=sourceString; for(int i=0;i&lt;object.length;i++)&#123; String[] result=(String[])object[i]; Pattern pattern = Pattern.compile(result[0]); Matcher matcher = pattern.matcher(temp); temp=matcher.replaceAll(result[1]); &#125; return temp; &#125; 以正则条件查询指定目录下文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//用于缓存文件列表 private ArrayList files = new ArrayList(); //用于承载文件路径 private String _path; //用于承载未合并的正则公式 private String _regexp; class MyFileFilter implements FileFilter &#123; /** * 匹配文件名称 */ public boolean accept(File file) &#123; try &#123; Pattern pattern = Pattern.compile(_regexp); Matcher match = pattern.matcher(file.getName()); return match.matches(); &#125; catch (Exception e) &#123; return true; &#125; &#125; &#125; /** * 解析输入流 * @param inputs */ FilesAnalyze (String path,String regexp)&#123; getFileName(path,regexp); &#125; /** * 分析文件名并加入files * @param input */ private void getFileName(String path,String regexp) &#123; //目录 _path=path; _regexp=regexp; File directory = new File(_path); File[] filesFile = directory.listFiles(new MyFileFilter()); if (filesFile == null) return; for (int j = 0; j &lt; filesFile.length; j++) &#123; files.add(filesFile[j]); &#125; return; &#125; /** * 显示输出信息 * @param out */ public void print (PrintStream out) &#123; Iterator elements = files.iterator(); while (elements.hasNext()) &#123; File file=(File) elements.next(); out.println(file.getPath()); &#125; &#125; public static void output(String path,String regexp) &#123; FilesAnalyze fileGroup1 = new FilesAnalyze(path,regexp); fileGroup1.print(System.out); &#125; public static void main (String[] args) &#123; output(\"C://\",\"[A-z|.]*\"); &#125; Java正则的功用还有很多，事实上只要是字符处理，就没有正则做不到的事情存在。（正则解释时较耗时间就是了|||……）","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://feiyang.li/tags/Android/"},{"name":"Pattern","slug":"Pattern","permalink":"http://feiyang.li/tags/Pattern/"}]},{"title":"VelocityTracker滑动屏幕切换Activity","slug":"VelocityTracker_Activity","date":"2016-10-19T09:11:28.000Z","updated":"2016-10-20T07:13:10.520Z","comments":true,"path":"2016/10/19/VelocityTracker_Activity/index.html","link":"","permalink":"http://feiyang.li/2016/10/19/VelocityTracker_Activity/index.html","excerpt":"我现在非常恨自己手贱选了安卓这门课，作业多的令人发指。不过自己选的课，哭着也要上完。本文主要讲解如何实现 滑动屏幕时切换Activity","text":"我现在非常恨自己手贱选了安卓这门课，作业多的令人发指。不过自己选的课，哭着也要上完。本文主要讲解如何实现 滑动屏幕时切换Activity VelocityTracker简介 android.view.VelocityTracker主要用跟踪触摸屏事件（flinging事件和其他gestures手势事件）的速率。 用addMovement(MotionEvent)函数将Motion event加入到VelocityTracker类实例中。 使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。 使用recycleVelocityTracker()释放空间，循环使用。 当你需要跟踪触摸屏事件的速度的时候 使用obtain() 方法来获得 VelocityTracker 类的一个实例对象在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象使用computeCurrentVelocity (int units)函数来计算当前的速度，使用 getXVelocity ()、 getYVelocity ()函数来获得当前的速度。 使用VelocityTracker123456789101112131415161718192021222324252627private void initView()&#123; entryLayout = (RelativeLayout)super.findViewById(R.id.entry); entryLayout.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; createVelocityTracker(event); //获取实例对象 switch(event.getAction())&#123; case MotionEvent.ACTION_DOWN: // xDown=event.getX(); break; case MotionEvent.ACTION_MOVE: int xSpeed = getScrollVelocity(); xMove = event.getRawX(); int distanceX1 = (int) (xMove - xDown); int distanceX2 = (int) (xDown-xMove); if ((distanceX1 &gt; XDISTANCE_MIN||distanceX2&gt;XDISTANCE_MIN )&amp;&amp;(xSpeed&gt;XSPEED_MIN)) &#123; openNew(); &#125; break; case MotionEvent.ACTION_UP: recycleVelocityTracker(); &#125; return true; &#125; &#125;); &#125; 对于 MotionEventACTION_DOWN: 表示用户开始触摸. ACTION_MOVE: 表示用户在移动(手指或者其他) ACTION_UP:表示用户抬起了手指 ACTION_CANCEL:表示手势被取消了 ACTION_OUTSIDE: 表示用户触碰超出了正常的UI边界. ACTION_POINTER_DOWN:有一个非主要的手指按下了. ACTION_POINTER_UP:一个非主要的手指抬起来了 其余部分代码12345678910111213141516171819202122232425private int getScrollVelocity() &#123;//计算移动距离 mVelocityTracker.computeCurrentVelocity(1000); int velocity = (int) mVelocityTracker.getXVelocity(); return Math.abs(velocity); &#125; private void createVelocityTracker(MotionEvent event)&#123; if(mVelocityTracker == null)&#123; mVelocityTracker = VelocityTracker.obtain(); //获得VelocityTracker类实例 &#125; mVelocityTracker.addMovement(event);//将事件加入到VelocityTracker类实例中 &#125; private void recycleVelocityTracker()&#123; mVelocityTracker.recycle(); mVelocityTracker = null; &#125; private void openNew()&#123; Intent intent = new Intent(SCOSEntry.this,MainScreen.class); Bundle bundle = new Bundle(); bundle.putString(\"message\",\"FromEntry\"); intent.putExtras(bundle); startActivity(intent); &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://feiyang.li/tags/Android/"},{"name":"VelocityTracker","slug":"VelocityTracker","permalink":"http://feiyang.li/tags/VelocityTracker/"}]},{"title":"搭建个人SSR帐号及私人分享","slug":"SSR","date":"2016-10-19T06:13:18.000Z","updated":"2017-02-11T13:29:08.195Z","comments":true,"path":"2016/10/19/SSR/index.html","link":"","permalink":"http://feiyang.li/2016/10/19/SSR/index.html","excerpt":"本文转自1024社区，讲了一下SSR的搭建流程，并分享自己的SSR服务器。","text":"本文转自1024社区，讲了一下SSR的搭建流程，并分享自己的SSR服务器。 服务器配置安装SSR1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/shadowsocks_install/master/shadowsocksR.sh &amp;&amp; bash shadowsocksR.sh 锐速一键包1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh finalspeed 一键包1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/finalspeed/master/install_fs.sh &amp;&amp; bash install_fs.sh finalspeed客户端配置假设服务器 IP 为 10.10.10.10,finalspeed 端口为默认 150,ss 端口为 8989. 加速前提 ss 服务端运行正常, ss 客户端也能正常登录,运行FinalSpeed客户端,填写服务器地址 10.10.10.10 . 搭建个人SSR帐号及私人 点击添加,增加加速端口,加速端口为ss端口8989,如果为其他端口,请相应修改,本地端口任意,这里是2000 打开ss客户端,添加服务器,服务器IP为127.0.0.1,服务器端口为加速端口对应的本地端口,这里是2000,然后设置你的ss密码,加密方式 确定保存,选择使用刚添加的服务器,并设置浏览器代理,成功连接后,FinalSpeed状态栏会出现”连接服务器成功”提示.SSR 客户端、Xshell5和finalspeed客户端自己百度下载吧，我就不分享主要是不知用什么网盘分享，度盘不安全，免得被请去喝茶。 安卓版SSR下载地址下载地址：http://cdn.mmmxcc.cn/ssr_3.0.2.2.apk 因为本网站已经备案，所以。。。有什么问题可以留言或发送邮件~","categories":[],"tags":[{"name":"GFW","slug":"GFW","permalink":"http://feiyang.li/tags/GFW/"},{"name":"SSR","slug":"SSR","permalink":"http://feiyang.li/tags/SSR/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"}]},{"title":"无公网IP服务器搭建Web站点","slug":"without_IP_build_Website","date":"2016-10-19T05:25:29.000Z","updated":"2017-02-11T13:28:24.691Z","comments":true,"path":"2016/10/19/without_IP_build_Website/index.html","link":"","permalink":"http://feiyang.li/2016/10/19/without_IP_build_Website/index.html","excerpt":"前言很多时候我们都会碰到 无公网IP ，比如家用电脑，或者在阿里云上贪便宜买的服务器等。对于科大学生，就更容易出现这种情况了，科大学生可以从http://cloud.ustc.edu.cn/ 申请校内云主机，配置高，网速快，免流量，简直就是学生狗的福音啊。唯一的问题就是，提供的地址是校内IP，使用起来很不方便，搭建Web站点的时候就会遇到很多问题。","text":"前言很多时候我们都会碰到 无公网IP ，比如家用电脑，或者在阿里云上贪便宜买的服务器等。对于科大学生，就更容易出现这种情况了，科大学生可以从http://cloud.ustc.edu.cn/ 申请校内云主机，配置高，网速快，免流量，简直就是学生狗的福音啊。唯一的问题就是，提供的地址是校内IP，使用起来很不方便，搭建Web站点的时候就会遇到很多问题。 本文介绍一种免费内网穿透方案，ngrok 。 该方案与花生壳差不多，只不过花生壳变坏了，现在开始要钱，每个月还限制流量1g。对于网站来说，1个g能干什么，卖萌么。 在vps中下载对应版本的客户端本文以中国科大云的ubuntu系统为例，首先输入命令1sudo -s 本命令的作用是提升权限，否则之后会不停的要求输入密码的，然后下载客户端。1wget http://hls.ctopus.com/sunny/linux_amd64.zip 下载完毕之后，就要安装ngrok了。 注册端口获得隧道ID在安装之后，需要进入网站注册，注册的目的就是告诉服务器，你希望将服务器的哪个端口和自己的系统的哪个端口相映射，比如这个样子。 本地端口注意，需要填写本机在局域网内的IP地址和服务端口，我这里写的tcp：22，为了SSH连接使用的，当然也可以像下边这个样子。 这里可以使用前缀域名，也可以使用自己的域名，如果使用自己域名的话，需要将域名的CNAME指向到 server.ngrok.cc 。提醒一下，自定义域名会比前缀域名速度慢很多。复制一下，自动生成的隧道ID，一会儿有用哦~ 配置服务器参数服务器端配置完毕之后，回到自己的VPS控制台，输入12cd linux_amd64/nohup ./sunny clientid 9328c9d3f12326e9 后边那一串9328c9d3f12326e9 就是隧道ID，用自己的ID进行替换就好。解释一下nohup的作用，因为SSH连接断掉，或者退出该页面的话，会导致该ngrok关闭，使用nohup可以让本命令在后台运行，直接关毕SSH不会影响ngrok的运行。 切记，这可是一个晚上的深刻教训 啊。。。 这个时候应该就可以看到成功页面了，打开自己的网址就可以看到自己Web服务器里边的东西了~~ 这种内网穿透也就是所谓的TCP转发其实一点也不靠谱，速度巨慢。但是很多人为了调试微信小程序不得不使用这种方法，真心建议各位去闲鱼上，找个学生买个腾讯云服务器，一个月1块钱，而且还有公网IP。用起来不知道比这种方法快到哪里去了。","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://feiyang.li/tags/VPS/"},{"name":"Linux","slug":"Linux","permalink":"http://feiyang.li/tags/Linux/"}]},{"title":"回到了苏州","slug":"return_suzhou","date":"2016-10-08T12:28:44.000Z","updated":"2017-02-11T13:28:28.884Z","comments":true,"path":"2016/10/08/return_suzhou/index.html","link":"","permalink":"http://feiyang.li/2016/10/08/return_suzhou/index.html","excerpt":"又回到了苏州 今天我回到了苏州，想想昨天还在北京，和臭臭在一起吃KFC，就觉得好梦幻。","text":"又回到了苏州 今天我回到了苏州，想想昨天还在北京，和臭臭在一起吃KFC，就觉得好梦幻。 臭臭，你是我见到过最棒最好的女孩子了。我特别怕我让你失望，我一定会好好努力的。 以前我给你写的那些纸，都跟流水账一样的。因为我的确不会写日记，以前写日记就是早上干了什么晚上干了什么的，一通记录了事。我以后会好好写的，我做了好多事情，都对不起你。 我会努力的 我真觉得自己配不上你，但是我会努力的。我想和你一起留在北京，我想让你离妈妈爸爸近一些，我想看着孩子长大。 臭臭，谢谢你。","categories":[],"tags":[{"name":"love","slug":"love","permalink":"http://feiyang.li/tags/love/"}]},{"title":"今天我要去北京见臭臭啦","slug":"travel_to_peking","date":"2016-09-29T12:28:44.000Z","updated":"2017-02-11T13:28:20.163Z","comments":true,"path":"2016/09/29/travel_to_peking/index.html","link":"","permalink":"http://feiyang.li/2016/09/29/travel_to_peking/index.html","excerpt":"","text":"又可以见面了 现在是中午12点，我还在收拾东西，下午就要“坐”火车去北京了。 我真的很想臭臭。","categories":[],"tags":[{"name":"love","slug":"love","permalink":"http://feiyang.li/tags/love/"}]},{"title":"关于","slug":"resume","date":"2016-01-18T12:02:28.000Z","updated":"2017-03-23T11:43:52.275Z","comments":true,"path":"2016/01/18/resume/index.html","link":"","permalink":"http://feiyang.li/2016/01/18/resume/index.html","excerpt":"个人信息 李飞阳/男/1994 本科/华中科技大学 硕士/中国科学技术大学","text":"个人信息 李飞阳/男/1994 本科/华中科技大学 硕士/中国科学技术大学 Github：http://github.com/mmmwhy 工作经历360 产品经理 2016.03-2016.08360好药 需求设计 使用 Mockplus 完成 APP 1.6、1.7、1.8 产品需求分析和原型设计； 推进疾病症状搜索功能上线，提高用户搜索体验； 360电商云 前端原型设计 与运营人员沟通确认需求范围，整理需求优先级并提交技术排期开发； 360全球药 （国内最大赴印丙肝服务机构）前端后端需求 使用Axure设计360全球药前端页面原型； 设计全球药后台系统，完成多次活动策划方案的原型与后台设计； OPPO 产品经理 2014.07-2014.08产品服务质量提升 项目背景：微信客服好评率一直非常高，但在调研中发现该产品口碑却偏低。 项目目标：解释弹窗评价与调研反馈的差异，找出产品改进的方向，扭转差口碑的局面。 OPPO官方论坛改版 项目目标：由满足功能性为主转化为满足娱乐性需求，提高论坛的可玩性； 推广策划：使用 SWOT 和 3W 分析市场状况，根据 OPPO 服务理念设计朋友圈/微博营销方案，进行实施和效果评估。 致谢 hexo-theme-indigo 主题颜色搭配很出色，真的好棒。 360 进入互联网公司 OPPO 跳进产品狗的大坑 HUST 本科母校，一切都那么习惯 USTC 谢谢收留","categories":[],"tags":[{"name":"resume","slug":"resume","permalink":"http://feiyang.li/tags/resume/"}]}]}